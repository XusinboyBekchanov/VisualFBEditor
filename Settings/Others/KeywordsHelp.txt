------------------------------------------------------------- KeyPgDots ----
... (Ellipsis)

Used in place of procedure parameter to pass a variable number of 
arguments, or as the upper bound in an array declaration to denote that the 
number of elements will be determined by the initializer.

Syntax
   Declare { Sub | Function } proc_name cdecl ( param_list, ... )  { | [ 
   ByRef ] As return_type }

   #define identifier( [ parameters, ] variadic_parameter... ) body

   Dim array_symbol ([lbound To] ...) [As datatype] => { expression_list }

Description
   Variadic Procedures
      The ellipsis (three dots, ...) is used in procedure declarations and 
      definitions to indicate a variable argument list.

      A first argument (at least) must always be specified and the 
      procedure must be called with the C calling convention cdecl.

      In the procedure body, Cva_List data type, and Cva_Arg macro can be 
      used to expand the ellipsis parameter (...) to obtain the values of 
      the arguments passed to the variadic procedure.  The argument list, 
      once initialized with Cva_Start or copied with Cva_Copy, can be 
      passed to another procedure taking a Cva_List parameter.

      On some targets, for backwards compatibility, va_first, va_arg and 
      va_next can still be used to handle the variable arguments.

      Only numeric types and pointers are supported as variable arguments 
      (all bytes and shorts passed on variable arguments are implicitly 
      converted to integers, all singles passed on variable arguments are 
      implicitly converted to doubles).  Strings can be passed, in which 
      case a ZString Ptr to the string data is taken.

      A variadic procedure name can never be overloaded.

   Variadic Macros
      Using an ellipsis behind the last parameter in a #define or #macro 
      declaration allows creation of a variadic macro. This means it is 
      possible to pass any number of arguments to the variadic_parameter, 
      which can be used in the body as if it was a normal macro parameter. 
      The variadic_parameter will expand to the full list of arguments 
      passed to it, including commas, and can also be completely empty.

      Note: To distinguish between the different arguments passed by 
      variadic_parameter, you can first convert variadic_parameter to a 
      string using the Operator # (Preprocessor Stringize), then 
      differentiate in this string (#variadic_parameter) each passed 
      argument by locating the separators (usually a comma).

   Array Upper Bound
      Using an ellipsis in place of the upper bound in an array declaration 
      causes the upper bound to be set according to the data that appears 
      in the expression_list.  When the ellipsis is used in this manner, an 
      initializer must appear, and cannot be Any.

Example
   Declare Function foo cdecl (x As Integer, ...) As Integer

   Dim As Integer myarray(0 To ...) = {0, 1, 2, 3}
   Print LBound(myarray), UBound(myarray)   '' 0, 3

   '' Using a variadic macro to wrap a variadic function
   #include "crt.bi"
   #define eprintf(Format, args...) fprintf(stderr, Format, args)
   eprintf(!"Hello from printf: %i %s %i\n", 5, "test", 123)

   '' LISP-like accessors allowing to modify comma-separated lists
   #define car(a, b...) a
   #define cdr(a, b...) b

Differences from QB
   * New to FreeBASIC

See also
   * cdecl
   * Cva_List
   * Cva_Arg
   * va_arg
   * va_first
   * va_next
   * Dim
   * Static
   * #define




============================================================================
    _

----------------------------------------------------------- KeyPgDddate ----
__DATE__

Intrinsic define (macro value) set by the compiler

Syntax
   __DATE__

Description
   Substitutes the compiler date in a literal string ("mm-dd-yyyy" format) 
   where used.

Example
   Print "Compile Date: " & __DATE__


   Compile Date: 09-29-2011

Differences from QB
   * New to FreeBASIC

See also
   * __DATE_ISO__
   * __TIME__
   * Date



-------------------------------------------------------- KeyPgDddateiso ----
__DATE_ISO__

Intrinsic define (macro value) set by the compiler

Syntax
   __DATE_ISO__

Description
   Substitutes the compiler date in a literal string ("yyyy-mm-dd" format) 
   where used.  This format is in line with ISO 8601 and can be used for 
   lexicographical date comparisons.

Example
   Print "Compile Date: " & __DATE_ISO__

   If __DATE_ISO__ < "2011-12-25" Then
      Print "Compiled before Christmas day 2011"
   Else
      Print "Compiled after Christmas day 2011"
   End If


   Compile Date: 2011-09-29
   Compiled before Christmas Day 2011

Differences from QB
   * New to FreeBASIC

See also
   * __DATE__
   * __TIME__
   * Date



-------------------------------------------------------- KeyPgDdfb64bit ----
__FB_64BIT__

Intrinsic define set by the compiler

Syntax
   __FB_64BIT__

Description
   Define created at compile time if the the compilation target is 64bit, 
   otherwise undefined.

Example
   #ifdef __FB_64BIT__
     '...instructions for 64bit OSes...
   #else
     '...instructions for other OSes
   #endif 

Differences from QB
   * New to FreeBASIC

See also
   * __FB_LINUX__
   * __FB_FREEBSD__
   * __FB_OPENBSD__
   * __FB_NETBSD__
   * __FB_CYGWIN__
   * __FB_DARWIN__
   * __FB_PCOS__
   * Compiler Option: -target



----------------------------------------------------- KeyPgDdfbargcount ----
__FB_ARG_COUNT__

Intrinsic define (macro) performed by the compiler.

Syntax
   __FB_ARG_COUNT__( args... )

Parameters
   args...
      argument list

Description
   Counts the number of arguments in the argument list (args...) and 
   returns the corresponding value.
   A value is always returned, with 0 corresponding to an empty argument 
   list.

   Because the argument separator is the comma (,), the returned value for 
   a non-empty argument list is the number of main commas (non-nested) plus 
   1.

Example
   #macro m( args... )
      Print __FB_ARG_COUNT__( args )
   #endmacro

   m()
   m(a)
   m(b,c)
   m(,d)
   m(,e,)
   m(,,,)

   Sleep

   /' Output:
    0
    1
    2
    2
    3
    4
   '/
      

   ' macro with a variadic parameter which can contain several sub-parameters:
   '   To distinguish between the different arguments passed by a variadic_parameter,
   '   you can first convert the variadic_parameter to a string using the Operator # (Preprocessor Stringize),
   '   then differentiate in this string (#variadic_parameter) each passed argument by locating the separators (usually a comma)
   '   in a [For...Next] loop based on the number of arguments (__FB_ARG_COUNT__) passed to the macro.

   #macro average(result, arg...)
      Scope
         Dim As String s = #arg
         If s <> "" Then
            result = 0
            For I As Integer = 1 To __FB_ARG_COUNT__( arg ) - 1
               Dim As Integer k = InStr(1, s, ",")
               result += Val(Left(s, k - 1))
               s = Mid(s, k + 1)
            Next I
            result += Val(s)
            result /= __FB_ARG_COUNT__( arg )
         End If
      End Scope
   #endmacro

   Dim As Double result
   average(result, 1, 2, 3, 4, 5, 6)
   Print result

   Sleep

   /' Output :
    3.5
   '/
      

Version
   * Since fbc 1.08.0

Differences from QB
   * New to FreeBASIC

See also
   * __FB_ARG_LEFTOF__
   * __FB_ARG_RIGHTOF__
   * __FB_ARG_EXTRACT__



--------------------------------------------------- KeyPgDdfbargextract ----
__FB_ARG_EXTRACT__

Intrinsic define (macro) performed by the compiler.

Syntax
   __FB_ARG_EXTRACT__( index, args... )

Parameters
   index
      zero-based offset from the first argument (zero or positive integer 
      value)
   args...
      argument list

Description
   Returns the argument from the argument list (args...) corresponding to 
   the index value (index).

   If the requested index value refers to an argument that does not exist 
   in the supplied argument list (index value too large), nothing is 
   returned.

Example
   #print __FB_ARG_EXTRACT__( 1, 7, 89.78, "Postman" )

   /' Compiler output:
   89.78
   '/
      

   '   In this example, the '__FB_EVAL__' is absolutely mandatory in this 'print_last' macro,
   '   because the numeric expression '__FB_ARG_COUNT__( args ) - 1' must be fully evaluated
   '   before being used as the index argument of '__FB_ARG_EXTRACT__'

   #macro print_last( args... )
      #define last_arg_num __FB_EVAL__( __FB_ARG_COUNT__( args ) - 1 )
      #print __FB_ARG_EXTRACT__( last_arg_num, args )
   #endmacro

   print_last( 7, 89.78, "Postman" )

   /' Compiler output:
   Postman
   '/
      

Version
   * Since fbc 1.08.0

Differences from QB
   * New to FreeBASIC

See also
   * __FB_ARG_LEFTOF__
   * __FB_ARG_RIGHTOF__
   * __FB_ARG_COUNT__



---------------------------------------------------- KeyPgDdfbargleftof ----
__FB_ARG_LEFTOF__

Intrinsic define (macro) performed by the compiler.

Syntax
   __FB_ARG_LEFTOF__( arg, sep [, ret] )

Parameters
   arg
      argument
   sep
      separator, obviously different from the comma (,)
   ret
      default return if separator not found

Description
   Returns the left token of the argument (arg), based on the separator (
   sep).
   (in the expression of the argument, the tokens and the separator must be 
   spaced)

   By default, if the default return (ret) is not given, the macro returns 
   nothing (empty token) if the separator (sep) is not found.
   Otherwise, if the default return (ret) is given, the macro returns the 
   default return (ret) if the separator (sep) is not found.

Example
   #macro m( arg )
      Scope
         Var v = __FB_ARG_LEFTOF__( arg, versus, "Not found 'versus'" )
         Print v
      End Scope
   #endmacro

   m(1 versus 2)
   m("left-side" versus "right-side")
   m(3.14 verso pi)

   Sleep

   /' Output:
    1
   left-side
   Not found 'versus'
   '/

   See also __FB_ARG_RIGHTOF__ example.

Version
   * Since fbc 1.08.0

Differences from QB
   * New to FreeBASIC

See also
   * __FB_ARG_RIGHTOF__
   * __FB_ARG_COUNT__
   * __FB_ARG_EXTRACT__



--------------------------------------------------- KeyPgDdfbargrightof ----
__FB_ARG_RIGHTOF__

Intrinsic define (macro) performed by the compiler.

Syntax
   __FB_ARG_RIGHTOF__( arg, sep [, ret] )

Parameters
   arg
      argument
   sep
      separator, obviously different from the comma (,)
   ret
      default return if separator not found

Description
   Returns the right token of the argument (arg), based on the separator (
   sep).
   (in the expression of the argument, the tokens and the separator must be 
   spaced)

   By default, if the default return (ret) is not given, the macro returns 
   nothing (empty token) if the separator (sep) is not found.
   Otherwise, if the default return (ret) is given, the macro returns the 
   default return (ret) if the separator (sep) is not found.

Example
   #macro m( arg )
      Scope
         Var v = __FB_ARG_RIGHTOF__( arg, versus, "Not found 'versus'" )
         Print v
      End Scope
   #endmacro

   m(1 versus 2)
   m("left-side" versus "right-side")
   m(pi verso 3.14)

   Sleep

   /' Output:
    2
   right-side
   Not found 'versus'
   '/

   #macro count( range )
      Scope
         Dim x As Integer = __FB_ARG_LEFTOF__( range, To )
         Dim y As Integer = __FB_ARG_RIGHTOF__( range, To )
         Dim s As Integer = Sgn(y - x)
         Print "Counting " & #range
         For i As Integer = x To y Step s
            Print i
         Next i
      End Scope

   #endmacro

   count( 4 To 10 )
   count( 7 To 2 )

   Sleep

   /' Output:
   Counting 4 to 10
    4
    5
    6
    7
    8
    9
    10
   Counting 7 to 2
    7
    6
    5
    4
    3
    2
   '/

Version
   * Since fbc 1.08.0

Differences from QB
   * New to FreeBASIC

See also
   * __FB_ARG_LEFTOF__
   * __FB_ARG_COUNT__
   * __FB_ARG_EXTRACT__



--------------------------------------------------------- KeyPgDdfbargc ----
__FB_ARGC__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_ARGC__

Description
   Substituted with the number of arguments passed in on the command line.

   __FB_ARGC__ is the name of a parameter passed to the program's implicit 
   main function, and therefore is only defined in the module level code of 
   the main module for an application.

Example
   Dim i As Integer
   For i = 0 To __FB_ARGC__ - 1
         Print "arg "; i; " = '"; Command(i); "'"
   Next i

Differences from QB
   * New to FreeBASIC

See also
   * __FB_ARGV__
   * Command



--------------------------------------------------------- KeyPgDdfbargv ----
__FB_ARGV__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_ARGV__

Description
   Substituted with a pointer to a list of pointers to the zero terminated 
   command line arguments passed in on the command line.

   __FB_ARGV__ is the name of a parameter passed to the program's implicit 
   main function, and therefore is only defined in the module level code of 
   the main module for an application.

Example
   Declare Function main _
     ( _
      ByVal argc As Integer, _
      ByVal argv As ZString Ptr Ptr _
     ) As Integer

     End main( __FB_ARGC__, __FB_ARGV__ )

   Private Function main _
     ( _
      ByVal argc As Integer, _
      ByVal argv As ZString Ptr Ptr _
     ) As Integer

     Dim i As Integer
     For i = 0 To argc - 1
         Print "arg "; i; " = '"; *argv[i]; "'"
     Next i

     Return 0

   End Function

Differences from QB
   * New to FreeBASIC

See also
   * __FB_ARGC__
   * Command



---------------------------------------------------------- KeyPgDdfbarm ----
__FB_ARM__

Intrinsic define set by the compiler

Syntax
   __FB_ARM__

Description
   Define created at compile time if the compilation target uses the ARM 
   CPU architecture, otherwise undefined.

Example
   #ifdef __FB_ARM__
     '...instructions for ARM OSes...
   #else
     '...instructions for other OSes
   #endif 

Differences from QB
   * New to FreeBASIC

See also
   * __FB_X86__
   * __FB_LINUX__
   * __FB_FREEBSD__
   * __FB_OPENBSD__
   * __FB_NETBSD__
   * __FB_CYGWIN__
   * __FB_DARWIN__
   * __FB_PCOS__
   * Compiler Option: -target



---------------------------------------------------------- KeyPgDdfbasm ----
__FB_ASM__

Intrinsic define set by the compiler

Syntax
   __FB_ASM__

Description
   __FB_ASM__ returns a string equal to "intel" or "att" depending on 
   whether inline assembly blocks should use the Intel format or the 
   GCC/AT&T format.

Example
   Dim a As Long
   #if __FB_ASM__ = "intel"
      Asm
          inc dword Ptr [a]
      End Asm
   #else
      Asm
         "incl %0\n" : "+m" (a) : :
      End Asm
   #endif

Version
   * Since fbc 1.02.0

Differences from QB
   * New to FreeBASIC

See also
   * Compiler Option: -asm



------------------------------------------------------ KeyPgDdFBBackend ----
__FB_BACKEND__

Intrinsic define set by the compiler

Syntax
   __FB_BACKEND__

Description
   Defined to either "gas" or "gcc", depending on which backend was 
   specified via -gen.

Example
   Print "Back end is: " & __FB_BACKEND__
      

Differences from QB
   * Did not exist in QB



---------------------------------------------------- KeyPgDdFBBigEndian ----
__FB_BIGENDIAN__

Intrinsic define set by the compiler

Syntax
   __FB_BIGENDIAN__

Description
   Define without a value created at compile time if compiling for a big 
   endian target.

   It can be used to compile parts of the program only if the target is big 
   endian.

Example
   #ifdef __FB_BIGENDIAN__
      '...instructions only for big endian machines
   #else
     '...instructions only for little endian machines
   #endif 

Differences from QB
   * Did not exist in QB



---------------------------------------------------- KeyPgDdFBBuildDate ----
__FB_BUILD_DATE__

Intrinsic define (macro string) set by the compiler

Syntax
   __FB_BUILD_DATE__

Description
   Substituted with the quoted string containing the date (MM-DD-YYYY) the 
   compiler was built on.

Example
      Print "This program compiled with a compiler built on this date:" & __FB_BUILD_DATE__

Differences from QB
   * New to FreeBASIC

See also
   * __FB_BUILD_DATE_ISO__
   * __DATE__
   * __DATE_ISO__



------------------------------------------------- KeyPgDdfbbuilddateiso ----
__FB_BUILD_DATE_ISO__

Intrinsic define (macro string) set by the compiler

Syntax
   __FB_BUILD_DATE_ISO__

Description
   Substituted with the quoted string containing the date (YYYY-MM-DD) the 
   compiler was built on in ISO date format.

Example
      Print "This program compiled with a compiler built on this date:" & __FB_BUILD_DATE_ISO__

Version
   * Since fbc 1.07.1

Differences from QB
   * New to FreeBASIC

See also
   * __FB_BUILD_DATE__
   * __DATE__
   * __DATE_ISO__



---------------------------------------------------- KeyPgDdfbbuildsha1 ----
__FB_BUILD_SHA1__

Intrinsic define (macro string) set by the compiler

Syntax
   __FB_BUILD_SHA1__

Description
   Substituted by a string of the compiler's source SHA-1 revision.  The 
   value is set using the SHA-1 commit id of the source code revision used 
   to build the compiler binary, if available.  If the SHA-1 was not 
   available at the time of building the compiler, the value will be an 
   empty string.

Example
   Print __FB_BUILD_SHA1__

Version
   * Since fbc 1.07.1

Differences from QB
   * New to FreeBASIC



------------------------------------------------------- KeyPgDdfbcygwin ----
__FB_CYGWIN__

Intrinsic define set by the compiler

Syntax
   __FB_CYGWIN__

Description
   Define without a value created at compile time in the Cygwin version of 
   the compiler, or when the -target cygwin command line option is used. It 
   can be used to compile parts of the program only if the target is 
   Cygwin.

Example
   #ifdef __FB_CYGWIN__
     '...instructions only for Cygwin...
   #else
     '...instructions not for Cygwin...
   #endif 

Differences from QB
   * New to FreeBASIC

See also
   * __FB_LINUX__
   * __Fb_Win32_
   * __FB_UNIX__
   * Compiler Option: -target



------------------------------------------------------- KeyPgDdfbdarwin ----
__FB_DARWIN__

Intrinsic define set by the compiler

Syntax
   __FB_DARWIN__

Description
   Define without a value created at compile time in the Darwin version of 
   the compiler, or when the -target darwin command line option is used. It 
   can be used to compile parts of the program only if the target is 
   Darwin.

Example
   #ifdef __FB_DARWIN__
     '...instructions only for Darwin...
   #else
     '...instructions not for Darwin...
   #endif 

Differences from QB
   * New to FreeBASIC

See also
   * __FB_LINUX__
   * __FB_WIN32__
   * __FB_UNIX__
   * Compiler Option: -target



-------------------------------------------------------- KeyPgDdfbdebug ----
__FB_DEBUG__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_DEBUG__

Description
   __FB_DEBUG__ indicates if the the generate debug information option -g 
   or the enable intrinsic define __FB_DEBUG__ option 
   Compiler Option: -edebug was specified on the command line at the time 
   of compilation.

   Returns non-zero (-1) if either option was specified.  Returns zero (0) 
   otherwise.

   __FB_ERR__ can be used to determine in user source code if the -g or 
   -edebug option was specified or implied on the command line.

Example
   #if __FB_DEBUG__ <> 0
         #print Debug mode 
   #else 
         #print Release mode 
   #endif

Differences from QB
   * New to FreeBASIC

See also
   * __FB_ERR__
   * __FB_MT__
   * Compiler Option: -edebug
   * Compiler Option: -g



---------------------------------------------------------- KeyPgDdfbdos ----
__FB_DOS__

Intrinsic define set by the compiler

Syntax
   __FB_DOS__

Description
   Define without a value created at compile time if compiling for the DOS 
   target. Default in the DOS hosted version, or active when the -target dos
   command line option is used. It can be used to compile parts of the 
   program only if the target is DOS. Note: the DOS hosted version cannot 
   compile to other targets than DOS by now.

Example
   #ifdef __FB_DOS__
     ' ... instructions only for DOS ...
     ' ... INT 0x31
   #else
     ' ... instructions not for DOS ...
   #endif 

Differences from QB
   * New to FreeBASIC

See also
   * __FB_LINUX__
   * __FB_WIN32__
   * __FB_PCOS__
   * DOS related FAQ
   * Compiler Option: -target



---------------------------------------------------------- KeyPgDdfberr ----
__FB_ERR__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_ERR__

Description
   __FB_ERR__ indicates if -e, -ex, or -exx was specified on the compiler 
   command line at the time of compilation of a module.

   __FB_ERR__ indicates if -earray, -enullptr, or -elocation was specified 
   on the compiler command line, or implied by use of -exx, at the time of 
   compilation of a module.

   __FB_ERR__ indicates if -edebug, -edebuginfo, or -eassert was specified 
   on the compiler command line, or implied by use of -g, at the time of 
   compilation of a module.

   Returns bit-wise OR of the following values:
         +-----+---------------------------------------------------------+
         |value|description                                              |
         |0    |'-e', '-ex', '-exx' and other error options not specified|
         |1    |'-e' was specified                                       |
         |3    |'-ex' was specified (implies '-e')                       |
         |7    |'-exx' was specified (implies '-e, -ex')                 |
         |8    |'-earray' was specified (or implied by '-exx')           |
         |16   |'-enullptr' was specified (or implied by '-exx')         |
         |32   |'-eassert' was specified (or implied by '-g')            |
         |64   |'-edebuginfo' was specified (or implied by '-g')         |
         |128  |'-edebug' was specified (or implied by '-g')             |
         |256  |'-elocation' was specified (or implied by '-exx')        |
         +-----+---------------------------------------------------------+

   __FB_ERR__ is always defined.

Example
   'Example code to demonstrate a use of __FB_ERR__
   Dim err_command_line As UByte
   err_command_line = __FB_ERR__
   Select Case err_command_line
   Case 0
   Print "No Error Checking enabled on the Command Line!"
   Case 1
   Print "Some Error Checking enabled on the Command Line!"
   Case 3
   Print "QBasic style Error Checking enabled on the Command Line!"
   Case 7
   Print "Extreme Error Checking enabled on the Command Line!"
   Case Else
   Print "Some Unknown Error level has been set!"
   End Select

Differences from QB
   * New to FreeBASIC

See also 
   * __FB_MT__
   * __FB_DEBUG__
   * Compiler Option: -e
   * Compiler Option: -ex
   * Compiler Option: -exx
   * Error Handling



--------------------------------------------------------- KeyPgDdfbeval ----
__FB_EVAL__

Intrinsic define (macro) performed by the compiler.

Syntax
   __FB_EVAL__( arg )

Parameters
   arg
      argument

Description
   Evaluates the argument (constant-expression) at compile time.

   When the argument evaluation produces a string, __FB_EVAL__ returns a 
   string formatted with a preprocessor operator:
      - a Non-Escaped String Literal (of form: $"text"),
      - or an Escaped String Literal (of form: !"text") if needed.
   For other datatypes produced, simple Literals (of Integers, Floating 
   Points, Booleans) without prefix/suffix are returned.

   __FB_EVAL__ macro is useful where there is any of the following:
      - non functional expression (i.e. side-effects),
      - needs to be evaluated (i.e. simplified, respecting the operator 
      precedence) before passing it on,
      - used in a place where fbc would not allow an expression.

Example
   #print 1 + 2
   #print __FB_EVAL__( 1 + 2 )
   #print 4 * Atn(1)
   #print __FB_EVAL__( 4 * Atn(1) )

   /' Compiler output:
   1 + 2
   3
   4 * Atn(1)
   3.141592653589793
   '/
      

   '   In this example, the three '__FB_EVAL__' are absolutely mandatory in this 'assign()' macro.
   '   Even for '__FB_QUOTE__( __FB_EVAL__( expr ) )', because for the case of expr = cos(1/x),
   '   'cos(1/x)' must be properly evaluated before be quoted (after the previous 'assign("x", x+1)'),
   '   otherwise in that case 'cos(1/x+1)' is taken into account (giving 'cos(2)') instead of 'cos(1/(x+1))' (giving 'cos (1/2)')
   '   because the operator precedence is not applied by '__FB_QUOTE__'.

   #macro assign( sym, expr )
      __FB_UNQUOTE__( __FB_EVAL__( "#undef " + sym ) )
      __FB_UNQUOTE__( __FB_EVAL__( "#define " + sym + " " + __FB_QUOTE__( __FB_EVAL__( expr ) ) ) )
   #endmacro

   #define x

   assign( "x", 1 )
   Print x

   assign( "x", x+1 )
   Print x

   assign( "x", Cos(1/x) )
   Print x

   assign( "x", "hello" )
   Print x

   assign( "x", x+x )
   Print x

   /' Output:
    1
    2
    0.877582...
   hello
   hellohello
   '/
      

   See also __FB_ARG_EXTRACT__ example.

Version
   * Since fbc 1.08.0

Differences from QB
   * New to FreeBASIC

See also
   * __FB_QUOTE__
   * __FB_UNQUOTE__



------------------------------------------------------- KeyPgDdfbfpmode ----
__FB_FPMODE__

Intrinsic define set by the compiler

Syntax
   __FB_FPMODE__

Description
   Defined as "fast" if SSE fast arithmetics is enabled, or "precise" 
   otherwise.

Example
   #if __FB_FPMODE__ = "fast"
     ' ... instructions for using fast-mode math ...
   #else
     ' ... instructions for using normal math ...
   #endif

Differences from QB
   * New to FreeBASIC

See also
   * Compiler Option: -fpmode



---------------------------------------------------------- KeyPgDdfbfpu ----
__FB_FPU__

Intrinsic define set by the compiler

Syntax
   __FB_FPU__

Description
   Defined as "sse" if SSE floating point arithmetics is enabled, or "x87" 
   otherwise.

Example
   #if __FB_FPU__ = "sse"
     ' ... instructions only for SSE ...
   #else
     ' ... instructions not for SSE ...
   #endif

Differences from QB
   * New to FreeBASIC

See also
   * __FB_SSE__
   * Compiler Option: -fpu



------------------------------------------------------ KeyPgDdfbfreebsd ----
__FB_FREEBSD__

Intrinsic define set by the compiler

Syntax
   __FB_FREEBSD__

Description
   Define without a value created at compile time in the FreeBSD version of 
   the compiler, or when the -target freebsd command line option is used. 
   It can be used to compile parts of the program only if the target is 
   FreeBSD.

Example
   #ifdef __FB_FREEBSD__
     '...instructions only for FreeBSD...
   #else
     '...instructions not for FreeBSD...
   #endif 

Differences from QB
   * New to FreeBASIC

See also
   * __FB_LINUX__
   * __FB_WIN32__
   * __FB_UNIX__
   * Compiler Option: -target



---------------------------------------------------------- KeyPgDdfbgcc ----
__FB_GCC__

Intrinsic define set by the compiler

Syntax
   __FB_GCC__

Description
   Defined to true (-1) if -gen gcc is used, or false (0) otherwise.

Example
   #if __FB_GCC__ <> 0
         #print Backend Code Emitter And Assembler: gcc
   #else 
         #print Backend Code Emitter And Assembler: Not gcc
   #endif
      

Differences from QB
   * Did not exist in QB



---------------------------------------------------------- KeyPgDdfbgui ----
__FB_GUI__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_GUI__

Description
   __FB_GUI__ indicates if the executable subsystem option '-s gui' was 
   specified on the command line at the time of compilation.

   Returns non-zero (-1) if the executable subsystem option '-s gui' was 
   specified. Returns zero (0) otherwise (no executable subsystem option 
   specified, or executable subsystem option '-s console' specified).

Example
   #if __FB_GUI__ <> 0
         #print Executable subsystem: gui
   #else 
         #print Executable subsystem: console
   #endif

Version
   * Since fbc 1.06.0

Platform Differences
   * Supported on Windows and Cygwin only.

Differences from QB
   * New to FreeBASIC

See also
   * Compiler Option: -s



--------------------------------------------------------- KeyPgDdfbjoin ----
__FB_JOIN__

Intrinsic define (macro) performed by the compiler.

Syntax
   __FB_JOIN__( arg1, arg2 )

Parameters
   arg1, arg2
      left (1) and right (2) arguments to join

Description
   Joins two token arguments together as one, similar to token pasting 
   operator (##) but more powerfull (will resolve arguments before 
   joining).

Example
   #macro m ( arg1, arg2 )
      #print arg1##arg2
      #print __FB_JOIN__( arg1, arg2 )
   #endmacro

   m(Free, BASIC)

   /' Compiler output:
   FreeBASIC
   FreeBASIC
   '/
      

   #define PREFIX p
   #define SUFFIX _T

   '' this won't work - arguments not expanded
   #define   makename1( x )  PREFIX##x##SUFFIX

   '' this will work - can do this in older versions of fbc too
   #define join( a, b ) a##b
   #define makename2( x ) join( PREFIX, join( x, SUFFIX ) )

   '' built in __FB_JOIN__() -- works pretty much like join() above
   #define   makename3( x )  __FB_JOIN__( PREFIX, __FB_JOIN__( x, SUFFIX ) )

   #macro dump( arg )
      #print #arg
   #endmacro

   dump( makename1(text) )
   dump( makename2(text) )
   dump( makename3(text) )

   /' Compiler output:
   PREFIXtextSUFFIX
   ptext_T
   ptext_T
   '/
      

Version
   * Since fbc 1.08.0

Differences from QB
   * New to FreeBASIC

See also
   * Operator ## (Preprocessor Concatenate)



--------------------------------------------------------- KeyPgDdfblang ----
__FB_LANG__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_LANG__

Description
   __FB_LANG__ indicates which language compatibility option was set at the 
   time of compilation of a module.  By default __FB_LANG__ will be set to 
   "fb".  The language compatibility option can be changed using one (or 
   more) of the following methods:
      * -lang command line option
      * -forcelang command line option
      * #lang directive
      * $Lang metacommand

   Returns a lower case string with one of the following values:
         +--------------+----------------------------------------------------------------------------+
         |value         |description                                                                 |
         |''fb''        |FreeBASIC compatibility (default)                                           |
         |''qb''        |QBASIC compatibility                                                        |
         |''fblite''    |FreeBASIC language compatibility, with a more QBASIC-compatible coding style|
         |''deprecated''|FBC version 0.16 compatibility                                              |
         +--------------+----------------------------------------------------------------------------+

   __FB_LANG__ is always defined.

Example
   '' Set option explicit always on

   #ifdef __FB_LANG__
     #if __FB_LANG__ <> "fb"
      Option Explicit
     #endif
   #else
     '' Older version - before lang fb
     Option Explicit
   #endif

Differences from QB
   * New to FreeBASIC

See also 
   * __FB_VERSION__
   * #lang
   * Compiler Option: -lang
   * Compiler Option: -forcelang
   * Compiler Dialects



-------------------------------------------------------- KeyPgDdfblinux ----
__FB_LINUX__

Intrinsic define set by the compiler

Syntax
   __FB_LINUX__

Description
   Define without a value created at compile time when compiling to the 
   Linux target. Default in the Linux hosted version of the compiler, or 
   active when the -target linux command line option is used. It can be 
   used to compile parts of the program only if the target is Linux.

Example
   #ifdef __FB_LINUX__
     ' ... instructions only for Linux ...
     ' ... #libpath "/usr/X11/lib" 
   #else
     ' ... instructions not for Linux ...
   #endif 

Differences from QB
   * New to FreeBASIC

See also
   * __FB_DOS__
   * __FB_WIN32__
   * __FB_UNIX__
   * Compiler Option: -target



--------------------------------------------------------- KeyPgDdFBMain ----
__FB_MAIN__

Intrinsic define set by the compiler

Syntax
   __FB_MAIN__

Description
   __FB_MAIN__ is defined in the main module and not defined in other 
   modules.

   The main module is determined by the compiler as either the first source 
   file listed on the command line or explicitly named using the -m option 
   on the command line.

Example
   #ifdef __FB_MAIN__
     #print Compiling the main module
   #else
     #print Compiling an additional module
   #endif

Differences from QB
   * New to FreeBASIC

See also
   * Compiler Option: -m
   * #ifdef
   * #ifndef



--------------------------------------------------- KeyPgDdFBMinVersion ----
__FB_MIN_VERSION__

Macro function to test minimum compiler version

Syntax
   #define __FB_MIN_VERSION__( major, minor, patch) _
      ((__FB_VER_MAJOR__ > major) or _
      ((__FB_VER_MAJOR__ = major) and ((__FB_VER_MINOR__ > minor) or _
      (__FB_VER_MINOR__ = minor and __FB_VER_PATCH__ >= patch_level))))

Usage
   __FB_MIN_VERSION__( major, minor, patch)

Parameters
   major
      minimum major version to test
   minor
      minimum minor version to test
   patch
      minimum patch version to test

Return Value
   Returns zero (0) if the compiler version is less than the specified 
   version, or non-zero (-1) if the compiler version is greater than or 
   equal to specified version

Description
   __FB_MIN_VERSION__ tests for a minimum version of the compiler.

Example
   #if Not __FB_MIN_VERSION__(0, 18, 2)
       #error fbc must be at least version 0.18.2 To compile This module
   #endif

Differences from QB
   * New to FreeBASIC

See also
   * #if



----------------------------------------------------------- KeyPgDdfbmt ----
__FB_MT__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_MT__

Description
   __FB_MT__ indicates if the the multithreaded option -mt was specified on 
   the command line at the time of compilation, or whether one of the 
   Threadtcreate or ThreadCall keywords is used more above in the source 
   code.

   Returns non-zero (-1) if the option was specified.  Returns zero (0) 
   otherwise.

Example
   #if __FB_MT__ 
         #print Using multi-threaded library
   #else
         #print Using Single-threaded library
   #endif

Differences from QB
   * New to FreeBASIC

See also 
   * __FB_DEBUG__
   * Compiler Option: -mt



------------------------------------------------------- KeyPgDdfbnetbsd ----
__FB_NETBSD__

Intrinsic define set by the compiler

Syntax
   __FB_NETBSD__

Description
   Define without a value created at compile time in the NetBSD version of 
   the compiler, or when the -target netbsd command line option is used. It 
   can be used to compile parts of the program only if the target is NetBSD
   .

Example
   #ifdef __FB_NETBSD__
     '...instructions only for NetBSD...
   #else
     '...instructions not for NetBSD...
   #endif 

Differences from QB
   * New to FreeBASIC

See also
   * __FB_LINUX__
   * __FB_WIN32__
   * __FB_UNIX__
   * Compiler Option: -target



------------------------------------------------------ KeyPgDdfbopenbsd ----
__FB_OPENBSD__

Intrinsic define set by the compiler

Syntax
   __FB_OPENBSD__

Description
   Define without a value created at compile time in the OpenBSD version of 
   the compiler, or when the -target openbsd command line option is used. 
   It can be used to compile parts of the program only if the target is 
   OpenBSD.

Example
   #ifdef __FB_OPENBSD__
     '...instructions only for OpenBSD...
   #else
     '...instructions not for OpenBSD...
   #endif 

Differences from QB
   * New to FreeBASIC

See also
   * __FB_LINUX__
   * __FB_WIN32__
   * __FB_UNIX__
   * Compiler Option: -target



----------------------------------------------------- KeyPgDdfboptimize ----
__FB_OPTIMIZE__

Intrinsic define set by the compiler

Syntax
   __FB_OPTIMIZE__

Description
   Always defined and will have a value from 0 to 3 (0 by default) to 
   indicate the optimization level passed to the backend compiler via -O.

Example
   Print "Optimization level is: " & __FB_OPTIMIZE__
      

Version
   * Since fbc 1.09.0

Differences from QB
   * Did not exist in QB

See also
   * Compiler Option: -O



-------------------------------------------------- KeyPgDdfboptionbyval ----
__FB_OPTION_BYVAL__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_OPTION_BYVAL__

Description
   Indicates if parameters to a Function or Sub are passed by reference as 
   with ByRef, or by value as with ByVal by default when the by value / by 
   reference specifier is not explicitly stated.

   __FB_OPTION_BYVAL__ is set to non-zero (-1) if by default parameters are 
   passed value, and zero (0) if by default parameters are passed by 
   reference.

   The default for passing parameters by reference or by value is 
   determined by the -lang command line option used during compilation or 
   usage of Option ByVal in the source file.

Example
   #if( __FB_OPTION_BYVAL__ <> 0 )
     #error Option ByVal must Not be used With This source
   #endif

Differences from QB
   * New to FreeBASIC

See also 
   * ByVal
   * ByRef
   * Option ByVal



------------------------------------------------ KeyPgDdfboptiondynamic ----
__FB_OPTION_DYNAMIC__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_OPTION_DYNAMIC__

Description
   __FB_OPTION_DYNAMIC__ is defined as true (negative one (-1)) if a recent 
   Option Dynamic statement or '$Dynamic meta-command was issued. 
   Otherwise, it is defined as zero (0).

Example
   #if __FB_OPTION_DYNAMIC__ <> 0
   #error This module must Not use Option Dynamic
   #endif

Differences from QB
   * New to FreeBASIC

See also 
   * Option Dynamic
   * Option Static



------------------------------------------------- KeyPgDdfboptionescape ----
__FB_OPTION_ESCAPE__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_OPTION_ESCAPE__

Description
   Indicates if by default, string literals are processed for escape 
   characters when not explicitly prefixed with the $ Operator for 
   non-escaped strings, or the ! Operator for escaped strings.

   The default method for processing string literals is set by usage of the 
   -lang command line option during compilation or usage of Option Escape 
   in the source file.

   __FB_OPTION_ESCAPE__ returns zero (0) if the option has not been set.  
   Returns non-zero (-1) if the option has been set.

Example
   #if( __FB_OPTION_ESCAPE__ <> 0 )
     #error Option Escape must Not be used With This include file
   #endif

Differences from QB
   * New to FreeBASIC

See also 
   * Option Escape



----------------------------------------------- KeyPgDdfboptionexplicit ----
__FB_OPTION_EXPLICIT__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_OPTION_EXPLICIT__

Description
   __FB_OPTION_EXPLICIT__ indicates if Option Explicit has been used 
   previously in the source.  

   Returns zero (0) if the option has not been set.  Returns non-zero (-1) 
   if the option has been set.

Example
   #if( __FB_OPTION_EXPLICIT__ = 0 )
     #error Option Explicit must used With This module
   #endif

Differences from QB
   * New to FreeBASIC

See also 
   * Dim
   * Option Explicit



-------------------------------------------------- KeyPgDdfboptiongosub ----
__FB_OPTION_GOSUB__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_OPTION_GOSUB__

Description
   Indicates how GoSub and Return will be handled at compile time. If the 
   option is set (-1) then GoSub is allowed and Return is recognized as 
   return-from-gosub only.  If the option is not set (0) then GoSub is not 
   allowed and Return is recognized as return-from-procedure only.

   This macro value can be changed at compile time.  Option Gosub will set 
   the option (enable gosub support) and Option Nogosub will clear the 
   option (disable gosub support).

   __FB_OPTION_GOSUB__ returns zero (0) if the option has not been set.  
   Returns non-zero (-1) if the option has been set.

Example
   #if( __FB_OPTION_GOSUB__ <> 0 )
      '' turn off gosub support
      Option nogosub
   #endif

Dialect Differences
   * Defaults to -1 in the -lang qb dialect and 0 in all other dialects.

Differences from QB
   * New to FreeBASIC

See also 
   * Option Gosub
   * Option Nogosub



------------------------------------------------ KeyPgDdfboptionprivate ----
__FB_OPTION_PRIVATE__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_OPTION_PRIVATE__

Description
    Indicates if by default Function's and Sub's have module scope or 
   global scope when not explicitly specified with Private or Public.

   The default scope specifier for functions and subs is set by usage of 
   the -lang command line option during compilation or usage of 
   Option Private in the source file.

   __FB_OPTION_PRIVATE__ returns zero (0) if the option has not been set.  
   Returns non-zero (-1) if the option has been set.

Example
   #if( __FB_OPTION_PRIVATE__ <> 0 )
     #error Option Private must Not be used With This module
   #endif

Differences from QB
   * New to FreeBASIC

See also 
   * Option Private
   * Private
   * Public



------------------------------------------------------- KeyPgDdfboutdll ----
__FB_OUT_DLL__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_OUT_DLL__

Description
   __FB_OUT_DLL__ indicates that the specified output file type on the 
   compiler command line at the time of compilation is a shared library.

   Returns non-zero (-1) if the output is a shared library.  Returns zero 
   (0) otherwise.

   Only one of __FB_OUT_DLL__, __FB_OUT_EXE__, __FB_OUT_LIB__, or 
   __FB_OUT_OBJ__ will evaluate to non-zero (-1).  All others will evaluate 
   to zero (0).

Example
   #if __FB_OUT_DLL__ 
         '... specific instructions when making a shared library (DLL)
   #else
         '... specific instructions when not making a shared library (DLL)
   #endif   

Differences from QB
   * New to FreeBASIC

See also 
   * __FB_OUT_EXE__
   * __FB_OUT_LIB__
   * __FB_OUT_OBJ__
   * Compiler Option: -dll



------------------------------------------------------- KeyPgDdfboutexe ----
__FB_OUT_EXE__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_OUT_EXE__

Description
   __FB_OUT_EXE__ indicates that the specified output file type on the 
   compiler command line at the time of compilation is an executable.

   Returns non-zero (-1) if the output is an executable.  Returns zero (0) 
   otherwise.

   Only one of __FB_OUT_DLL__, __FB_OUT_EXE__, __FB_OUT_LIB__, or 
   __FB_OUT_OBJ__ will evaluate to non-zero (-1).  All others will evaluate 
   to zero (0).

Example
   #if __FB_OUT_EXE__ 
         '... specific instructions when making an executable
   #else
         '... specific instructions when not making an executable
   #endif

Differences from QB
   * New to FreeBASIC

See also 
   * __FB_OUT_DLL__
   * __FB_OUT_LIB__
   * __FB_OUT_OBJ__



------------------------------------------------------- KeyPgDdfboutlib ----
__FB_OUT_LIB__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_OUT_LIB__

Description
   __FB_OUT_LIB__ indicates that the specified output file type on the 
   compiler command line at the time of compilation is a static library.

   Returns non-zero (-1) if the output is a static library.  Returns zero 
   (0) otherwise.

   Only one of __FB_OUT_DLL__, __FB_OUT_EXE__, __FB_OUT_LIB__, or 
   __FB_OUT_OBJ__ will evaluate to non-zero (-1).  All others will evaluate 
   to zero (0).

Example
   #if __FB_OUT_LIB__ 
         '... specific instructions when making a static library
   #else
         '... specific instructions when not making a static library
   #endif

Differences from QB
   * New to FreeBASIC

See also 
   * __FB_OUT_EXE__
   * __FB_OUT_DLL__
   * __FB_OUT_OBJ__
   * Compiler Option: -lib



------------------------------------------------------- KeyPgDdfboutobj ----
__FB_OUT_OBJ__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_OUT_OBJ__

Description
   __FB_OUT_OBJ__ indicates that the specified output file type on the 
   compiler command line at the time of compilation is an object module.

   Returns non-zero (-1) if the output is an object module.  Returns zero 
   (0) otherwise.

   Only one of __FB_OUT_DLL__, __FB_OUT_EXE__, __FB_OUT_LIB__, or 
   __FB_OUT_OBJ__, will evaluate to non-zero (-1).  All others will 
   evaluate to zero (0).

Example
   #if __FB_OUT_OBJ__ 
         '... specific instructions when compiling to an object file only
   #else
         '... specific instructions when not compiling to an object file only
   #endif

Differences from QB
   * New to FreeBASIC

See also 
   * __FB_OUT_EXE__
   * __FB_OUT_DLL__
   * __FB_OUT_LIB__



--------------------------------------------------------- KeyPgDdfbpcos ----
__FB_PCOS__

Intrinsic define set by the compiler

Syntax
   __FB_PCOS__

Description
   Define created at compile time if the OS has filesystem behavior styled 
   like common PC OSes, e.g. DOS, Windows, OS/2, Symbian OS, possibly 
   others. Drive letters, backslashes, that stuff, otherwise undefined.

Example
   #ifdef __FB_PCOS__
     '...instructions for PC-ish OSes...
   #else
     '...instructions for other OSes
   #endif 

Differences from QB
   * New to FreeBASIC

See also
   * __FB_WIN32__
   * __FB_DOS__
   * __FB_XBOX__
   * __FB_UNIX__
   * Compiler Option: -target



---------------------------------------------------------- KeyPgDdfbppc ----
__FB_PPC__

Intrinsic define set by the compiler

Syntax
   __FB_PPC__

Description
   Define created at compile time if the compilation target uses the 
   PowerPC CPU architecture, otherwise undefined.

Example
   #ifdef __FB_PPC__
     '...instructions for PowerPC OSes...
   #else
     '...instructions for other OSes
   #endif 

Version
   * Since fbc 1.09.0

Differences from QB
   * New to FreeBASIC

See also
   * Compiler Option: -target



-------------------------------------------------------- KeyPgDdfbquote ----
__FB_QUOTE__

Intrinsic define (macro) performed by the compiler.

Syntax
   __FB_QUOTE__( arg )

Parameters
   arg
      argument

Description
   Converts the argument to a string, similar to stringize operator (#) but 
   can be used anywhere (will expand the argument before conversion).
   More precisely, __FB_QUOTE__ returns an over-quoted text (prefixed with 
   the Operator $ (Non-Escaped String Literal)) compared to the one passed 
   through the argument (the argument may already be a string, and so the 
   return will be an over-quoted string in this case).

Example
   #macro m( arg )
      Scope
         Dim s1 As String = #arg
         Print s1
         Dim s2 As String = __FB_QUOTE__( arg )
         Print s2
      End Scope
   #endmacro

   m(Hello)
   Print
   m("Hello")

   Sleep

   /' Output:
   Hello
   Hello

   "Hello"
   "Hello"
   '/
      

   #macro m( arg1, arg2 )
      Scope
         'Dim s0 As String = #arg1##arg2  ' does not work because arg1##arg2 is not developped before applying #
         Dim s1 As String = #arg1###arg2  ' workaround because #arg => $"arg" and not only "arg"
                                  '    (otherwise the result would be "arg1""arg2" => "arg1"arg2")
         Print s1
         Dim s2 As String = __FB_QUOTE__( arg1##arg2 )
         Print s2
      End Scope
   #endmacro

   m(Free, BASIC)

   Sleep

   /' Output:
   FreeBASIC
   FreeBASIC
   '/
      

   See also __FB_UNQUOTE__ example.

Version
   * Since fbc 1.08.0

Differences from QB
   * New to FreeBASIC

See also
   * __FB_UNQUOTE__
   * __FB_EVAL__



---------------------------------------------------- KeyPgDdfbsignature ----
__FB_SIGNATURE__

Intrinsic define (macro string) set by the compiler

Syntax
   __FB_SIGNATURE__

Description
   Substituted by a signature of the compiler where used.

Example
   Print __FB_SIGNATURE__


   FreeBASIC 0.21.1

Differences from QB
   * New to FreeBASIC

See also
   * __FB_VERSION__
   * __FB_WIN32__
   * __FB_LINUX__
   * __FB_DOS__



---------------------------------------------------------- KeyPgDdfbsse ----
__FB_SSE__

Intrinsic define set by the compiler

Syntax
   __FB_SSE__

Description
   Define without a value created at compile time if SSE floating point 
   arithmetics is enabled.

Example
   #ifdef __FB_SSE__
     ' ... instructions only for SSE ...
   #else
     ' ... instructions not for SSE ...
   #endif

Differences from QB
   * New to FreeBASIC

See also
   * __FB_FPU__
   * Compiler Option: -fpu



----------------------------------------------------- KeyPgDdfbuniqueid ----
__FB_UNIQUEID__

Intrinsic define (macro) performed by the compiler.

Syntax
   __FB_UNIQUEID__( stack-id )

Parameters
   stack-id
      the name of the stack to access

Description
   Gets the identifier at the top of stack identified by stack-id (the size 
   of the stack is not modified).
   (__FB_UNIQUEID_PUSH__ allows to push a new unique identifier on to the 
   stack, and __FB_UNIQUEID_POP__ allows to pop an identifier off of the 
   stack)

   Note:
      - The 'stack-id' name itself is a separate namespace from all other 
      symbols.
      - The stack can only contain 'unique identifiers'.
      - 'unique identifier' is a name of an fb symbol that is unique to the 
      module, so does not conflict or shadow other symbol names ('unique 
      identifier' will have the form 'LT_xxxx' as a name so it might not be 
      completely unique).
      - fb uses the form 'LT_xxxx' internally for labels, symbols, temp 
      variables, etc (so should avoid naming fbc symbols of this form for 
      any fbc program since version 0.0).

   __FB_UNIQUEID__ simply expands to unquoted text. So the name, for 
   example 'Lt_0004', can be used wherever an fb symbol is required (a 
   variable, procedure name, type name, etc.).
   __FB_UNIQUEID__ returns an unquoted empty string when the stack is empty 
   or has never been filled.

Example
   __FB_UNIQUEID_PUSH__( stk )
   #print __FB_UNIQUEID__( stk )

      __FB_UNIQUEID_PUSH__( stk )
      #print __FB_UNIQUEID__( stk )

         __FB_UNIQUEID_PUSH__( stk )
         #print __FB_UNIQUEID__( stk )
         __FB_UNIQUEID_POP__( stk )

      #print __FB_UNIQUEID__( stk )
      __FB_UNIQUEID_POP__( stk )

   #print __FB_UNIQUEID__( stk )
   __FB_UNIQUEID_POP__( stk )

   /' Compiler output example:
   Lt_0006
   Lt_0007
   Lt_0008
   Lt_0007
   Lt_0006
   '/
      

   See also __FB_UNIQUEID_PUSH__ and __FB_UNIQUEID_POP__ examples.

Version
   * Since fbc 1.08.0

Differences from QB
   * New to FreeBASIC

See also
   * __FB_UNIQUEID_PUSH__
   * __FB_UNIQUEID_POP__



-------------------------------------------------- KeyPgDdfbuniqueidpop ----
__FB_UNIQUEID_POP__

Intrinsic define (macro) performed by the compiler.

Syntax
   __FB_UNIQUEID_POP__( stack-id )

Parameters
   stack-id
      the name of the stack to pop

Description
   Pops an identifier off of stack identified by stack-id (the size of the 
   stack is decreased by 1).
   (__FB_UNIQUEID__ allows to get the identifier at the top of the stack, 
   and __FB_UNIQUEID_PUSH__ allows to push a new unique identifier on to 
   the stack)

   Note:
      - The "stack-id" name itself is a separate namespace from all other 
      symbols.
      - The stack can only contain "unique identifiers".
      - "unique identifier" is a name of an fb symbol that is unique to the 
      module, so does not conflict or shadow other symbol names ("unique 
      identifier" will have the form "LT_xxxx" as a name so it might not be 
      completely unique).
      - fb uses the form "LT_xxxx" internally for labels, symbols, temp 
      variables, etc (so should avoid naming fbc symbols of this form for 
      any fbc program since version 0.0).

   When such a stack is no longer in use, it is recommended that it be 
   empty (at the end there must have been applied as many 
   __FB_UNIQUEID_POP__ as __FB_UNIQUEID_PUSH__ for this stack).
   At any time of its use, the number of __FB_UNIQUEID_POP__ applied from 
   the beginning must always be less than or equal to the number of 
   __FB_UNIQUEID_PUSH__ applied.

Example
   See also __FB_UNIQUEID__ example.

   #macro repeat ? ( count )  '' with user named variable
      Scope
         Dim __counter__ As UInteger = count
         While( __counter__)
   #endmacro

   #macro end_repeat  '' with user named variable
            __counter__ -= 1
         Wend
      End Scope   
   #endmacro

   Print "With user named variable:"
   repeat 3
      Print "   outer"
      repeat 2
         Print "   --- inner"
      end_repeat
   end_repeat
   Print

   #undef repeat
   #undef end_repeat

   #macro repeat ? ( count )  '' with "unique identifier" variable
      __FB_UNIQUEID_PUSH__( ctx )
      Dim __FB_UNIQUEID__( ctx ) As UInteger = count
      While( __FB_UNIQUEID__( ctx ) )
   #endmacro

   #macro end_repeat  '' with "unique identifier" variable
         __FB_UNIQUEID__( ctx ) -= 1
      Wend
      __FB_UNIQUEID_POP__( ctx )
   #endmacro

   Print "With ""unique identifier"" variable:"
   repeat 3
      Print "   outer"
      repeat 2
         Print "   --- inner"
      end_repeat
   end_repeat

   Sleep

   /' Output:
   With user named variable:
      outer
      --- inner
      --- inner
      outer
      --- inner
      --- inner
      outer
      --- inner
      --- inner

   With "unique identifier" variable:
      outer
      --- inner
      --- inner
      outer
      --- inner
      --- inner
      outer
      --- inner
      --- inner
   '/
      
The first part of code works, because the '__counter__' variable is defined 
in a [Scope...End Scope] block and therefore allows nesting.
   The second part of code works (without [Scope...End Scope] block) 
   because of using a "unique identifier" (provided by the compiler).

   See also __FB_UNIQUEID_PUSH__ example.

Version
   * Since fbc 1.08.0

Differences from QB
   * New to FreeBASIC

See also
   * __FB_UNIQUEID_PUSH__
   * __FB_UNIQUEID__



------------------------------------------------- KeyPgDdfbuniqueidpush ----
__FB_UNIQUEID_PUSH__

Intrinsic define (macro) performed by the compiler.

Syntax
   __FB_UNIQUEID_PUSH__( stack-id )

Parameters
   stack-id
      the name of the stack to push

Description
   Pushes a new unique identifier on to a stack identified by stack-id (the 
   size of the stack is increased by 1).
   (__FB_UNIQUEID__ allows to get the identifier at the top of the stack, 
   and __FB_UNIQUEID_POP__ allows to pop an identifier off of the stack)

   Note:
      - The "stack-id" name itself is a separate namespace from all other 
      symbols.
      - The stack can only contain "unique identifiers".
      - "unique identifier" is a name of an fb symbol that is unique to the 
      module, so does not conflict or shadow other symbol names ("unique 
      identifier" will have the form "LT_xxxx" as a name so it might not be 
      completely unique).
      - fb uses the form "LT_xxxx" internally for labels, symbols, temp 
      variables, etc (so should avoid naming fbc symbols of this form for 
      any fbc program since version 0.0).

   When such a stack is no longer in use, it is recommended that it be 
   empty (at the end there must have been applied as many 
   __FB_UNIQUEID_POP__ as __FB_UNIQUEID_PUSH__ for this stack).
   At any time of its use, the number of __FB_UNIQUEID_POP__ applied from 
   the beginning must always be less than or equal to the number of 
   __FB_UNIQUEID_PUSH__ applied.

Example
   See also __FB_UNIQUEID__ example.

   ' As the "unique identifiers" (used as jump labels) are successively pushed on to a stack,
   ' the jump-code bodies must be defined in the reversed order than the jump calls.

   #macro go
      __FB_UNIQUEID_PUSH__( stk )
      Goto __FB_UNIQUEID__( stk )
      End If
   #endmacro

   #macro end_go
      __FB_UNIQUEID__( stk ):
      __FB_UNIQUEID_POP__( stk )
   #endmacro
      
   Dim As Integer N

   Do
      Input "Enter a value between 1 and 4 (0 or empty input for exit) ? ", N
      
      If N = 0 Then go
      If N = 1 Then go
      If N = 2 Then go
      If N = 3 Then go
      If N = 4 Then go
      Continue Do
      
      end_go
         Print "You entered 4" : Continue Do
      end_go
         Print "You entered 3" : Continue Do
      end_go
         Print "You entered 2" : Continue Do
      end_go
         Print "You entered 1" : Continue Do
      end_go
         Print "End"           : Exit Do
   Loop

   Sleep
      

   See also __FB_UNIQUEID_POP__ example.

Version
   * Since fbc 1.08.0

Differences from QB
   * New to FreeBASIC

See also
   * __FB_UNIQUEID_POP__
   * __FB_UNIQUEID__



--------------------------------------------------------- KeyPgDdfbunix ----
__FB_UNIX__

Intrinsic define set by the compiler

Syntax
   __FB_UNIX__

Description
   Define created at compile time if the OS is reasonably enough like UNIX 
   that you can call it UNIX, otherwise undefined.

Example
   #ifdef __FB_UNIX__
     '...instructions for UNIX-family OSes...
   #else
     '...instructions for other OSes
   #endif 

Differences from QB
   * New to FreeBASIC

See also
   * __FB_LINUX__
   * __FB_FREEBSD__
   * __FB_OPENBSD__
   * __FB_NETBSD__
   * __FB_CYGWIN__
   * __FB_DARWIN__
   * __FB_PCOS__
   * Compiler Option: -target



------------------------------------------------------ KeyPgDdfbunquote ----
__FB_UNQUOTE__

Intrinsic define (macro) performed by the compiler.

Syntax
   __FB_UNQUOTE__( arg )

Parameters
   arg
      argument

Description
   Takes a literal string and converts it back to tokens.
   More precisely, __FB_UNQUOTE__ returns a sub-quoted text compared to the 
   one passed through the argument (the argument may already be an 
   over-quoted string, and so the return will be a simple string in this 
   case).

Example
   #macro m( arg )
      Scope
         Var v1 = arg
         #print TypeOf(v1)
         Print v1
         Var v2 = __FB_UNQUOTE__( arg )
         #print TypeOf(v2)
         Print v2
      End Scope
   #endmacro

   m("""Hello""")
   m("1")

   Sleep

   /' Compiler output:
   STRING
   STRING
   STRING
   INTEGER
   '/

   /' Output:
   "Hello"
   Hello
   1
    1
   '/
      

   #define X __FB_QUOTE__( Print "hello" )
   #macro Y( arg )
     __FB_UNQUOTE__( arg )
   #endmacro

   Print X
   Y( X )

   /' Output:
   print "hello"
   hello
   '/
      

Version
   * Since fbc 1.08.0

Differences from QB
   * New to FreeBASIC

See also
   * __FB_QUOTE__
   * __FB_EVAL__



---------------------------------------------------- KeyPgDdfbvectorize ----
__FB_VECTORIZE__

Intrinsic define set by the compiler

Syntax
   __FB_VECTORIZE__

Description
   Defined as the vectorisation level number set by the -vec command-line 
   option.

Example
   #if __FB_VECTORIZE__ = 2
     ' ... instructions only for vectorization level 2...
   #else
     ' ...
   #endif

Differences from QB
   * New to FreeBASIC

See also
   * Compiler Option: -vec



----------------------------------------------------- KeyPgDdFBVerMajor ----
__FB_VER_MAJOR__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_VER_MAJOR__

Description
   __FB_VER_MAJOR__ will return the major version of FreeBASIC currently 
   being used.  For example, the major version is 0 for FreeBASIC 0.90, and 
   will remain 0 until FreeBASIC version 1.0 is released.

Example
   Dim fbMajorVersion As Integer
   Dim fbMinorVersion As Integer
   Dim fbPatchVersion As Integer

   fbMajorVersion = __FB_VER_MAJOR__
   fbMinorVersion = __FB_VER_MINOR__
   fbPatchVersion = __FB_VER_PATCH__

   Print "Welcome to FreeBASIC " & fbMajorVersion & "." & fbMinorVersion & "." & fbPatchVersion

Differences from QB
   * New to FreeBASIC

See also
   * __FB_VER_MINOR__
   * __FB_VER_PATCH__



----------------------------------------------------- KeyPgDdFBVerMinor ----
__FB_VER_MINOR__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_VER_MINOR__

Description
   __FB_VER_MINOR__ will return the minor version of FreeBASIC currently 
   being used. For FreeBASIC version 0.90.1, for example, the minor version 
   number is 90.

Example
   Dim fbMajorVersion As Integer
   Dim fbMinorVersion As Integer
   Dim fbPatchVersion As Integer

   fbMajorVersion = __FB_VER_MAJOR__
   fbMinorVersion = __FB_VER_MINOR__
   fbPatchVersion = __FB_VER_PATCH__

   Print "Welcome to FreeBASIC " & fbMajorVersion & "." & fbMinorVersion & "." & fbPatchVersion

Differences from QB
   * New to FreeBASIC

See also 
   * __FB_VER_MAJOR__
   * __FB_VER_PATCH__



----------------------------------------------------- KeyPgDdFBVerPatch ----
__FB_VER_PATCH__

Intrinsic define (macro value) set by the compiler

Syntax
   __FB_VER_PATCH__

Description
   __FB_VER_PATCH__ will return the patch/subversion/revision number the 
   version of FreeBASIC currently being used. For FreeBASIC 0.18, for 
   example, there were subversions 1, 2, 3, 4, 5 and 6, resulting in 
   versions 0.18.1 through 0.18.6.

Example
   Dim fbMajorVersion As Integer
   Dim fbMinorVersion As Integer
   Dim fbPatchVersion As Integer

   fbMajorVersion = __FB_VER_MAJOR__
   fbMinorVersion = __FB_VER_MINOR__
   fbPatchVersion = __FB_VER_PATCH__

   Print "Welcome to FreeBASIC " & fbMajorVersion & "." & fbMinorVersion & ", revision " & fbPatchVersion

Differences from QB
   * New to FreeBASIC

See also 
   * __FB_VER_MAJOR__
   * __FB_VER_MINOR__



------------------------------------------------------ KeyPgDdfbversion ----
__FB_VERSION__

Intrinsic define (macro string) set by the compiler

Syntax
    __FB_VERSION__

Description
    Substituted by the version number of the compiler where used.

Example
   #if __FB_VERSION__ < "0.18" 
   #error  Please compile With FB version 0.18 Or above 
   #endif

   This will stop the compilation if the compiler version is below 0.18

Differences from QB
   * Did not exist in QB

See also
   * __FB_SIGNATURE__
   * __FB_WIN32__
   * __FB_LINUX__
   * __FB_DOS__



-------------------------------------------------------- KeyPgDdfbwin32 ----
__FB_WIN32__

Intrinsic define set by the compiler

Syntax
   __FB_WIN32__

Description
   Define without a value created at compile time if compiling to the Win 
   (32-bit or 64-bit) target. Default in Win hosted version, or active if 
   the -target win32 or -target win64 command line option is used. It can 
   be used to compile parts of the program only if the target is Win.

Example
   #ifdef __FB_WIN32__
     ' ... instructions only for Win ...
     ' ... GetProcAddress ...
   #else
     ' ... instructions not for Win ...
   #endif 

Differences from QB
   * New to FreeBASIC

See also
   * __FB_DOS__
   * __FB_LINUX__
   * __FB_PCOS__
   * Compiler Option: -target



---------------------------------------------------------- KeyPgDdfbx86 ----
__FB_X86__

Intrinsic define set by the compiler

Syntax
   __FB_X86__

Description
   Define created at compile time if the compilation target uses the X86 or 
   X86_64 CPU architecture, otherwise undefined.

Example
   #ifdef __FB_X86__
     '...instructions for X86 OSes...
   #else
     '...instructions for other OSes
   #endif 

Version
   * Since fbc 1.08.0

Differences from QB
   * New to FreeBASIC

See also
   * __FB_ARM__
   * Compiler Option: -target



--------------------------------------------------------- KeyPgDdfbxbox ----
__FB_XBOX__

Intrinsic define set by the compiler

Syntax
   __FB_XBOX__

Description
   Define without a value created at compile time when the -target xbox 
   command line option is used. It can be used to compile parts of the 
   program only if the target is Xbox.

Example
   #ifdef __FB_XBOX__
     '...instructions only for Xbox...
   #else
     '...instructions not for Xbox...
   #endif 

Differences from QB
   * New to FreeBASIC

See also
   * __FB_LINUX__
   * __FB_WIN32__
   * Compiler Option: -target



----------------------------------------------------------- KeyPgDdfile ----
__FILE__

Intrinsic define (macro string) set by the compiler

Syntax
   __FILE__

Description
   Substituted with the quoted source file name where used.

   An example of normal use is to report wrong values in debugging.

Example
   Dim a As Integer
   If a<0 Then
      Print "Error: a = " & a & " in " & __FILE__ & " (" & __FUNCTION__ & ") line " & __LINE__
   End If


   Error: a = -32767 in test.bas (MAIN) Line 47

Differences from QB
   * Did not exist in QB

See also
   * __FILE_NQ__
   * __FUNCTION__
   * __LINE__



--------------------------------------------------------- KeyPgDdfilenq ----
__FILE_NQ__

Intrinsic define (macro string) set by the compiler

Syntax
   __FILE_NQ__

Description
   Substituted with the non-quoted source file name where used.

Example
   #print __FILE_NQ__

Differences from QB
   * New to FreeBASIC

See also
   * __FILE__
   * __FUNCTION_NQ__
   * __LINE__



------------------------------------------------------- KeyPgDdfunction ----
__FUNCTION__

Intrinsic define (macro string) set by the compiler

Syntax
   __FUNCTION__

Description
   Substituted with the quoted name of the current function block where 
   used.

   Its normal use is to report wrong values in debugging.

   If __FUNCTION__ is used at the module level, the function name given 
   will be "__FB_MAINPROC__" for the main module, or "__FB_MODLEVELPROC__" 
   for a different module.

Example
   Dim a As Integer

   '...

   If a < 0 Then '' this shouldn't happen
      Print "Error: a = " & a & " in " & __FILE__ & " (" & __FUNCTION__ & ") line " & __LINE__
   End If


   Error: a = -32767 in test.bas (__FB_MAINPROC__) Line 47

Differences from QB
   * Did not exist in QB

See also
   * __FILE__
   * __FUNCTION_NQ__
   * __LINE__



----------------------------------------------------- KeyPgDdfunctionnq ----
__FUNCTION_NQ__

Intrinsic define (macro string) set by the compiler

Syntax
   __FUNCTION_NQ__

Description
   Substituted with the non-quoted name of the current function block where 
   used.

   If __FUNCTION_NQ__ is used at the module level, the function name given 
   will be __FB_MAINPROC__ for the main module, or __FB_MODLEVELPROC__ for 
   a different module.  This is not the actual function name though, so 
   it's not as useful there.

Example
   Sub MySub
     Print "Address of " + __FUNCTION__ + " is ";
     Print Hex( @__FUNCTION_NQ__ )
   End Sub

   MySub


   Address of MYSUB Is 4012D0

Differences from QB
   * Did not exist in QB

See also
   * __FILE_NQ__
   * __FUNCTION__
   * __LINE__



----------------------------------------------------------- KeyPgDdline ----
__LINE__

Intrinsic define (macro value) set by the compiler

Syntax
   __LINE__

Description
   Substituted with the current line number of the source file where used.

   Its normal use is to report wrong values in debugging.

Example
   Dim a As Integer

   If a < 0 Then 
      Print "Error: a = " & a & " in " & __FILE__ & " (" & __FUNCTION__ & ") line " & __LINE__
   End If


   Error: a = -32767 in test.bas (MAIN) Line 47

Differences from QB
   * Did not exist in QB

See also
   * __FILE__
   * __FUNCTION__



----------------------------------------------------------- KeyPgDdpath ----
__PATH__

Intrinsic define (macro string) set by the compiler

Syntax
   __PATH__

Description
   Set to the quoted absolute path of the source file at the time of 
   compilation.

Example
   ' Tell the compiler to seach the source file's
   ' directory for libraries

   #libpath __PATH__

Differences from QB
   * New to FreeBASIC

See also
   * __FILE__



----------------------------------------------------------- KeyPgDdtime ----
__TIME__

Intrinsic define (macro value) set by the compiler

Syntax
   __TIME__

Description
   Substitutes the compiler time in a literal string (24 clock, "hh:mm:ss" 
   format) where used.

Example
   Print "Compile Time: " & __TIME__


   Compile Time: 13:42:57

Differences from QB
   * New to FreeBASIC

See also
   * __DATE__
   * __DATE_ISO__
   * Time




============================================================================
    #

--------------------------------------------------------- KeyPgPpassert ----
#assert

Preprocessor conditional directive

Syntax
   #assert  condition

Parameters
   condition
      A conditional expression that is assumed to be true

Description
   Asserts the truth of a conditional expression at compile time.  If 
   condition is false, compilation will stop with an error.

   This statement differs from the Assert macro in that #assert is 
   evaluated at compile-time and Assert is evaluated at run-time.

Example
   Const MIN = 5, MAX = 10
   #assert MAX > MIN '' cause a compile-time error if MAX <= MIN

Differences from QB
   * New to FreeBASIC

See also
   * Assert
   * #if
   * #error



-------------------------------------------------------- KeyPgPpcmdline ----
#Cmdline

Preprocessor directive

Syntax
   #cmdline "args..."

Parameters
   args...
      argument list (separated by spaces) of valid Compiler Options except 
      -print and also generic option -help.

Description
   #cmdline is a pre-processor directive that allows specifying 
   compiler options from inside the first specified fb source file.  The 
   first source file is the first specified '.bas' file given on the shell 
   or IDE command line invoking the fbc compiler.  #cmdline directives 
   specified in the first source file affect all source files subsequently 
   compiled.  #cmdline directives inside source files other than the first 
   source file are ignored.

   #cmdline is only allowed at module scope and can be conditionally 
   processed with #if pre-processor statements .

   #cmdline directives are processed on the first pass of the the first 
   '.bas' source file when they appear in the source file.  If an invalid 
   command line option is given in the #cmdline statment, compilation 
   immediately aborts. #cmdline directives are ignored on the second pass 
   of the source file even if a conditional #if would add something 
   different on the second pass.

   At first fbc initializes as usual and begins parsing the fb source code 
   using the options given from the shell or IDE's fbc ... command line.  
   As #cmdline directives are processed, they are merged into the current 
   compiler configuration.  Depending on the command line options 
   encountered, fbc can continue parsing, restart the parser, or restart 
   fbc (for example: no restart after #cmdline "-mt", restart the parser 
   after #cmdline "-gen gcc", restart the build after #cmdline "-target 
   win64").

   fbc has no clever way to detect when all the #cmdline directives in 
   source have been processed, so there are 2 pseudo command line options 
   to instruct fbc what to next if it is necessary:
      #cmdline "-end"
         option to restart parser or build if needed.
      #cmdline "-restart"
         option to always restart build.
   If neither #cmdline "-end" nor #cmdline "-restart" were encountered, fbc 
   continues processing to the end of the first source file and restarts 
   only if necessary. 

   Adding -z nocmdline in the shell/IDE command line option ignores 
   #cmdline directives completely in source and allows user to override all 
   source directives using the shell/IDE fbc compiler command line only.

   Adding -w all on the shell/IDE command line option allows to get 
   warnings about ignored #cmdline directives.

Example
   Add a simple option in source to set the optimization level for GCC:
   #cmdline "-O 2"

   Print __FB_OPTIMIZE__  '' just to check the optimization level

   Sleep
         

   When #cmdline is not processed (no 'invalid command-line option' error 
   message is reported):
   (fbc parser is active when checking for #cmdline, so it's expected that 
   it follows sames rules as any other source code)
   '' not processed in single line comments
   '#cmdline "asdf"

   '' not processed in multi line comments
   /'
   #cmdline "-asdf"
   '/

   '' not processed in strings
   Print "#cmdline ""-asdf"""

   '' not processed if skipping over a conditional
   #if 0
      #cmdline "-asdf"
   #endif

   '' not processed when defining macros (as long as the macro is not called)
   #macro DOARGS
      #cmdline "-asdf"
   #endmacro

   Sleep
         

   Set options in source based on real fbc ... compiler command line option 
   given:
   (full error checking is activated depending if debug option '-g' was 
   given on the fbc ... compiler command line)
   '' '-g' command line option given on the real ##//fbc ...//## compiler command line?

   #if __FB_DEBUG__
      #cmdline "-exx -w pedantic -w constness"
   #endif
         

   Define a global symbol for all modules, starting with two modules: 
   main.bas and tools.bas, and compile both with the single '$ fbc 
   main.bas' compiler command line:
   (this is different than #include tools.bas in main.bas because the two 
   modules are compiled separately then linked)
   '' main.bas
   ''
   '' compile with:
   ''   $ fbc main.bas
   ''
   '' and will be same as if we did:
   ''   $ fbc main.bas tools.bas -d DoTrickyStuff

   '' add the tools module
   #cmdline "-b tools.bas"  '' or: #cmdline "tools.bas"

   '' gobal #define for all modules
   #cmdline "-d DoTrickyStuff"

   Declare Function IsTrickyTools() As Boolean

   #ifdef DoTrickyStuff
   Print "DoTrickyStuff is defined in the main.bas module"
   #endif

   If IsTrickyTools() Then
   Print "DoTrickyStuff is defined in the tools.bas module"
   End If

   Sleep
         

   '' tools.bas
   ''

   Function IsTrickyTools() As Boolean
      #ifdef DoTrickyStuff
      Return True
      #else
        Return False
      #endif
   End Function
         

Version
   * Since fbc 1.09.0

Differences from QB
   * New to FreeBASIC

See also
   * fbc command-line
   * Compiler Options
   * Intrinsic Defines



--------------------------------------------------------- KeyPgPpdefine ----
#define

Preprocessor directive to define a macro

Syntax
   #define identifier body
   #define identifier( [ parameters ] ) body
   #define identifier( [ parameters, ] Variadic_Parameter... ) body

Description
   #define allows to declare text-based preprocessor macros. Once the 
   compiler has seen a #define, it will start replacing further occurrences 
   of identifier with body. body may be empty. The expansion is done 
   recursively, until there is nothing more to expand and the compiler can 
   continue analyzing the resulting code. #undef can be used to make the 
   compiler forget about a #define.

   Parameters turn a define into a function-like macro, allowing text 
   arguments to be passed to the macro. Any occurrences of the parameter 
   names in the body will be replaced by the given argument text during 
   expansion.
   If a literal is passed to a macro, the name of the corresponding 
   parameter in the macro body can not be used as a local variable as in a 
   procedure body. To emulate the same functioning as for a procedure, the 
   user must then explicitly declare a local variable (with another name) 
   in the body of the macro and initialize it with the passed parameter 
   name (replaced at preprocessing by the literal passed).

   The # Stringize operator can be used on macro parameters to turn them 
   into string literals, and the ## Concatenate operator can be used to 
   merge tokens together.

   Note: In the function-like #define declaration, the identifier should be 
   followed by the opening parentheses (() immediately without any 
   white-space in between, otherwise the compiler will treat it as part of 
   the body.

   Defines are scoped; they are only visible in the scope they were defined 
   in. If defined at module level, the define is visible throughout the 
   module. If the identifier is defined inside a compound statement having 
   scope (Sub, For..Next, While..Wend, Do..Loop, Scope..End Scope, etc), 
   the identifier define is only visible within that scope. Namespaces on 
   the other hand do not have any effect on the visibility of a define.

   Identifiers can be checked for with #ifdef and others, which can be used 
   to hide parts of code from the compiler (conditional compiling).

   The result of macro expansion can be checked by using the -pp compiler 
   option.

   #defines are often used to declare constants. The Const statement is a 
   type-safe alternative.

   WARNING: When the define body contains an expression with one operator 
   at least, it may be mandatory to have to surround some terms 
   (parameters, whole body) by parentheses in order to not undergo an 
   unwanted precedence change of operators (if passing as argument an 
   expression with also operators, or if using the define in a main 
   expression with also operators).

Example
   '' Definition and check
   #define DEBUGGING
   #ifdef DEBUGGING
     ' ... statements
   #endif

   '' Simple definition/text replacement
   #define False 0
   #define True (Not False)

   '' Function-like definition
   #define MyRGB(R,G,B) (((R)Shl 16)  Or ((G)Shl 8) Or (B)) 
   Print Hex( MyRGB(&hff, &h00, &hff) )

   '' Line continuation and statements in a definition
   #define printval(bar) _
      Print #bar; " ="; bar

   '' #defines are visible only in the scope where they are defined
   Scope
      #define LOCALDEF 1
   End Scope

   #ifndef LOCALDEF
   #   Print LOCALDEF Is Not defined
   #endif

   '' namespaces have no effect on the visibility of a define
   Namespace foo
   #   define NSDEF
   End Namespace

   #ifdef NSDEF
   #   Print NSDEF Is defined
   #endif

Differences from QB
   * New to FreeBASIC

See also
   * #macro
   * # Preprocessor Stringize
   * ## Preprocessor Concatenate
   * #ifdef
   * #undef
   * Const
   * ...



----------------------------------------------------------- KeyPgPpelse ----
#else

Preprocessor conditional directive

Syntax
   #if (expression)
      ' Conditionally included statements if expression is True
   #else
      ' Conditionally included statements if expression is False 
   #endif

Description
   #else can be added to an #if, #ifdef, or #ifndef block to provide an 
   alternate result to the conditional expression.

Example
   #define MODULE_VERSION 1
   Dim a As String
   #if (MODULE_VERSION > 0)
     a = "Release"
   #else
     a = "Beta"
   #endif
   Print "Program is "; a

Differences from QB
   * New to FreeBASIC

See also
   * #define
   * #macro
   * #if
   * #elseif 
   * #endif 
   * #ifdef
   * #ifndef
   * #undef
   * defined



--------------------------------------------------------- KeyPgPpelseif ----
#elseif

Preprocessor conditional directive

Syntax
   #if (expression1)
      ' Conditionally included statements if expression1 is True
   #elseif (expression2)
      ' Conditionally included statements if expression2 is True
   #else
      ' Conditionally included statements if both
      ' expression1 and expression2 are False
   #endif

Description
   #elseif can be added to an #if block to provide an additional 
   conditions.

Example
   #define WORDSIZE 16
   #if (WORDSIZE = 16)
     ' Do some some 16 bit stuff
   #elseif (WORDSIZE = 32)
     ' Do some some 32 bit stuff
   #else
     #error WORDSIZE must be set To 16 Or 32
   #endif

Differences from QB
   * New to Freebasic

See also
   * #define
   * #macro
   * #if
   * #else 
   * #endif 
   * #ifdef
   * #ifndef
   * #undef
   * defined



---------------------------------------------------------- KeyPgPpendif ----
#endif

Preprocessor conditional directive

Syntax
   #endif

Description
   Ends a group of conditional directives

   See #if, #ifdef, or #ifndef for examples of usage.

Example
   #define DEBUG_LEVEL 1
   #if (DEBUG_LEVEL = 1)
     'Conditional statements
   #endif

Differences from QB
   * New to FreeBASIC

See also
   * #define
   * #macro
   * #if
   * #else 
   * #elseif 
   * #ifdef
   * #ifndef
   * #undef
   * defined



---------------------------------------------------------- KeyPgPpmacro ----
#Macro...#Endmacro

Preprocessor directive to define a multiline macro

Syntax
   #macro identifier [?] ( [ parameters ] )
      body
   #endmacro

   #macro identifier [?] ( [ parameters, ] Variadic_Parameter... )
      body
   #endmacro

Description
   #macro is the multi-line version of #define.

   If using the optional question mark (?) after the identifier in the 
   definition syntax, macros with parameters can be invoked without using 
   parentheses around the arguments.
   Note: Beware of the possibility of triggering so a conflict with 
   expressions containing the name of the macro as one of their terms.

   Note: Unlike the function-like #define declaration, spaces can be put 
   between the macro name and the opening parenthesis for any declaration 
   syntax of macro.

   WARNING: In the macro body, it may be mandatory to have to surround by 
   parentheses any used parameter if it is inside an expression with one 
   operator at least, in order to not undergo an unwanted precedence change 
   of operators (if passing as argument an expression with also operators).

Example
   ' macro as an expression value

   #macro Print1( a, b )
      a + b
   #endmacro

   Print Print1( "Hello ", "World!" )

   /' Output :
   Hello World!
   '/
      

   ' macro as multiple statements

   #macro Print2( a, b )
      Print a;
      Print " ";
      Print b;
      Print "!"
   #endmacro

   Print2( "Hello", "World" )

   /' Output :
   Hello World!
   '/
      

   ' macro with a variadic parameter

   #macro test1( arg1, arg2... )
      Print arg1
      #if #arg2 = ""
         Print "2nd argument not passed"
      #else
         Print arg2
      #endif
   #endmacro

   test1( "1", "2" )
   Print "-----------------------"
   test1( "3" )
   Print "-----------------------"
   test1( 5, 6 )
   Print "-----------------------"
   test1( 7 )

   /' Output :
   1
   2
   -----------------------
   3
   2nd argument not passed
   -----------------------
    5
    6
   -----------------------
    7
   2nd argument not passed
   '/
      

   ' macro with a variadic parameter which can contain several sub-parameters:
   '   To distinguish between the different arguments passed by variadic_parameter,
   '   you can first convert variadic_parameter to a string using the Operator # (Preprocessor Stringize),
   '   then differentiate in this string (#variadic_parameter) each passed argument by locating the separators (usually a comma).

   #macro test2( arg1, arg2... )
      Print "'" & Trim(#arg1) & "'"
      Scope
         Dim As String s = Trim(#arg2)
         If s <> "" Then
            Do
               Dim As Integer k = InStr(1, s, ",")
               If k = 0 Then
                  Print "'" & s & "'"
                  Exit Do
               End If
               Print "'" & Left(s, k - 1) & "'"
               s = Trim(Mid(s, k+1))
            Loop
         End If
      End Scope
   #endmacro

   test2( 5 )
   Print "----"
   test2( 5,6, 7, , 9, 10, ,,13, 14 )

   /' Output :
   '5'
   ----
   '5'
   '6'
   '7'
   ''
   '9'
   '10'
   ''
   ''
   '13'
   '14'
   '/
      

Differences from QB
   * New to FreeBASIC

See also
   * #define
   * #ifdef
   * #undef



---------------------------------------------------------- KeyPgPperror ----
#error

Preprocessor diagnostic directive

Syntax
   #error error_text

Parameters
   error_text
      The display message

Description
   #error interrupts compiling to display error_text when compiler finds 
   it, and then parsing continues. 

   This keyword must be surrounded by an #if <condition> ...#endif, so the 
   compiler can reach #error only if <condition> is met.

   In any case, the final status will be "Failed to compile".

Example
   #define c 1

   #if c = 1
     #error Bad value of c 
   #endif

Differences from QB
   * New to FreeBASIC

See also
   * #if
   * #print
   * #assert



------------------------------------------------------------- KeyPgPpif ----
#if

Preprocessor conditional directive

Syntax
   #if (expression)
      ' Conditionally included statements
   #endif

Description
   Conditionally includes statements at compile time.

   Statements contained within the #if / #endif block are included if 
   expression evaluates to True (non-zero) and excluded (ignored) if 
   expression evaluates to False (0).

   This conditional directive differs from the If conditional statement in 
   that #if is evaluated at compile-time and If is evaluated at run-time.

Example
   #define DEBUG_LEVEL 1
   #if (DEBUG_LEVEL >= 2)
     ' This line is not compiled since the expression is False
     Print "Starting application"
   #endif

Differences from QB
   * New to FreeBASIC

See also
   * #define
   * #macro
   * #else 
   * #elseif 
   * #endif 
   * #ifdef
   * #ifndef
   * #undef
   * defined
   * #assert 



---------------------------------------------------------- KeyPgPpifdef ----
#ifdef

Preprocessor conditional directive

Syntax
   #ifdef symbol
      ' Conditionally included statements
   #endif

Description
   Conditionally includes statements at compile time.

   Statements within the #ifdef...#endif block are included if symbol is 
   defined and excluded (ignored) if symbol is not defined.

   #ifdef symbol is equivalent to #if defined (symbol)

Example
   #define _DEBUG
   #ifdef _DEBUG
      ' Special statements for debugging
   #endif

Differences from QB
   * New to Freebasic

See also
   * #define
   * #macro
   * #if
   * #else 
   * #elseif 
   * #endif 
   * #ifndef
   * #undef
   * defined



--------------------------------------------------------- KeyPgPpifndef ----
#ifndef

Preprocessor conditional directive

Syntax
   #ifndef symbol
      ' Conditionally included statements
   #endif

Description
   Conditionally includes statements at compile time.

   Statements within the #ifndef...#endif block are included if symbol is 
   not defined and excluded (ignored) if symbol is defined.

   #ifndef symbol is equivalent to #if Not defined(symbol)

Example
   #ifndef __MYFILE_BI__
   #define __MYFILE_BI__
      ' Declarations 
   #endif

Differences from QB
   * New to FreeBASIC

See also
   * #define
   * #macro
   * #if
   * #else 
   * #elseif 
   * #endif 
   * #ifdef
   * #undef
   * defined



----------------------------------------------------------- KeyPgInclib ----
#inclib

Preprocessor directive

Syntax
   #inclib "libname"

Description
   Includes a library in the linking process as if the user specified 
   -l libname on the command line.

Example
   '' incomplete code snippet

   '' this will include libmystuff.a in the link process
   #inclib "mystuff" 

Differences from QB
   * New to FreeBASIC

See also
   * #include
   * Compiler Option: -l
   * Compiler Option: -p



---------------------------------------------------------- KeyPgInclude ----
#include

Preprocessor statement to include contents of another source file

Syntax
   #include [once] "file"

Description
   #include inserts source code from another file at the point where the 
   #include directive appears.  This has the effect of compiling the source 
   code from the include file as though it were part of the source file 
   that includes it.  Once the compiler has reached the end of the include 
   file, the original source file continues to be compiled.

   This is useful to remove code from a file and separate it into more 
   files. It is useful to have a single file with declarations in a program 
   formed by several modules. You may include files within an include file, 
   although avoid including the original file into itself, this will not 
   produce valid results. Typically, include files will have an extension 
   of .bi and are mainly used for declaring subs/functions/variables of a 
   library, but any valid source code may be present in an include file.

   The Once specifier tells the compiler to include the file only once even 
   if it is included several times by the source code.

   $Include is an alternative form of include, existing only for 
   compatibility with QuickBASIC. It is recommended to use #include 
   instead.

   The compiler will automatically convert path separator characters ( '/' 
   and '\' ) as needed to properly load the file.  The filename name may be 
   an absolute or relative path.  

   For relative paths, or where no path is given at all, the include file 
   is search for in the following order:
   * Relative from the directory of the source file
   * Relative from the current working directory
   * Relative from addition directories specified with the -i command line 
     option
   * The include folder of the FreeBASIC installation (FreeBASIC\inc, 
     where FreeBASIC is the folder where the fbc executable is located)

Example
   ' header.bi file
   Type FooType
      Bar As Byte
      Barbeque As Byte 
   End Type

   ' main.bas file
   #include "header.bi"

   Dim Foo As FooType

   Foo.Bar = 1
   Foo.Barbeque = 2

Differences from QB
   * New to FreeBASIC

See also
   * #define
   * #inclib
   * Compiler Option: -i
   * Compiler Option: -include



----------------------------------------------------------- KeyPgPplang ----
#lang

Preprocessor statement to set the compiler dialect.

Syntax
   #lang "lang"

Parameters
   "lang"
      The dialect to set, enclosed in double quotes, and must be one of 
      "fb", "fblite", "qb", or "deprecated".

Description
   If the -forcelang option was not given on the command line, #lang can be 
   used to set the dialect for the source module in which it appears.  At 
   most two passes will be made on the source module.  On the first pass, 
   if the specified dialect is anything other than the default dialect 
   (chosen with -lang, or "fb" by default), the compiler will reset the 
   parser for another pass and restart compilation at the beginning of the 
   source module.  If this directive is encountered again on the second 
   pass, and the specified dialect does not match the new current dialect, 
   a warning is issued and compilation continues.  If any errors were 
   encountered on the first pass, the compiler will not attempt a second 
   pass."

   #lang may not be used in any compound statement, scope, or subroutine.  
   However, it may be nested in module level preprocessor statements or 
   used in an include file.

   There is currently no restriction on where this directive may be placed 
   in a source module.  In future this may change, therefore best practice 
   would be to use this directive before the first declaration, definition, 
   or executable statement in the source.

   This directive overrides the -lang option if it was given on the command 
   line.  However, if the -forcelang option was given on the command line, 
   this directive will have no effect.  A warning is issued, the directive 
   is ignored, and compilation will continue.  This allows the user to 
   explicitly override #lang directives.

Example
   #lang "fblite"

Differences from QB
   * New to FreeBASIC

See also
   * $Lang
   * __FB_LANG__
   * Compiler Option: -lang
   * Compiler Option: -forcelang
   * FreeBASIC Dialects
   * #Cmdline



-------------------------------------------------------- KeyPgPplibpath ----
#libpath

Preprocessor statement to add a search path for libraries

Syntax
   #libpath "path"

Description
   Adds a library search path to the linker's list of search paths as if it 
   had been specified on the command line with the '-p' option.

   Paths are relative to the working directory where fbc was invoked and 
   not relative to the directory of the source file.

   No error is generated if the path does not exist and compilation and 
   linking will continue.

Example
   ' search the lib directory for external libraries
   #libpath "lib"

Differences from QB
   * New to FreeBASIC

See also
   * #inclib
   * #include
   * Compiler Option: -p
   * #Cmdline



----------------------------------------------------------- KeyPgPpline ----
#line

Preprocessor directive to set the current line number and file name

Syntax
   #line number [ "name" ]

Parameters
   number 
      new line number
   "name"
      new file name (optional)

Description
   Informs the compiler of a change in line number and file name and 
   updates the __FILE__ and __LINE__ macro values accordingly.

   Both compile time messages and run-time messages are affected by this 
   directive.

   This directive allows other programs to generate source code for the 
   FreeBASIC compiler and have it return warning and/or error messages that 
   refer to the original source used by the other program.

Example
   #line 155 "outside.src"

   Error 1000

   '' Output is:
   '' Aborting due to runtime error 1000 at line 157 of outside.src()

Differences from QB
   * New to FreeBASIC

See also
   * __FILE__
   * __LINE__



---------------------------------------------------------- KeyPgPpmacro ----
#Macro...#Endmacro

Preprocessor directive to define a multiline macro

Syntax
   #macro identifier [?] ( [ parameters ] )
      body
   #endmacro

   #macro identifier [?] ( [ parameters, ] Variadic_Parameter... )
      body
   #endmacro

Description
   #macro is the multi-line version of #define.

   If using the optional question mark (?) after the identifier in the 
   definition syntax, macros with parameters can be invoked without using 
   parentheses around the arguments.
   Note: Beware of the possibility of triggering so a conflict with 
   expressions containing the name of the macro as one of their terms.

   Note: Unlike the function-like #define declaration, spaces can be put 
   between the macro name and the opening parenthesis for any declaration 
   syntax of macro.

   WARNING: In the macro body, it may be mandatory to have to surround by 
   parentheses any used parameter if it is inside an expression with one 
   operator at least, in order to not undergo an unwanted precedence change 
   of operators (if passing as argument an expression with also operators).

Example
   ' macro as an expression value

   #macro Print1( a, b )
      a + b
   #endmacro

   Print Print1( "Hello ", "World!" )

   /' Output :
   Hello World!
   '/
      

   ' macro as multiple statements

   #macro Print2( a, b )
      Print a;
      Print " ";
      Print b;
      Print "!"
   #endmacro

   Print2( "Hello", "World" )

   /' Output :
   Hello World!
   '/
      

   ' macro with a variadic parameter

   #macro test1( arg1, arg2... )
      Print arg1
      #if #arg2 = ""
         Print "2nd argument not passed"
      #else
         Print arg2
      #endif
   #endmacro

   test1( "1", "2" )
   Print "-----------------------"
   test1( "3" )
   Print "-----------------------"
   test1( 5, 6 )
   Print "-----------------------"
   test1( 7 )

   /' Output :
   1
   2
   -----------------------
   3
   2nd argument not passed
   -----------------------
    5
    6
   -----------------------
    7
   2nd argument not passed
   '/
      

   ' macro with a variadic parameter which can contain several sub-parameters:
   '   To distinguish between the different arguments passed by variadic_parameter,
   '   you can first convert variadic_parameter to a string using the Operator # (Preprocessor Stringize),
   '   then differentiate in this string (#variadic_parameter) each passed argument by locating the separators (usually a comma).

   #macro test2( arg1, arg2... )
      Print "'" & Trim(#arg1) & "'"
      Scope
         Dim As String s = Trim(#arg2)
         If s <> "" Then
            Do
               Dim As Integer k = InStr(1, s, ",")
               If k = 0 Then
                  Print "'" & s & "'"
                  Exit Do
               End If
               Print "'" & Left(s, k - 1) & "'"
               s = Trim(Mid(s, k+1))
            Loop
         End If
      End Scope
   #endmacro

   test2( 5 )
   Print "----"
   test2( 5,6, 7, , 9, 10, ,,13, 14 )

   /' Output :
   '5'
   ----
   '5'
   '6'
   '7'
   ''
   '9'
   '10'
   ''
   ''
   '13'
   '14'
   '/
      

Differences from QB
   * New to FreeBASIC

See also
   * #define
   * #ifdef
   * #undef



--------------------------------------------------------- KeyPgPpPragma ----
#pragma

Preprocessor directive

Syntax
   #pragma option [ = value ]
   Or
   #pragma push ( option [, value ] )
   Or
   #pragma pop ( option )

Parameters
   Possible values for option and related values:

      +------------+------+------------------------------------------------------------------------------------------------------------+
      |Option      | Value| Description                                                                                                |
      | msbitfields| false| Use bitfields compatible with gcc (default)                                                                |
      | msbitfields| true | Use bitfields compatible with those used in Microsoft C compilers                                          |
      | once       | N/A  | cause the source file in which the pragma ppears to behave as though it was included with #include once ...|
      | constness  | false| disable 'CONST qualifier discarded' warning in current source                                              |
      | constness  | true | enable 'CONST qualifier discarded' warning in current source                                               |
      | lookup108  | false| use normal symbol lookups for unqualified symbol names                                                     |
      | lookup108  | true | use fbc-1.08.x or earlier symbol lookups for unqualified symbol names                                      |
      +------------+------+------------------------------------------------------------------------------------------------------------+

   If value is not given, the compiler assumes True (-1).  A zero (0) value 
   may be used in place of False.  A non-zero (for example, -1) value may 
   be used in place of True.

Description
   Allows the setting of compiler options inside the source code.

   Push saves the current value of the option onto a stack, then assigns 
   the new value (or True) to it. Pop restores the option to its previous 
   value, and removes it from the stack. This mechanism allows options to 
   be changed for a certain part of source code, regardless of the setting 
   used by the context, which is especially useful inside #include header 
   files.

   constness pragma is added for testing fbc compiler.  It will be removed 
   in future at should not be relied upon.

Example
   '' MSVC-compatible bitfields: save the current setting and then enable them
   #pragma push(msbitfields)

   '' do something that requires MS-compatible bitfields here

   '' restore original setting
   #pragma pop(msbitfields)

Version
   * #pragma lookup108 added in version 1.09.0, and to be removed in next 
     minor release

Differences from QB
   * New to FreeBASIC

See also
   * #Pragma Reserve
   * #include
   * #Cmdline
   * Preprocessor Overview



-------------------------------------------------- KeyPgPpPragmaReserve ----
#Pragma Reserve

Preprocessor directive

Syntax
      #pragma reserve symbol
   or
      #pragma reserve (extern) symbol
   or
      #pragma reserve (asm) symbol
   or
      #pragma reserve (asm, extern) symbol) or #pragma reserve (extern, 
      asm) symbol)

Parameters
   symbol
      symbol name to reserve.

Description
   #pragma reserved statements are preprocessor directives that allow user 
   to reserve symbol names by accessing to the internal symbol tables of 
   the fbc compiler:
      - #pragma reserve symbol
            statement will reserve a symbol name in the current scope / 
            namespace and generate an error if the symbol is redefined or 
            used in an expression.
      - #pragma reserve (extern) symbol
            statement will reserve a global symbol name and generate a 
            warning if the reserved symbol is used for a module level 
            procedure or shared variable in the global namespace.
      - #pragma reserve (asm) symbol
            statement will reserve an ASM symbol name in all ASM statements 
            and blocks.
      - #pragma reserve (asm, extern) symbol) or #pragma reserve (extern, 
      asm) symbol)
            Do both  previous statements: this combined statement will 
            reserve a global ASM symbol name and generate a warning if the 
            reserved symbol is used for a module level procedure or shared 
            variable in the global namespace.

   The primary objective with the two first syntaxes is to create a 
   mechanism to help deal with some symbols causing compile errors or 
   run-time crashes.
   Some symbol names in fbc compiler are emitted as-is to the backend 
   compilers (gcc, as, etc) where the symbol name is a reserved keyword by 
   the backend compiler.
   There are typically two outcomes:
      - compilation error in the backend,
      - bad code generation in the backend (successful compile and 
      unexpected run time crashes).
   Using #pragma reserve symbol statement allows the fbc compiler to output 
   an error message dedicated to the illegal use of this symbol name in the 
   current scope / namespace.
   Using #pragma reserve (extern)  symbol statement allows the fbc compiler 
   to output a warning message dedicated to the illegal use of this symbol 
   name for a module level procedure or shared variable in the global 
   namespace.

   A closely related secondary objective with the third and forth syntax is 
   ASM words used in ASM blocks and statements.
   This allows to add new ASM instruction name in the fbc ASM keywords list 
   (so not yet implicitly reserved by fbc).
   Therefore, using #pragma reserve (asm) symbol or #pragma reserve (asm, 
   extern) symbol or any #pragma reserve (extern, asm) symbol statement 
   allows the fbc compiler to always emit an undecorated ASM instruction 
   symbol name to the backend compiler.

   Note: #pragma reserve (extern) and #pragma reserve (asm) (and any 
   combined syntax) throw an error if used in any scope block or procedure.

Example
   Example (for the mechanism only) to prohibit/warn the definition/use of 
   a symbol name:
   #pragma reserve myName1
   #pragma reserve myName2
   #pragma reserve myName3
   #pragma reserve myName4
   #pragma reserve myName5
   #pragma reserve (Extern) myName11
   #pragma reserve (Extern) myName12
   #pragma reserve (Extern) myName13
   #pragma reserve (Extern) myName14
   #pragma reserve (Extern) myName15

   Dim As Integer myName1             '' error: Duplicated definition, myName1 in 'Dim As Integer myName1 ...
   Print myName1                      '' error: Illegal use of reserved symbol, found 'myName1' in 'Print myName1 ...

   Scope
      Dim As Integer myName2         '' OK
      Print myName2                  '' OK
   End Scope

   Dim As Integer myName11            '' OK
   Print myName11                     '' OK
   Dim Shared As Integer myName12     '' warning: Use of reserved global or backend symbol, myName12
   Print myName12                     '' OK

   Namespace N
      Dim As Integer myName3         '' OK
      Dim As Integer myName13        '' OK
      Sub myName4()                  '' OK
      End Sub
      Sub myName14()                 '' OK
      End Sub
   End Namespace
   Print N.myName3                    '' OK
   Print N.myName13                   '' OK
   N.myName4()                        '' OK
   N.myName14()                       '' OK

   Sub myName5()                      '' error: Duplicated definition, before ''' in 'Sub myName4() ...
   End Sub
   myName5()                          '' error: Illegal use of reserved symbol, found 'myName4' in 'myName4() ...

   Sub myName15()                     '' warning: Use of reserved global or backend symbol, myName14
   End Sub
   myName15()                         '' OK

   Suppose that 'xyz' is a new ASM instruction not yet entered in the fbc 
   ASM keywords list (so not yet implicitly reserved by fbc), and this 
   'xyz' symbol is also used to define a global variable name:
      - thus fbc emits to the backend compiler a decorated 'xyz' symbol (
      XYZ$) in the inserted ASM block:
   '' for x86_64

   #cmdline "-gen gas64 -r"

   Dim Shared xyz As Integer

   Sub proc Naked()
      Asm
         xyz
         ret
      End Asm
   End Sub

   /'
   OUTPUT in the .asm file:

      .intel_syntax noprefix
      .section .text
      .text
      .globl PROC
   PROC:
      .L_0004:
      XYZ$
      ret
      .L_0005:
      ret
   .....

   '/

      - after reserving the 'xyz' ASM symbol, fbc now emits to the backend 
      compiler an undecorated 'xyz' symbol (xyz) in the inserted ASM block:
   '' for x86_64

   #cmdline "-gen gas64 -r"
   #pragma reserve(Asm) xyz

   Dim Shared xyz As Integer

   Sub proc Naked()
      Asm
         xyz
         ret
      End Asm
   End Sub

   /'
   OUTPUT in the .asm file:

      .intel_syntax noprefix
      .section .text
      .text
      .globl PROC
   PROC:
      .L_0004:
      xyz
      ret
      .L_0005:
      ret
   .....

   '/

Version
   * Since fbc 1.09.0

Differences from QB
   * New to FreeBASIC

See also
   * #pragma
   * Preprocessor Overview



---------------------------------------------------------- KeyPgPpprint ----
#print

Preprocessor diagnostic directive

Syntax
   #print text

Description
   Causes compiler to output text to screen during compilation.

Example
   #print Now compiling module foo

Differences from QB
   * New to FreeBASIC

See also
   * #error



---------------------------------------------------------- KeyPgPpundef ----
#undef

Preprocessor directive to undefine a macro

Syntax
   #undef symbol

Description
   Undefines a symbol previously defined with #define.

   Can be used to ensure that a macro or symbol has a limited lifespan and 
   does not conflict with a similar macro definition that may be defined 
   later in the source code.

   (Note: #undef should not be used to undefine variable or function names 
   used in the current function scope.  The names are needed internally by 
   the compiler and removing them can cause strange and unexpected 
   results.)

Example
   #define ADD2(a_, b_)  ((a_) + (b_))
   Print ADD2(1, 2)
   ' Macro no longer needed so get rid of it ...
   #undef ADD2

Differences from QB
   * New to Freebasic

See also
   * #define
   * #macro
   * #if
   * #else 
   * #elseif 
   * #endif 
   * #ifdef
   * #ifndef
   * defined




============================================================================
    $

------------------------------------------------------ KeyPgMetaDynamic ----
$Dynamic

Metacommand to change the way arrays are allocated

Syntax
   '$Dynamic
      or
   Rem $Dynamic

Description
   '$Dynamic is a metacommand that specifies that any following array 
   declarations are variable-length, whether they are declared with 
   constant subscript ranges or not. This remains in effect for the rest of 
   the module in which '$Dynamic is used, and can be overridden with 
   '$Static.  It is equivalent to the Option Dynamic statement.

Example
   ' compile with -lang fblite or qb

   #lang "fblite"

   '$DYNAMIC
   Dim a(100)
   '......
   ReDim a(200)

Dialect Differences
   * Only available in the -lang fblite and -lang qb dialects.

Differences from QB
   * When used inside comments it must be the first token

See also
   * $Static
   * Dim
   * ReDim
   * Erase
   * Option Dynamic



------------------------------------------------------ KeyPgMetaInclude ----
$Include

Metacommand statement to include contents of another source file

Syntax
   '$Include [once]: 'file'
      or
   Rem $Include [once]: 'file'

Description
   $Include inserts source code from another file at the point where the 
   $Include metacommand appears.  This has the effect of compiling the 
   source code from the include file as though it were part of the source 
   file that includes it.  Once the compiler has reached the end of the 
   include file, the original source file continues to be compiled.

   The Once specifier tells the compiler to include the file only once even 
   if it is included several times by the source code.

   '$Include: exists for compatibility with QuickBASIC. It is recommended 
   to use #include instead.

Example
   ' header.bi file
   Type FooType
      Bar As Byte
      Barbeque As Byte 
   End Type
   Dim Foo As FooType

   '' compile with -lang fblite or qb

   #lang "fblite"

   '' main.bas file

   '$INCLUDE: "header.bi"

   Foo.Bar = 1
   Foo.Barbeque = 2

Dialect Differences
   * Only available in the -lang fblite and -lang qb dialects.

Differences from QB
   * None

See also
   * #include



--------------------------------------------------------- KeyPgMetaLang ----
$Lang

Metacommand statement to set the compiler dialect.

Syntax
   '$lang: "lang"
      or
   Rem $lang: "lang"

Parameters
   "lang"
      The dialect to set, enclosed in double quotes, and must be one of 
      "fb", "fblite", "qb", or "deprecated".

Description
   If the -forcelang option was not given on the command line, $Lang can be 
   used to set the dialect for the source module in which it appears.  At 
   most two passes will be made on the source module.  On the first pass, 
   if the specified dialect is anything other than the default dialect 
   (chosen with -lang, or "fb" by default), the compiler will reset the 
   parser for another pass and restart compilation at the beginning of the 
   source module.  If this metacommand is encountered again on the second 
   pass, and the specified dialect does not match the new current dialect, 
   a warning is issued and compilation continues.  If any errors were 
   encountered on the first pass, the compiler will not attempt a second 
   pass.

   $Lang  may not be used in any compound statement, scope, or subroutine.  
   However, it may be nested in module level preprocessor statements or 
   used in an include file.

   There is currently no restriction on where this directive may be placed 
   in a source module.  In future this may change, therefore best practice 
   would be to use this directive before the first declaration, definition, 
   or executable statement in the source.

   This directive overrides the -lang option if it was given on the command 
   line.  However, if the -forcelang option was given on the command line, 
   this directive will have no effect.  A warning is issued, the directive 
   is ignored, and compilation will continue.  This allows the user to 
   explicitly override $Lang metacommands.

   This metacommand was introduced in FreeBASIC version 0.20.0.  Older 
   versions of FB, and QuickBASIC, will treat it as a comment and silently 
   ignore it.

Example
   '$lang: "qb"

Differences from QB
   * New to FreeBASIC
   * QB handles '$lang: as a normal comment

See also
   * #lang
   * __FB_LANG__
   * Compiler Option: -lang
   * Compiler Option: -forcelang
   * FreeBASIC Dialects



------------------------------------------------------- KeyPgMetaStatic ----
$Static

Metacommand to change the way arrays are allocated

Syntax
   '$Static
      or
   Rem $Static

Description
   '$Static is a metacommand that overrides the behavior of $Dynamic, that 
   is, arrays declared with constant subscript ranges are fixed-length. 
   This remains in effect for the rest of the module in which '$Static is 
   used, and can be overridden with $Dynamic.  It is equivalent to the 
   Option Static statement.

Example
   ' compile with -lang fblite or qb

   #lang "fblite"

   '$dynamic
   Dim a(100)   '<<this array will be variable-length
   '$static
   Dim b(100)   '<<this array will be fixed-length

Dialect Differences
   * Only available in the -lang fblite and -lang qb dialects.

Differences from QB
   * When used inside comments it must be the first token

See also
   * $Dynamic
   * Dim
   * Erase
   * ReDim
   * Option Dynamic
   * Option Static




============================================================================
    ?

------------------------------------------------------------ KeyPgPrint ----
(Print | ?)

Writes text to the screen

Syntax
   (Print | ?) [ expressionlist ] [ , | ; ]

Parameters
   expressionlist
      list of items to print

Description
   Print outputs a list of values to the screen. Numeric values are 
   converted to their string representation, with left padding for the 
   sign. Objects of user-defined types must overload Operator Cast () As 
   String.

   Consecutive values in the expression list are separated either by a 
   comma (,) or semicolon (;). A comma indicates printing should take place 
   at the next 14 column boundary, while a semicolon indicates values are 
   printed with no space between them.  This has a similar effect to 
   concatenating expressions using + or &.

   Print also supports the special expressions, Spc() and Tab().  These can 
   be used to space out expressions, or to align the printing to a specific 
   column.

   A new-line character is printed after the values in the expression list 
   unless the expression list is followed by a comma or semicolon.  A Print 
   without any expressions or separators following it will just print a 
   new-line.

   NOTE: Print resets the Err value after each expression is printed.

   NOTE: In graphics mode, Draw String provides a flexible alternative to 
   Print: it prints a string to the screen with pixel positioning, 
   transparent background, and can use a user-supplied font.

Example
   '' print "Hello World!", and a new-line
   Print "Hello World!"

   '' print several strings on one line, then print a new-line
   Print "Hello";
   Print "World"; "!";
   Print

   '' column separator
   Print "Hello!", "World!"

   '' printing variables/expressions
   Dim As Double pi = Atn(1) * 4
   Dim As String s = "FreeBASIC"

   Print "3 * 4 ="; 3 * 4

   Print "Pi is approximately"; pi
   Print s; " is great!"

Dialect Differences
   * In the -lang qb dialect, an extra space is printed after numbers.

Differences from QB
   * None, when using QBASIC's variable types in -lang qb.
   * Unsigned numbers are printed without a space before them.
   * QB did not support casting for UDTs, so didn't allow them to be Print
     ed.

See also
   * Spc
   * Tab
   * Print #
   * ? #
   * Print Using
   * ? Using
   * Write
   * Draw String
   * Input



---------------------------------------------------------- KeyPgPrintPp ----
(Print | ?) #

Writes a list of values to a file or device

Syntax
   (Print | ?) # filenum, [ expressionlist ] [ , | ; ]

Parameters
   filenum
      The file number of a file or device opened for Output or Append.
   expressionlist
      List of values to write.

Description
   Print # outputs a list of values to a text file or device. Numeric 
   values are converted to their string representation, with left padding 
   for the sign. Objects of user-defined types must overload Operator Cast 
   () As String.

   Consecutive values in the expression list are separated either by a 
   comma (,) or semicolon (;). A comma indicates printing should take place 
   at the next 14 column boundary, while a semicolon indicates values are 
   printed with no space between them.

   A new-line character is printed after the values in the expression list 
   unless the expression list is followed by a comma or semicolon.

   Note that the comma (,) immediately following the file number is still 
   necessary, even the expression list is empty.  In this case a new-line 
   is printed, just as with a normal expression list that doesn't have a 
   comma or semicolon at the end.

Example
   Open "bleh.dat"  For Output As #1
      
      Print #1, "abc def"
      Print #1, 1234, 5678.901, "xyz zzz"
      
      Close #1

Dialect Differences
   * In the -lang qb dialect, an extra space is printed after numbers.

Differences from QB
   * None, when using QBASIC's variable types in -lang qb.
   * Unsigned numbers are printed without a space before them.
   * QB did not support casting for UDTs, so didn't allow them to be Print
     ed.

See also
   * Print Using
   * ? Using
   * Print
   * ?
   * Write #
   * Open



------------------------------------------------------- KeyPgPrintusing ----
(Print | ?) Using

Outputs formatted text to the screen or output device

Syntax
   (Print | ?) [# filenum ,] [ printexpressionlist {,|;} ] Using 
   formatstring ; [ expressionlist [ ; ] ]

Parameters
   filenum
      The file number of a file or device opened for Output or Append.  
      (Alternatively LPrint may be used where appropriate, instead of 
      Print #)
   printexpressionlist
      Optional preceding list of items to print, separated by commas (,) or 
      semi-colons (;) (see Print for more details).
   formatstring
      Format string to use.
   expressionlist
      List of items to format, separated by semi-colons (;).

Description
   Print to screen various expressions using a format determined by the 
   formatstring parameter. Internally, Print Using uses a buffer size of 
   2048 bytes: while it is highly unlikely that this buffer would be 
   filled, it should be noted that output would be truncated should this 
   limit be reached.

   If no expression list is given, the format string will be printed up to 
   the first special marker.  Note that the semi-colon after formatstring 
   is still necessary, even if no expression list is given.

   The format string dictates how the expressions are to be formatted when 
   output to the screen, indicated by the use of special marker characters. 
   There are markers for formatting both string and numeric output:

   String formatting

         +------+----------------------------------------------------------------------+
         |Marker|Formatting                                                            |
         |!     |prints the first character of a string                                |
         |\   \ |prints as many characters of a string as occupied between the pair \ \|
         |&     |prints the entire string                                              |
         +------+----------------------------------------------------------------------+

   Numeric formatting

         +------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+
         |Marker|Formatting                                                                                                                                                            |
         |#     |placeholder for either an integer digit, or a decimal digit if a decimal point precedes it                                                                            |
         |,     |placed after integer digit indicates groups of 3 digits should be separated by commas in fixed-point notation                                                         |
         |.     |placed near # indicates place for the decimal point                                                                                                                   |
         |^^^   |uses exponential notation (E+/-#) when placed after the digit characters                                                                                              |
         |^^^^  |uses exponential notation (E+/-##) when placed after the digit characters                                                                                             |
         |^^^^^ |uses exponential notation (E+/-###) when placed after the digit characters                                                                                            |
         |+     |placed before/after the format string, controls whether the sign of a number is prepended/appended, and causes an explicit '+' sign to be printed for positive numbers|
         |-     |placed after the format string, causes the sign of the number to be appended rather than prepended, appending a space/negative sign for positive/negative numbers     |
         |$$    |placed at the start of integer digits, causes a dollar sign to be prepended to the number (after the sign if one is prepended)                                        |
         |**    |placed at the start of integer digits, causes any padding on the left to be changed from spaces to asterisks                                                          |
         |**$   |placed at the start of integer digits, pads on the left with asterisks, and prepends a dollar sign after the asterisks                                                |
         |&     |prints a number intelligently, using the exact number of digits required (new to version 0.21.0b)                                                                     |
         +------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+

   All of the special marker characters can be escaped by preceding them 
   with the underscore character "_", allowing them to be printed directly. 
   For example, "_!" is printed as "!", and "__" is printed as "_".

   If a numerical value cannot fit in the number of digits indicated by the 
   format string, the formatting is adapted to fit the number, possibly 
   switching to scientific notation, and the number is printed preceded by 
   the percent "%" character. E.g., the number 1234 with a formatstring of 
   "##.##" would be printed as "%1234.00".

   All other characters within the format string are printed as they 
   appear.

   A new-line character is printed after the values in the expression list 
   unless the expression list is followed by a semicolon (;).

Example

   Print Using "The value is #.## seconds"; 1.019
   Print Using "The ASCII code for the pound sign (_#) is ###"; Asc("#")
   Print Using "The last day in the year is & \ \"; 31; "December"

   will produce the output:

   The value Is 1.02 seconds
   The ASCII code For the pound sign (#) Is  35
   The last Day in the Year Is 31 Dec

Differences from QB
   * QB didn't allow "&" to be used for printing numbers.

See also
   * Print
   * ?
   * Print #
   * ? #
   * Format
   * Using
   * Palette Using




============================================================================
    A

-------------------------------------------------------------- KeyPgAbs ----
Abs

Calculates the absolute value of a number

Syntax
   Declare Function Abs ( ByVal number As Integer ) As Integer
   Declare Function Abs ( ByVal number As UInteger ) As UInteger
   Declare Function Abs ( ByVal number As Double ) As Double

Usage
   result = Abs( number )

Parameters
   number
      Value to find the absolute value of.

Return Value
   The absolute value of number.

Description
   The absolute value of a number is its positive magnitude.  If a number 
   is negative, its value will be negated and the positive result returned. 
   For example, Abs(-1) and Abs(1) both return 1. The required number 
   argument can be any valid numeric expression.
   Unsigned numbers will be treated as if they were signed, i.e. if the 
   highest bit is set the number will be treated as negative, and its value 
   negated.
   The value returned will be greater than or equal to 0, with the 
   exception of signed integers containing the lowest possible negative 
   value that can be stored in its type, in which case negating it will 
   overflow the result.

   The Abs unary Operator can be overloaded with user defined types.

Example
   Dim n As Integer

   Print Abs( -1 )
   Print Abs( -3.1415 )
   Print Abs( 42 )
   Print Abs( n )

   n = -69

   Print Abs( n )

Output:

   1
   3.1415
   42
   0
   69

Dialect Differences
   * In the -lang qb dialect, this operator cannot be overloaded.

Differences from QB
   * None

See also
   * Sgn
   * Operator



--------------------------------------------------------- KeyPgAbstract ----
Abstract

Declare abstract methods

Syntax
   Type typename Extends base_typename
      Declare Abstract Sub|Function|Property|Operator ...
   End Type

Description
   Abstract is a special form of Virtual. The difference is that abstract 
   methods do not have a body, but just the declaration. Essentially this 
   allows the declaration of an interface which can be implemented by 
   various derived types.

   In order to call an abstract method, it must have been overridden and 
   implemented by a derived data type, or else the program will abort.
   As a result, only types that implement all the abstract methods are 
   allowed to create objects. For the same reason, a constructor should not 
   call an unimplemented method.

   Constructors cannot be abstract, since they cannot be virtual. In 
   addition, abstract Destructors are not supported either, because a 
   destructor body (no matter whether implicit or explicit) is needed in 
   order to call base and field destructors.

   Abstracts are called "pure virtual" in C++ (unlike FreeBASIC, C++ allows 
   pure virtuals to have a body, but accessible only statically).

   Note: In a multi-level inheritance, a same named method (same identifier 
   and signature) can be declared Abstract, Virtual or normal (without 
   specifier) at each inheritance hierarchy level. When there is mixing of 
   specifiers, the usual order is abstract -> virtual -> normal, from top 
   to bottom of the inheritance hierarchy.
   The access control (Public/Protected/Private) of an overriding method is 
   not taken into account by the internal polymorphism process, but only 
   for the initial call at compile-time.
   A derived static method cannot override a base virtual/abstract method, 
   but can shadow any base method (including virtual/abstract).

Example
   Type Hello Extends Object
      Declare Abstract Sub hi( )
   End Type

   Type HelloEnglish Extends Hello
      Declare Sub hi( )
   End Type

   Type HelloFrench Extends Hello
      Declare Sub hi( )
   End Type

   Type HelloGerman Extends Hello
      Declare Sub hi( )
   End Type

   Sub HelloEnglish.hi( )
      Print "hello!"
   End Sub

   Sub HelloFrench.hi( )
      Print "Salut!"
   End Sub

   Sub HelloGerman.hi( )
      Print "Hallo!"
   End Sub

      Randomize( Timer( ) )

      Dim As Hello Ptr h

      For i As Integer = 0 To 9
         Select Case( Int( Rnd( ) * 3 ) + 1 )
         Case 1
            h = New HelloFrench
         Case 2
            h = New HelloGerman
         Case Else
            h = New HelloEnglish
         End Select

         h->hi( )
         Delete h
      Next

Dialect Differences
   * Only available in the -lang fb dialect.

Differences from QB
   * New to FreeBASIC

See also
   * Virtual
   * Type
   * Extends
   * Extends Zstring
   * Extends Wstring
   * Object
   * Override



----------------------------------------------------------- KeyPgAccess ----
Access

Clause of the Open statement to specify requested privileges

Syntax
   Open filename for Binary Access {Read | Write | Read Write} as [#]
   filenum

Usage
   open filename for binary Access Read as #filenum
   open filename for binary Access Write as #filenum
   open filename for binary Access Read Write as #filenum

Parameters
   Read
      Open the file with only read privileges.
   Write
      Open the file with only write privileges.
   Read Write
      Open the file with read and write privileges.

Description
   Access is used with the Open statement to request read, write, or read 
   and write privileges.  If the Access clause is not specified, Read Write 
   is assumed.

Example

This example shows how to open the file "data.raw" with Read and then 
"data.out" with Write access, in Binary mode, in an open file number 
returned by FreeFile.
   Dim As Integer o

     '' get an open file number.
     o = FreeFile
     
     '' open file for read-only access.    
     Open "data.raw" For Binary Access Read As #o
      
      '' make a buffer in memory thats the entire size of the file
      Dim As UByte file_char( LOF( o ) - 1 )

        '' get the file into the buffer.      
        Get #o, , file_char()
      
     Close
     
     '' get another open file number.
     o = FreeFile
     
     '' open file for write-only access.    
     Open "data.out" For Binary Access Write As #o

      '' put the buffer into the new file.      
      Put #o, , file_char()
      
     Close

     Print "Copied file ""data.raw"" to file ""data.out"""

     Sleep

Differences from QB
   * None known.

See also
   * Open
   * Read
   * Write



------------------------------------------------------------- KeyPgAcos ----
Acos

Finds the arccosine of an angle

Syntax
   Declare Function Acos ( ByVal number As Double ) As Double

Usage
   result = Acos( number )

Parameters
   number
      A cosine value in the range [-1..1].

Return Value
   The arccosine of number, in radians, in the range [0..Pi].

Description
   Acos returns the arccosine of the argument number as a Double within the 
   range of 0 to Pi.  The arccosine is the inverse of the Cos function. The 
   returned angle is measured in radians (not degrees).

   Acos can be overloaded as operator to accept user-defined types.

Example
   Dim h As Double
   Dim a As Double
   Input "Please enter the length of the hypotenuse of a triangle: ", h
   Input "Please enter the length of the adjacent side of the triangle: ", a
   Print ""
   Print "The angle between the sides is"; Acos ( a / h )
   Sleep

The output would look like:

   Please enter the length of the hypotenuse of a triangle: 5
   Please enter the length of the adjacent side of the triangle: 4

   The angle between the sides Is 0.6435011087932843

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Acos.

Differences from QB
   * New to FreeBASIC

See also
   * Cos
   * A Brief Introduction To Trigonometry



----------------------------------------------------------- KeyPgAddGfx ----
Add

Parameter to the Put graphics statement which selects addition as the 
blitting method

Syntax
   Put [ target, ] [ STEP ] ( x,y ), source [ ,( x1,y1 )-( x2,y2 ) ], Add[ 
   ,multiplier ]

Parameters
   Add
      Required.
   multiplier
      Optional value between 0 and 255.  The source pixels are 
      premultiplied by (multiplier / 256) before being added.  If omitted, 
      this value defaults to 255.

Description
   Add selects addition as the method for blitting an image buffer.  For 
   each source and target pixel, the values of each respective component 
   are added together to produce the result.
   The addition is saturated - i.e. if the sum of the two values is 256 or 
   more, then it will be cropped down to 255.

   This method will work in all color modes.  Mask colors (color 0 for 
   indexed images, magenta (RGB(255, 0, 255)) for full color images) will 
   be skipped, though full color values of 0 (RGBA(0, 0, 0, 0)) will have 
   also have no effect.

Example
   ''open a graphics window
   ScreenRes 320, 200, 16

   ''create a sprite containing a circle
   Const As Integer r = 32
   Dim c As Any Ptr = ImageCreate(r * 2 + 1, r * 2 + 1, 0)
   Circle c, (r, r), r, RGB(255, 255, 192), , , 1, f

   ''put the sprite at three different multipier
   ''levels, overlapping each other in the middle
   Put (146 - r, 108 - r), c, Add,  64
   Put (174 - r, 108 - r), c, Add, 128
   Put (160 - r,  84 - r), c, Add, 192

   ''free the memory used by the sprite
   ImageDestroy c

   ''pause the program before closing
   Sleep

Differences from QB
   * New to FreeBASIC

See also
   *Trans
   *Alpha
   *Custom
   * Put (Graphics)



------------------------------------------------------------ KeyPgAlias ----
Alias (Name)

Clause of the Sub and Function statements that provides an alternate 
internal name.

Syntax
   [Declare] { Sub | Function } usablename Alias "alternatename" (...)

Usage
   declare sub usablename Alias "alternatename" ( ... )
      or
   declare function usablename Alias "alternatename" ( ... )
      or
   sub usablename Alias "alternatename" ( ... )
      ...
   end sub
      or
   function usablename Alias "alternatename" ( ... )
      ...
   end function
      or
   type typename Alias "alternatename" ( ... )
      ...
   end type

Description
   Alias gives an alternate name to a procedure.  This alternate name 
   cannot be used within the program to call the procedure, but it is 
   visible (if the function is not private) to the linker when linking with 
   code written in other languages.

   Alias is commonly used for procedures in libraries written in other 
   languages when such procedure names are valid in the other language but 
   invalid in BASIC.  When using Alias with Declare, only the alternate 
   name is used by the linker.

   Differently from normal procedure names, Alias does not change the case 
   of the alternate name, so it is useful when external code requires an 
   exported function with a particular name or with a particular case.

   Alias can be used to specify an alternate name for Type definitions.

   Alias can be used as a modifier that specifies an alternate name 
   mangling for procedure parameters.  See Alias (Modifier)

Example

If there is a sub called xClearScreen in an external library and you want 
to reference it with the name ClearVideoScreen, here is sample code to do 
so:
   Declare Sub ClearVideoScreen Alias "xClearScreen" ()

A procedure meant to be used by external C code, exported as MyExportedProc
:
   Function MultiplyByFive cdecl Alias "MyExportedProc" (ByVal Parameter As Integer) As Integer Export
     Return Parameter * 5
   End Function

Differences from QB
   * In QB, Alias only worked with Declare.

See also
   * Declare
   * Export
   * Type (Alias)
   * Alias (Modifier)



---------------------------------------------------- KeyPgAliasModifier ----
Alias (Modifier)

Modifies the data type name mangling (decoration) of a public symbol

Syntax
   ... As [ Const ] datatype alias "modifier" [ Const [ Ptr ... ] ]

Usage
   Dim variable As datatype alias "modifier"
   Type name As datatype alias "modifier"
   Declare Sub name ( param As datatype alias "modifier", ... )
   Declare Function name ( param As datatype alias "modifier", ... ) As 
   datatype alias "modifier"

Parameters
   datatype
      Standard data type or user defined data type to modify
   modifier
      One of the supported modifiers as described in Description section 
      following

Description
   Alias "modifier", when specified following a data type, gives an 
   alternate meaning to the data type, which may be needed for linking with 
   languages other than FreeBASIC.

   Public symbol names are mangled (decorated) to encode information about 
   the data type that is used for the symbol.  When linking with the c 
   language, the special meaning of the alias modifier is meaningless, 
   since the extra information is not encoded in to the public name.  When 
   linking with the c++ language, typically more information is encoded in 
   to the public symbol, and the alias modifier may be required.  The 
   public name is written to the compiled object file, and used by the 
   linker to match symbol names from one object module to another.

   The same rules for mapping data types is used regardless of which 
   backend (gas or gcc) code emitter is used,  And the intent is that FB's 
   compiled code can link consistently with it's own object modules and 
   object modules (or libraries) compiled from other languages.

   Supported Modifiers

      Long alias "long"
      ULong alias "long"
         On Win 64-bit targets, used to map FB's 32-bit Long and ULong 
         types to c/c++'s 32-bit long [int] type, instead of the 32-bit int 
         type.

      Any alias "char" Ptr
         Maps any ptr to c/c++'s char *.  In c/c++, char, signed char, and 
         unsigned char, are three distinct types.
         * Byte Ptr maps to signed char *
         * UByte Ptr maps to unsigned char *
         * On some platforms the variable argument list va_list type is a 
           typed as a char *, but FB does not have an equivalent type, 
           therefore Any Ptr is used instead.  Linking with names encoded 
           with this type will fail since, normally, FB encodes void * data 
           type instead of char *.
         * alias "char" keeps the any ptr behaviour in FB but then encodes 
           the public name as char * for linking.

      any alias "__builtin_va_list" ptr
         Maps the data type to gcc's __builtin_va_list type
         * expected that gcc's built-in type is a pointer type
         * used on dos, win32, win64, linux-x86, targets
         * see Cvalist for default usage in the cva_list data type

      alias "__builtin_va_list"
         Maps the data type to gcc's __builtin_va_list type
         * expected that gcc's built-in type is a struct type
         * used on aarch64 target
         * see Cvalist for default usage in the cva_list data type

      alias "__builtin_va_list[]"
         Maps the data type to gcc's __builtin_va_list type
         * expected that gcc's built-in type is a struct array type
         * used on linux-x86_64 target
         * see Cvalist for default usage in the cva_list data type

   Data Type Mapping Details

   On all targets, FB to c/c++:
   Several of FB's data types are consistently mapped across all targets:
      * 8-bit Byte maps to signed char
      * 8-bit UByte maps to unsigned char
      * 16-bit Short maps to [signed] short [int]
      * 16-bit UShort maps to unsigned short [int]
      * 32-bit Long maps to int
      * 32-bit ULong maps to unsigned int
      * 64-bit LongInt maps to long long [int]
      * 64-bit ULongInt maps to unsigned long long [int]

   On Dos/Win/Linux 32-bit targets, FB to c/c++:
   Integer on 32-bit targets is 32-bits wide
      * 32-bit Integer maps to long [int]
      * 32-bit UInteger maps to unsigned long [int]

   On Linux 64-bit targets, FB to c/c++:
   Integer on 64-bit targets is 64-bits wide
      * 64-bit Integer maps to long [int]
      * 64-bit UInteger maps to unsigned long [int]

   On Win 64-bit targets, FB to c/c++:
   Integer on 64-bit targets is 64-bits wide.  However, on Win target, 
   c/c++'s long int type is 32-bit, not 64-bit, and we can't use the long 
   long int mangling because it's already used by FB's LongInt type.  
   Reusing the same mangling (decoration) for two different data types 
   would cause function overloading to fail or have duplicate definitions.  
   To preserve FB's behaviour that Integer on 64-bit targets is always 
   64-bits, we mangle (decorate) the symbol with a custom datatype and keep 
   the size at 64-bit.
      * 64-bit Integer maps to custom INTEGER
      * 64-bit UInteger maps to custom UINTEGER
      To create a data type in FB that will map to c/c++'s long [int] 
      32-bit on win, we must use alias modifier.
      * 32-bit Long alias "long"  maps to long [int]
      * 32-bit ULong alias "long"  maps to unsigned long [int]

      For example extern c++ : declare sub proc( byval as long alias "long" 
      ) : end extern.  This allows FreeBASIC to call external c++ 
      procedures (on win-64) requiring a 32-bit long int type.  Usage of 
      Alias in this way affects win-64 targets only, and is ignored on all 
      other targets.

Example
   See example at Alias (Name).

Version
   * Since fbc 1.06.0

Differences from QB
   * In QB, Alias only worked with Declare.

See also
   * Alias (Name)
   * Declare
   * Export
   * Type (Alias)



--------------------------------------------------------- KeyPgAllocate ----
Allocate

Allocates a block of memory from the free store

Syntax
   Declare Function Allocate cdecl ( ByVal count As UInteger ) As Any Ptr

Usage
   result = Allocate( count )

Parameters
   count
      The size, in bytes, of the block of memory to allocate.

Return Value
   If successful, the address of the start of the allocated memory is 
   returned. Otherwise, if the requested block size could not be allocated, 
   or if count < 0, then the null pointer (0) is returned.

Description
   Attempts to allocate, or reserve, count number of bytes from the free 
   store (heap). The newly allocated memory is not initialized.

   As the initial value of newly allocated memory is unspecified, Allocate 
   must not be directly used with String or Udt containing string, because 
   the string descriptor being not cleared (containing random data), that 
   may induce corrupted string or more (trying to write to a random place 
   in memory or trying to deallocate a random pointer).  It is mandatory in 
   that case (with string or UDT containing string) to use CAllocate 
   (clearing memory), or New Expression (calling constructor) in case of 
   UDT, or at worst after Allocate to explicitly clear the descriptor 
   (setting to 0) before the first string use.
   For allocating memory for a ZString or a WString, see the corresponding 
   page.

   The pointer that is returned is an Any Ptr and points to the start of 
   the allocated memory. This pointer is guaranteed to be unique, even if 
   count is zero.

   Allocated memory must be deallocated, or returned back to the free 
   store, with Deallocate when no longer needed. 

Example
   '' This program uses the ALLOCATE(...) function to create a buffer of 15 integers that is
   '' then filled with the first 15 numbers of the Fibonacci Sequence, then output to the
   '' screen. Note the call to DEALLOCATE(...) at the end of the program.

      Const integerCount As Integer = 15

      '' Try allocating memory for a number of integers.
      ''
      Dim buffer As Integer Ptr
      buffer = Allocate(integerCount * SizeOf(Integer))

      If (0 = buffer) Then
         Print "Error: unable to allocate memory, quitting."
         End -1
      End If

      '' Prime and fill the memory with the fibonacci sequence.
      ''
      buffer[0] = 0
      buffer[1] = 1
      For i As Integer = 2 To integerCount - 1
         buffer[i] = buffer[i - 1] + buffer[i - 2]
      Next

      '' Display the sequence.
      ''
      For i As Integer = 0 To integerCount - 1
         Print buffer[i] ;
      Next

      Deallocate(buffer)
      End 0

   Output is:
    0 1 1 2 3 5 8 13 21 34 55 89 144 233 377

   It is important to free allocated memory if it's not going to be used 
   anymore. Unused memory that isn't freed is simply wasting memory, and if 
   the address of that memory is somehow overwritten or forgotten, that 
   memory can never be freed. This condition is known as a memory leak, and 
   should be avoided at all costs. Note that leaked memory is always 
   completely freed when the application terminates, either by an 
   "ordinary" exit or crash, so the leak "persists" only as long as the 
   application runs, nevertheless it's a good habit to free any allocated 
   memory inside your application. The following example demonstrates a 
   function with a memory leak, where the address of allocated memory is 
   lost and isn't and can't be freed anymore. If such a function is called 
   frequently, the total amount of memory wasted can add up quickly.

   '' Bad example of Allocate usage, causing memory leaks

   Sub BadAllocateExample()

      Dim p As Byte Ptr

      p = Allocate(420)   '' assign pointer to new memory

      p = Allocate(420)   '' reassign same pointer to different memory,
                     '' old address is lost and that memory is leaked

      Deallocate(p)

   End Sub

      '' Main
      BadAllocateExample() '' Creates a memory leak 
      Print "Memory leak!"
      BadAllocateExample() '' ... and another
      Print "Memory leak!"
      End

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Allocate 

Differences from QB
   * New to FreeBASIC

See also
   * CAllocate
   * Reallocate
   * Deallocate



--------------------------------------------------------- KeyPgAlphaGfx ----
Alpha

Parameter to the Put graphics statement which selects alpha blending as the 
method

Syntax
   Put [ target, ] [ STEP ] ( x,y ), source [ ,( x1,y1 )-( x2,y2 ) ], Alpha
   Put [ target, ] [ STEP ] ( x,y ), source [ ,( x1,y1 )-( x2,y2 ) ], Alpha
   , alphaval

Parameters
   Alpha
      Required.
   alphaval
      Optional alpha parameter in the range [0..255].  Overrides alpha 
      values in individual pixels.

Description
   Alpha selects alpha blending as the method for Putting an image.  If the 
   alphaval parameter is specified, it overrides the alpha value of each 
   pixel, and the mask color (magenta) will be treated as transparent.  
   This works in 15, 16, 24, or 32-bit color depths.

   If alphaval is not specified, Alpha will only work in 32-bit color 
   depth, and Put will use the alpha value embedded within each pixel.  
   Pixels using the mask color will be treated as normal, and drawn with 
   their given alpha value.

   Alpha also has another mode which allows an 8-bit image to be Put on top 
   of a 32-bit image.  In this case, it will replace the alpha channel of 
   the 32-bit image with the contents of the 8-bit image.

      Alpha values range between 0 and 255.  An alpha value of 0 will not 
      draw the image at all.  All other alpha values are incremented by 1 
      to get a range between 2 and 256, and the result is then divided by 
      256 to get a value between 1/128 and 1, which is used to calculate 
      the exact value of each pixel from the source and destination pixels. 
      Thus, 255 is practically equivalent to drawing using Put with Trans 
      blitting mode, 0 is equivalent to doing nothing at all, and all the 
      other alpha values blend is expected.

Example
   This example compares the two different Alpha modes, including how they 
   react to the mask color
   '' Set up a 32-bit screen
   ScreenRes 320, 200, 32

   '' Draw checkered background
   For y As Integer = 0 To 199
      For x As Integer = 0 To 319
         PSet (x, y), IIf((x Shr 2 Xor y Shr 2) And 1, RGB(160, 160, 160), RGB(128, 128, 128))
      Next x
   Next y

   '' Make image sprite for Putting
   Dim img As Any Ptr = ImageCreate(32, 32, RGBA(0, 0, 0, 0))
   For y As Single = -15.5 To 15.5
      For x As Single = -15.5 To 15.5
         Dim As Integer r, g, b, a
         If y <= 0 Then
            If x <= 0 Then
               r = 255: g = 0: b = 0   '' red
            Else
               r = 0: g = 0: b = 255   '' blue
            End If
         Else
            If x <= 0 Then
               r = 0: g = 255: b = 0   '' green
            Else
               r = 255: g = 0: b = 255 '' magenta (transparent mask color)
            End If
         End If
         a = 255 - (x ^ 2 + y ^ 2)
         If a < 0 Then a = 0': r = 255: g = 0: b = 255
         PSet img, (15.5 + x, 15.5 - y), RGBA(r, g, b, a)
      Next x
   Next y

   '' Put with single Alpha value, Trans for comparison
   Draw String (32, 10), "Single alpha"
   Put (80 - 16,  50 - 16), img, Alpha, 64
   Put (80 - 16, 100 - 16), img, Alpha, 192
   Put (80 - 16, 150 - 16), img, Trans

   '' Put with full Alpha channel
   Draw String (200, 10), "Full alpha"
   Put (240 - 16, 100 - 16), img, Alpha

   '' Free the image memory
   ImageDestroy img

   '' Wait for a keypress
   Sleep

   This example shows the special method for setting a 32-bit alpha channel 
   using an 8-bit image
   Dim As Any Ptr img8, img32
   Dim As Integer x, y, i

   '' Set up an 8-bit graphics screen
   ScreenRes 320, 200, 8
   For i = 0 To 255
      Palette i,  i, i, i
   Next i
   Color 255, 0

   '' Create an 8-bit image
   img8 = ImageCreate(64, 64, 0,  8)
   For y = 0 To 63
      For x = 0 To 63
         Dim As Single x2 = x - 31.5, y2 = y - 31.5
         Dim As Single t = Sqr(x2 ^ 2 + y2 ^ 2) / 5
         PSet img8, (x, y), Sin(t) ^ 2 * 255
      Next x
   Next y

   Draw String (16, 4), "8-bit Alpha sprite"
   Put (16, 16), img8
   Sleep

   '' Set up a 32-bit graphics screen
   ScreenRes 320, 200, 32
   For y = 0 To 199
      For x = 0 To 319
         PSet (x, y), IIf(x - y And 3, RGB(160, 160, 160), RGB(128, 128, 128))
      Next x
   Next y

   '' Create a 32-bit, fully opaque sprite
   img32 = ImageCreate(64, 64, 0, 32)
   For y = 0 To 63
      For x = 0 To 63
         PSet img32, (x, y), RGB(x * 4, y * 4, 128)
      Next x
   Next y

   Draw String (16, 4), "Original Alpha channel"
   Put (16, 16), img32, Alpha

   '' Put a new alpha channel using the 8-bit image
   Put img32, (0, 0), img8, Alpha

   Draw String (16, 104), "New Alpha channel"
   Put (16, 116), img32, Alpha

   ''Free the memory for the two images
   ImageDestroy img8
   ImageDestroy img32

   Sleep

Differences from QB
   * New to FreeBASIC

See also
   * Put (Graphics)
   * Trans
   * Custom



------------------------------------------------------------ KeyPgOpAnd ----
Operator And (Conjunction)

Returns the bitwise-and (conjunction) of two numeric values

Syntax
   Declare Operator And ( ByRef lhs As T1, ByRef rhs As T2 ) As Ret

Usage
   result = lhs And rhs

Parameters
   lhs
      The left-hand side expression.
   T1
      Any numeric or boolean type.
   rhs
      The right-hand side expression.
   T2
      Any numeric or boolean type.
   Ret
      A numeric or boolean type (varies with T1 and T2).

Return Value
   Returns the bitwise-and (conjunction) of the two operands.

Description
   This operator returns the bitwise-and of its operands, a logical 
   operation that results in a value with bits set depending on the bits of 
   the operands (for conversion of a boolean to an integer, false or true 
   boolean value becomes 0 or -1 integer value).

   The truth table below demonstrates all combinations of a boolean-and 
   operation:

      +-------+-------+------+
      |Lhs Bit|Rhs Bit|Result|
      |0      |0      |0     |
      |1      |0      |0     |
      |0      |1      |0     |
      |1      |1      |1     |
      +-------+-------+------+

   No short-circuiting is performed - both expressions are always 
   evaluated.

   The return type depends on the types of values passed. Byte, UByte and 
   floating-point type values are first converted to Integer. If the left 
   and right-hand side types differ only in signedness, then the return 
   type is the same as the left-hand side type (T1), otherwise, the larger 
   of the two types is returned. Only if the left and right-hand side types 
   are both Boolean, the return type is also Boolean.

   This operator can be overloaded for user-defined types.

Example
   ' Using the AND operator on two numeric values
   Dim As UByte numeric_value1, numeric_value2
   numeric_value1 = 15 '00001111
   numeric_value2 = 30 '00011110

   'Result =  14  =     00001110
   Print numeric_value1 And numeric_value2
   Sleep

   ' Using the AND operator on two conditional expressions
   Dim As UByte numeric_value1, numeric_value2
   numeric_value1 = 15
   numeric_value2 = 25

   If numeric_value1 > 10 And numeric_value1 < 20 Then Print "Numeric_Value1 is between 10 and 20"
   If numeric_value2 > 10 And numeric_value2 < 20 Then Print "Numeric_Value2 is between 10 and 20"
   Sleep

   ' This will output "Numeric_Value1 is between 10 and 20" because
   ' both conditions of the IF statement is true
   ' It will not output the result of the second IF statement because the first
   ' condition is true and the second is false.

Dialect Differences
   * In the -lang qb dialect, this operator cannot be overloaded.

Differences from QB
   * None

See also
   * AndAlso
   * Operator Truth Tables



-------------------------------------------------------- KeyPgOpAndAlso ----
Operator Andalso (Short Circuit Conjunction)

Returns the short circuit-and (conjunction) of two numeric values

Syntax
   Declare Operator AndAlso ( ByRef lhs As T1, ByRef rhs As T2 ) As Ret

Usage
   result = lhs AndAlso rhs

Parameters
   lhs
      The left-hand side expression.
   T1
      Any numeric or boolean type.
   rhs
      The right-hand side expression.
   T2
      Any numeric or boolean type.
   Ret
      A numeric or boolean type (varies with T1 and T2).

Return Value
   Returns the short circuit-and (conjunction) of the two operands.

Description
   This operator evaluates the left hand side expression.  If the result is 
   zero, then zero is immediately returned.  If the result is nonzero then 
   the right hand side is evaluated, and the logical result from that is 
   returned.
   (for conversion of a boolean to an integer, false or true boolean value 
   becomes 0 or -1 integer value) 

   The truth table below demonstrates all combinations of a short 
   circuit-and operation, the '-' denotes that the operand is not 
   evaluated.

      +---------+---------+------+
      |Lhs Value|Rhs Value|Result|
      |0        |-        |0     |
      |nonzero  |0        |0     |
      |nonzero  |nonzero  |-1    |
      +---------+---------+------+

   Short-circuiting is performed - only expressions needed to calculate the 
   result are evaluated.  The left hand side lhs is evaluated first, and 
   only if it evaluates to non-zero (true) is the right hand side rhs also 
   evaluated.  If the left hand side evaluation lhs returns zero (false), 
   it is known that at that point that the overall condition is false, so 
   the right hand side rhs is not evaluated (skipped).

   The return type is almost always an Integer, of the value 0 or -1, 
   denoting false and true respectively. Except if the left and right-hand 
   side types are both Boolean, then the return type is also Boolean.

   This operator cannot be overloaded for user-defined types.

Example
   '' Using the ANDALSO operator to guard against array access
   '' when the index is out of range

   Dim As Integer isprime(1 To 10) = { _
      _ ' 1  2  3  4  5  6  7  8  9  10
         0, 1, 1, 0, 1, 0, 1, 0, 0, 0 _
      }

   Dim As Integer n
   Input "Enter a number between 1 and 10: ", n

   '' isprime() array will only be accessed if n is in range
   If (n >= 1 And n <= 10) AndAlso isprime(n) Then
      Print "n is prime"
   Else
      Print "n is not prime, or out of range"
   End If

Differences from QB
   * This operator was not available in QB.

See also
   * OrElse
   * And
   * Operator Truth Tables



----------------------------------------------------------- KeyPgAndGfx ----
And

Parameter to the Put graphics statement which uses a bit-wise And as the 
blitting method

Syntax
   Put [ target, ] [ STEP ] ( x,y ), source [ ,( x1,y1 )-( x2,y2 ) ], And

Parameters
   And
      Required.

Description
   The And method combines each source pixel with the corresponding 
   destination pixel, using the bit-wise And function.  The result of this 
   is output as the destination pixel.
   This method works in all graphics modes.  There is no mask color, 
   although color values with all bits set (255 for 8-bit palette modes, or 
   RGBA(255, 255, 255, 255) in full-color modes) will have no effect, 
   because of the behavior of And.

   In full-color modes, each component (red, green, blue and alpha) is kept 
   in a discrete set of bits, so the operation can be made to only affect 
   some of the channels, by making sure the all the values of the other 
   channels are set to 255.

Example
   ''open a graphics window
   ScreenRes 320, 200, 16
   Line (0, 0)-(319, 199), RGB(255, 255, 255), bf

   ''create 3 sprites containing cyan, magenta and yellow circles
   Const As Integer r = 32
   Dim As Any Ptr cc, cm, cy
   cc = ImageCreate(r * 2 + 1, r * 2 + 1, RGBA(255, 255, 255, 255))
   cm = ImageCreate(r * 2 + 1, r * 2 + 1, RGBA(255, 255, 255, 255))
   cy = ImageCreate(r * 2 + 1, r * 2 + 1, RGBA(255, 255, 255, 255))
   Circle cc, (r, r), r, RGB(0, 255, 255), , , 1, f
   Circle cm, (r, r), r, RGB(255, 0, 255), , , 1, f
   Circle cy, (r, r), r, RGB(255, 255, 0), , , 1, f

   ''put the three sprites, overlapping each other in the middle
   Put (146 - r, 108 - r), cc, And
   Put (174 - r, 108 - r), cm, And
   Put (160 - r,  84 - r), cy, And

   ''free the memory used by the sprites
   ImageDestroy cc
   ImageDestroy cm
   ImageDestroy cy

   ''pause the program before closing
   Sleep

Differences from QB
   * None

See also
   * And
   * Put (Graphics)



-------------------------------------------------------------- KeyPgAny ----
Any

The Any keyword is used as a placeholder for a type or value in various 
ways.

Syntax
   Dim identifier As Any Pointer|Ptr
or
   Declare Sub|Function identifier ( ByRef identifier As Any [ , ... ] )
or
   Dim identifier(Any [, Any...]) As DataType
or
   [ Declare ] { Sub | Function } proc_name ( param(Any [, Any...]) As 
   DataType  )
or
   Dim identifier As DataType = Any
or
   New DataType ( Any )
or
   New(Address) DataType [count] { Any }
or
   InStr|InStrRev ( string, Any substring )

Description
   * Pointers:
      A special pointer type called the Any Ptr (or "Any Pointer") allows 
      pointing to any variable type.  If you cast it to a DataType Ptr, it 
      can be indexed or dereferenced to access the memory as an instance of 
      DataType. Pointer arithmetic is allowed on an Any Ptr, and treats it 
      like a Byte Ptr: The pointer is changed by increments of 1.

      A pure Any Ptr has no type checking by the compiler.  It can be 
      implicitly converted to and from other pointer types through 
      assignment or parameter passing.

      Any on its own is not a valid data type for a variable. Also, it is 
      illegal to dereference an Any Ptr (although an Any Ptr Ptr may be 
      dereferenced to produce a Any Ptr).

      This should not be confused with Variant, a Visual Basic data type 
      which can contain any type of variable. FreeBASIC does not provide 
      native support for a Variant type.

   * Byref parameters:
      Any can be used in procedure prototypes (in a Declare statement) with 
      ByRef parameters to disable the compiler checking for the correct 
      type of the variable passed (this includes the array parameters 
      because always implicitly passed by reference).
      However, it does not work with UDT member procedures, except if they 
      are static procedures.
      This use of Any is deprecated and it only exists for compatibility 
      with QB.

   * Array dimensions:
      In array declarations, Any can be specified in place of the array 
      bounds in order to create a dynamic array with a certain amount of 
      dimensions that is determined based on the number of Anys specified 
      (use the syntax with Any is mandatory when declaring a dynamic array 
      member inside a Type).

      In parameter declarations, Any can be also specified instead of empty 
      parenthesis in order to fix the amount of dimensions.

   * Initialization:
      Any can be used as a fake initializer to disable the default 
      initialization of variables to 0, leaving the variable uninitialized. 
      This may save time in critical sections of a program. It is the 
      program's responsibility to fill the variables with meaningful data 
      before reading it.

      Comparison to C/C++: This matches the behavior of a variable 
      declaration without initialization value in C/C++.

      Similar to Any initializers for variables, Any can also be used with 
      the New Expression or Placement New operators in order to leave the 
      newly created object uninitialized (only allowed with data types that 
      do not have constructors).

   * Instr/InstrRev:
      Any can be used with InStr or InStrRev as a qualifier for the 
      substring parameter, to indicate that any individual character in it 
      may be matched.

Example
   Declare Sub echo(ByVal x As Any Ptr) '' echo will accept any pointer type

   Dim As Integer a(0 To 9) = Any '' this variable is not initialized
   Dim As Double  d(0 To 4)

   Dim p As Any Ptr

   Dim pa As Integer Ptr = @a(0)
   Print "Not initialized ";
   echo pa       '' pass to echo a pointer to integer

   Dim pd As Double Ptr = @d(0)
   Print "Initialized ";
   echo pd       '' pass to echo a pointer to double

   p = pa     '' assign to p a pointer to integer
   p = pd     '' assign to p a pointer to double      

   Sleep

   Sub echo (ByVal x As Any Ptr)
      Dim As Integer i
      For i = 0 To 39
         'echo interprets the data in the pointer as bytes
         Print Cast(UByte Ptr, x)[i] & " ";
      Next
      Print
   End Sub

   'Example of ANY disabling the variable type checking
   Declare Sub echo (ByRef a As Any) '' ANY disables the checking for the type of data passed to the function

   Dim x As Single
   x = -15
   echo x                  '' Passing a single to a function that expects an integer. The compiler does not complain!!             
   Sleep

   Sub echo (ByRef a As Integer)
     Print Hex(a)         
   End Sub

   Dim a(Any) As Integer ' 1-dimensional dynamic array
   Dim b(Any, Any) As Integer ' 2-dimensional dynamic array
   Dim c(Any, Any, Any) As Integer ' 3-dimensional dynamic array
   ' etc.

   ' Further Redims or array accesses must have a matching amount of dimensions
   ReDim a(0 To 1)
   ReDim b(1 To 10, 2 To 5)
   ReDim c(0 To 9, 0 To 5, 0 To 1)

Dialect Differences
   * Not available in the -lang qb dialect.

Differences from QB
   * Pointers and initializers are new to FreeBASIC.

See also
   * Dim
   * Declare



----------------------------------------------------------- KeyPgAppend ----
Append

Specifies text file to be opened for append mode

Syntax
   Open filename for Append [Encoding encoding_type] [Lock lock_type] as 
   [#]filenum 

Parameters
   filename
      file name to open for append
   encoding_type
      indicates encoding type for the file
   lock_type
      locking to be used while the file is open
   filenum
      unused file number to associate with the open file

Description
   A file mode used with Open to open a text file for writing.

   This mode is used to add text to an existing file  with Print #, or 
   comma separated values with Write#.

   Text files can't be simultaneously read and written in FreeBASIC, so if 
   both functions are required on the same file, it must be opened twice.

   filename must be a string expression resulting in a legal file name in 
   the target OS, without wildcards. The file will be sought for in the 
   present directory, unless the filename contains a path . If the file 
   does not exist, it is created. The pointer is set after the last 
   character of the file.

   Encoding_type indicates the Unicode Encoding of the file, so characters 
   are correctly read. If omitted, "ascii" encoding is defaulted. Only 
   little endian character encodings are supported at the moment. 
      *"utf8"
      *"utf16"
      *"utf32"
      *"ascii" (the default)

   Lock_type indicates the way the file is locked  for other processes, it 
   is one of:
      * Read - the file can be opened simultaneously by other processes, 
        but not for reading
      * Write - the file can be opened simultaneously by other processes, 
        but not for writing
      * Read Write - the file cannot be opened simultaneously by other 
        processes (the default)

   filenum Is a valid FreeBASIC file number (in the range 1..255) not being 
   used for any other file presently open. The file number identifies the 
   file for the rest of file operations. A free file number can be found 
   using the FreeFile function.

Example
   Dim i As Integer
   For i = 1 To 10
      Open "test.txt" For Append As #1
      Print #1, "extending test.txt"
      Close #1
   Next

Differences from QB
   * None

See also
   * Input (File Mode)
   * Open
   * Output
   * Print #
   * ? #
   * Write #



--------------------------------------------------------- KeyPgArrayLen ----
Arraylen

Provides the length of an array given its array-name.

Syntax
   Declare Function ArrayLen ( arrayname() As Const Any ) As UInteger

Usage
   #include once "fbc-int/array.bi"
   using FB
   ...
   result = ArrayLen(arrayname())

Parameters
   arrayname
      The name of the array for which the length is returned.

Description
   Returns the total number of elements of the array specified by 
   arrayname() (taking into account all dimensions of array).

Example
   #include Once "fbc-int/array.bi"
   Using FB

   Dim As LongInt array(4, 5)
   Dim As UInteger array_length

   array_length = ArrayLen(array())
   Print array_length                '' 30

Version
   * Since fbc 1.09.0. 

Differences from QB
   * New to FreeBASIC.

See also
   * Arraysize
   * Fbarray (Array Descriptor Structure And Access)



-------------------------------------------------------- KeyPgArraySize ----
Arraysize

Provides the size of an array given its array-name.

Syntax
   Declare Function ArraySize ( arrayname() As Const Any ) As UInteger

Usage
   #include once "fbc-int/array.bi"
   using FB
   ...
   result = ArraySize(arrayname())

Parameters
   arrayname
      The name of the array for which the size is returned.

Description
   Returns the total size (in bytes) of the array specified by arrayname() 
   (size of array element multiplied by total number of array elements).

Example
   #include Once "fbc-int/array.bi"
   Using FB

   Dim As LongInt array(4, 5)
   Dim As UInteger array_size

   array_size = ArraySize(array())
   Print array_size                 '' 240

Version
   * Since fbc 1.09.0. 

Differences from QB
   * New to FreeBASIC.

See also
   * Arraylen
   * Fbarray (Array Descriptor Structure And Access)



--------------------------------------------------------------- KeyPgAs ----
As

Part of a declaration which specifies a data type, or part of the Open 
statement which specifies a file handle.

Syntax
   symbolname As datatype

   Open ... As #filenumber
   Type ... As datatype

Description
   As is used to declare the type of variables, fields or arguments and is 
   also used in the Open statement to determine the file handle. As is also 
   used with the Type (Alias) syntax, similar to C's typedef statement.

Example
   '' don't try to compile this code, the examples are unrelated
   Declare Sub mySub (X As Integer, Y As Single, Z As String)
   ' ...

   Dim X As Integer
   ' ...

   Type myType
     X As Integer
     Y As Single
     Z As String
   End Type
   ' ...

   Type TheNewType As myType
   ' ...

   Open "test" For Input As #1
   ' ...

Differences from QB
   * The Type (Alias) syntax was not supported in QB.

See also
   * Declare
   * Dim
   * Type
   * Open



-------------------------------------------------------------- KeyPgAsc ----
Asc

Returns the corresponding ASCII or Unicode integer representation of a 
character

Syntax
   Declare Function Asc ( ByRef str As Const String, ByVal position As 
   Integer = 1 ) As ULong
   Declare Function Asc ( ByVal str As Const ZString Ptr, ByVal position As 
   Integer = 1 ) As ULong
   Declare Function Asc ( ByVal str As Const WString Ptr, ByVal position As 
   Integer = 1 ) As ULong

Usage
   result = Asc( str [, position ] )

Parameters
   str
      The source string.
   position
      The position in the string of a character.

Return Value
   The raw character value stored at position in str.
   If both str and position can be evaluated at compile time (like Asc("a") 
   or Asc(chr(97)) or Asc("abc", 2) ...), the value is returned in a 
   UInteger result, otherwise in a ULong result.

Description
   If str is a String or a ZString, the UByte value at that position is 
   returned. This will be a 7-bit ASCII code, or even a 8-bit character 
   value from some code-page, depending on the string data stored in str.

   If str is a WString, the UShort (Windows) or ULong (Linux) value at that 
   position is returned. This will be a 16bit value on Windows (WStrings 
   use UTF16 there), or a 32bit value on Linux (WStrings use UTF32 there).

   The function returns zero (0) if the string is a zero length string, 
   position is less than one (1), or position is greater than the number of 
   characters in str.

   Chr performs the opposite function for ASCII strings, while WChr is the 
   opposite for Unicode strings, returning a string containing the 
   character represented by the code passed as an argument.

Example
   Print "the ascii code of 'a' is:"; Asc("a")
   Print "the ascii code of 'b' is:"; Asc("abc", 2)

   will produce the output:

   the ascii code of 'a' is: 97
   the ascii code of 'b' is: 98

Unicode example (Note to documentation editors: don't put inside %%(qbasic) 
markers or the Russian text will disappear!)

dim a as wstring * 12
a = "&#1055;&#1088;&#1080;&#1074;&#1077;&#1090;, &#1084;&#1080;&#1088;"
print "the Unicode of the second char of " & a & " is: " & asc(a, 2)
	will produce the output:
the Unicode of the second char of 
&#1055;&#1088;&#1080;&#1074;&#1077;&#1090;, &#1084;&#1080;&#1088; is: 1088

Platform Differences
   * DOS does not support the wide-character string version of Asc.

Differences from QB
   * The optional position argument is new to FreeBASIC.
   * QB does not support the wide-character string version of Asc

See also
   * ASCII Character Codes
   * Chr
   * Str
   * Val



------------------------------------------------------------- KeyPgAsin ----
Asin

Finds the arcsine of a number

Syntax
   Declare Function Asin ( ByVal number As Double ) As Double

Usage
   result = Asin( number )

Parameters
   number
      Sine value in the range [-1..1].

Return Value
   The arcsine of number, in radians, in the range [-Pi/2..Pi/2].

Description
   Asin returns the arcsine of the argument number as a Double within the 
   range of -Pi/2 to Pi/2.  The arcsine is the inverse of the Sin function. 
   The returned angle is measured in radians (not degrees).

   Asin can be overloaded as operator to accept user-defined types.

Example
   Dim h As Double
   Dim o As Double
   Input "Please enter the length of the hypotenuse of a triangle: ", h
   Input "Please enter the length of the opposite side of the triangle: ", o
   Print ""
   Print "The angle between the sides is"; Asin ( o / h )
   Sleep

The output would look like:

   Please enter the length of the hypotenuse of a triangle: 5
   Please enter the length of the opposite side of the triangle: 3
   The angle between the sides Is 0.6435011087932844

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Asin.

Differences from QB
   * New to FreeBASIC

See also
   * Sin
   * A Brief Introduction To Trigonometry



-------------------------------------------------------------- KeyPgAsm ----
Asm

Code block that allows the use of architecture-specific instructions.

Syntax
   Asm
      architecture-dependent instructions
   End Asm

      Or

   Asm architecture-dependent instructions

Description
   The Asm block is used to insert specific machine-code instructions in a 
   program in order to perform operations that cannot be carried out using 
   the features of the language or to hand-optimize performance-sensitive 
   sections of code.

   The current FreeBASIC compiler currently only produces code for Intel 
   80x86-based machines; however, in the future, the compiler might be 
   ported to a platform which does not support the same instruction set.  
   Therefore, Asm blocks should only be used when necessary, and a 
   FreeBASIC-only alternative should be provided if possible.

   The return value of a function may be set by using the Function keyword 
   within brackets as shown in the example below.

   Asm block comments have the same syntax as usual FreeBASIC Comments  - 
   use FreeBASIC-like " ' " comments, not " ; " as usual in assembly code. 

   x86 Specific:

      Syntax
         The syntax of the inline assembler is a simplified form of Intel 
         syntax.  Intel syntax is used by the majority of x86 assemblers, 
         such as MASM, TASM, NASM, YASM and FASM. In general, the 
         destination of an instruction is placed first, followed by the 
         source. Variables and functions defined by a program may be 
         referenced in an Asm block.  The assembler used by FreeBASIC is 
         GAS, using the .intel_syntax noprefix directive, and Asm blocks 
         are passed through unmodified, except for the substitution of 
         local variable names for stack frame references, and commenting 
         removal.

         Instruction syntax is mostly the same as FASM uses, one important 
         difference is that GAS requires size settings to be followed by 
         the word "ptr".

   ' Assuming "n" is a FB global or local ULONG variable
   mov  eax, [n]        ' OK: size is apparent from eax
   inc  [n]             ' Not OK: size is not given
   inc  dword [n]       ' Not OK: size given, but still not accepted by GAS
   inc  dword Ptr [n]   ' OK: "ptr" is needed by GAS here

      Register Preservation
         When an Asm block is opened, the registers ebx, esi, and edi are 
         pushed to the stack, when the block is closed, these registers are 
         popped back from the stack.  This is because these registers are 
         required to be preserved by most or all OS's using the x86 CPU.  
         You can therefore use these registers without explicitly 
         preserving them yourself. You should not change esp and ebp, since 
         they are usually used to address local variables. 
         Note: Inside a Naked procedure, there is no such register 
         preservation.

      Register Names
         The names of the registers for the x86 architecture are written as 
         follows in an Asm block:
         * 4-byte integer registers: eax, ebx, ecx, edx, ebp, esp, edi, 
           esi
         * 2-byte integer registers: ax, bx, cx, dx, bp, sp, di, si (low 
           words of 4-byte e- registers)
         * 1-byte integer registers: al, ah, bl, bh, cl, ch, dl, dh (low 
           and high bytes of 2-byte -x registers)
         * Floating-point registers: st(0), st(1), st(2), st(3), st(4), 
           st(5), st(6), st(7)
         * MMX registers (aliased onto floating-point registers): mm0, mm1
           , mm2, mm3, mm4, mm5, mm6, mm7
         * SSE registers: xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7

      Instruction Set
         See these external references:
         * Original Intel 80386 manual from 1986
         * Latest Intel Pentium 4 manuals
         * NASM x86 Instruction Reference (Please note that NASM is not 
           the assembler used by FreeBASIC, but this page provides a good 
           overview of x86 instructions)

      Unsafe instructions
         Note that the FreeBASIC compiler produces 32-bit protected-mode 
         code for the x86 which usually runs in an unprivileged user level; 
         therefore, privileged and sensitive instructions will assemble 
         fine, but possibly won't work correctly or cause a runtime 
         "General Protection Fault", "Illegal instruction", or SIGILL 
         error. The following are the privileged and sensitive instructions 
         as of the Intel Pentium 4 and Xeon:
         * cli *1
         * clts
         * hlt
         * in *1
         * ins *1
         * int *1               
         * into *1               
         * invd
         * invlpg
         * lgdt
         * lidt
         * lldt
         * lmsw
         * ltr
         * mov to/from CRn, DRn, TRn
         * out *1
         * outs *1
         * rdmsr
         * rdpmc *2
         * rdtsc *2
         * sti *1
         * str
         * wbinvd
         * wrmsr
         * all SSE2 and higher instructions *2

          *1: sensitive to IOPL, fine in DOS 
          *2: sensitive to permission bits in CR4, see below

   The privileged instructions will work "correctly" in DOS when running on 
   a Ring 0 DPMI kernel, like the (non-default) Ring 0 version of CWSDPMI, 
   WDOSX or D3X, nevertheless most of them are not really useful and 
   dangerous when executed from DPMI code. RDTSC (Read Time Stamp Counter) 
   has been shown to be allowed by most, or all OS'es.

   However the usefulness of RDTSC has been diminished with the advent of 
   multi-core and hibernating CPUs. SSE2 and higher instructions are 
   disabled "by default" after CPU initialization, Windows and Linux 
   usually do enable them, in DOS it is business of the DPMI host: HDPMI32 
   will enable them, CWSDPMI won't. The INT instruction is usable in the 
   DOS version/target only, note that it works slightly differently from 
   real mode DOS, see also FaqDOS.

   The segment registers (cs, ds, es, fs, gs) should not be changed from an 
   Asm block, except in certain cases with the DOS port (note that they do 
   NOT work the same way as in real-mode DOS, see also FaqDOS). The 
   operating system or DPMI host is responsible for memory management; the 
   meaning of segments (selectors) in protected mode is very different from 
   real-mode memory addressing.

   Note that those "unsafe" instructions are not guaranteed to raise a 
   "visible" crash even when ran with insufficient privilege - the OS or 
   DPMI host can decide to "emulate" them, either functionally (reading 
   from some CRx works under HDPMI32), or "dummy" (nothing happens, 
   instruction will pass silently, like a NOP).

Example
   '' This is an example for the x86 architecture.
   Function AddFive(ByVal num As Long) As Long
      Asm
         mov eax, [num]
         Add eax, 5
         mov [Function], eax
      End Asm
   End Function

   Dim i As Long = 4

   Print "4 + 5 ="; AddFive(i)

   4 + 5 = 9

   FreeBASIC's Assembler is AS / GAS, the assembler of GCC, so an external 
   program. Some quirks apply:
      * The error lines  returned by FBC for Asm blocks are not related 
        the FB source file. As FBC simply displays the errors returned by 
        AS , the lines are related to the assembly file. To make FreeBASIC 
        preserve them, the compiler must be invoked with the -R option 
        ("don't delete ASM files").
      * The label names are case sensitive inside Asm blocks.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Asm.

Differences from QB
   * New to FreeBASIC

See also
   * Function
   * Naked



----------------------------------------------------------- KeyPgAssert ----
Assert

Debugging macro that halts program execution if an expression is evaluated 
to 0 (false).

Syntax
   #define Assert(expression) If (expression) = 0 Then : fb_Assert( __FILE__
   , __LINE__, __FUNCTION__, #expression ) : End If

Usage
   Assert( expression )

Parameters
   expression
      Any valid conditional/numeric expression.  If expression evaluates to 
      0 (i.e. "false"), execution is halted.

Description
   The Assert macro is intended for use in debugging and works only if the 
   -g or -eassert option is specified on the fbc command line. In this case 
   it prints an error message and stops the program execution if expression 
   evaluates to 0.

   Its normal use is to check the correct value of the variables or 
   expressions during debugging.

   If -g and -eassert are not passed to fbc, the macro does not generate 
   any code, and has no effect.

   Note: If an Assert fails while the program is in a graphics Screen, the 
   error message will not be visible as it will be printed to the graphics 
   screen, which will be closed immediately after.

Example
   Sub foo
    Dim a As Integer
    a=0
    Assert(a=1)
   End Sub

   foo 

   '' If -g or -eassert is used, this code stops with: test.bas(3): assertion failed at FOO: a=1 

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __ASSERT.

Differences from QB
   * New to FreeBASIC

See also
   * #assert
   * AssertWarn
   * Compiler Option: -eassert
   * Compiler Option: -g



------------------------------------------------------- KeyPgAssertwarn ----
AssertWarn

Debugging macro that prints a warning if an expression evaluates to 0.

Syntax
   #define AssertWarn(expression) If (expression) = 0 Then : fb_AssertWarn( 
   __FILE__, __LINE__, __FUNCTION__, #expression ) : End If

Usage
   AssertWarn( expression )

Parameters
   expression
      Any valid expression.  If expression evaluates to 0, a warning 
      message is printed to stderr (console).

Description
   The AssertWarn macro is intended for use in debugging and works only if 
   the -g option is selected in the FBC command line. In this case it 
   prints a warning message if expression evaluates to 0. It doesn't stop 
   the program execution like Assert does.

   Its normal use is to check the correct value of the variables during 
   debugging.

   If -g is not passed to fbc, the macro does not generate any code.

Example
   Sub foo
     Dim a As Integer
     a=0
     AssertWarn(a=1)
   End Sub

   foo 

   '' If -g is used this code prints: test.bas(3): assertion failed at FOO: a=1 

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __ASSERTWARN.

Differences from QB
   * New to FreeBASIC

See also
   * Assert



------------------------------------------------------------ KeyPgAtan2 ----
Atan2

Returns the arctangent of a ratio

Syntax
   Declare Function ATan2 ( ByVal y As Double, ByVal x As Double ) As Double

Usage
   result = ATan2( y, x )

Parameters
   y
      Vertical component of the ratio.
   x
      Horizontal component of the ratio.

Return Value
   The angle whose tangent is y/x, in radians, in the range [-Pi..Pi].

Description
   ATan2 returns the arctangent of the ratio y/x as a Double within the 
   range of -Pi to Pi.  The arctangent is the inverse of the Tan function. 
   The returned angle is measured in radians (not degrees).

   ATan2 cannot be overloaded as operator to accept user-defined types.

Example
   Print Atan2 ( 4, 5 )     'this is the same as PRINT ATN ( 4 / 5 )

The output would be:

   0.6747409422235527

Differences from QB
   * New to FreeBASIC

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Atan2.

See also
   * Tan
   * Atn
   * A Brief Introduction To Trigonometry



-------------------------------------------------------------- KeyPgAtn ----
Atn

Returns the arctangent of a number

Syntax
   Declare Function Atn ( ByVal number As Double ) As Double

Usage
   result = Atn( number )

Parameters
   number
      A number.

Return Value
   The angle, in radians, whose tangent is number, in the range 
   [-Pi/2..Pi/2].

Description
   Atn returns the arctangent of the argument number as a Double within the 
   range of -Pi/2 to Pi/2.  The arctangent is the inverse of the Tan 
   function. The returned angle is measured in radians (not degrees).

   Atn can be overloaded as operator to accept user-defined types.

Example
   Print "Pi ="; Atn ( 1.0 ) * 4
   Print Atn ( 4 / 5 )

The output would be:

   Pi = 3.141592653589793
   0.6747409422235527

Differences from QB
   * None

See also
   * Tan
   * Atan2
   * A Brief Introduction To Trigonometry




============================================================================
    B

--------------------------------------------------------- KeyPgBaseInit ----
Base (Initializer)

Specifies an initializer for the base UDT in derived Udt constructors

Syntax
   Base ( constructor-parameters... )
or:
   Base ( UDT-initializers... )

Description
   The Base initializer can be used at the top of constructors of derived 
   UDTs. It allows to specify an explicit constructor call or UDT 
   initializers to be used to initialize the base object. It will replace 
   the implicit default initialization, and must appear above any other 
   statements in the constructor it is used in.

   Note: Unlike "Base( )", a "Base.Constructor( )" statement does not 
   replace the implicit default initialization done by the constructor of a 
   derived UDT, and can usually not be used legally, because it would 
   result in two constructor calls for the base object (for an inheritance 
   structure extending the built-in Object type, this second base 
   constructor call may also corrupt the vtable pointer to point to the 
   base-type vtable instead of to the type vtable).

Example
   Type SimpleParent
      As Integer a, b, c
   End Type

   Type Child Extends SimpleParent
      Declare Constructor( )
   End Type

   Constructor Child( )
      '' Simple UDT initializer
      Base( 1, 2, 3 )
   End Constructor

   Type ComplexParent
      As Integer i
      Declare Constructor( ByVal As Integer = 0 )
   End Type

   Constructor ComplexParent( ByVal i As Integer = 0 )
      this.i = i
   End Constructor

   Type Child Extends ComplexParent
      Declare Constructor( )
      Declare Constructor( ByRef As Child )
   End Type

   Constructor Child( )
      '' Base UDT constructor call
      Base( 1 )
   End Constructor

   Constructor Child( ByRef rhs As Child )
      '' Base UDT constructor call
      Base( rhs.i )
   End Constructor

Dialect Differences
   * Methods are only supported in the -lang fb dialect, hence Base has no 
     function in other dialects.

Differences from QB
   * New to FreeBASIC

See also
   * Base (Member Access)
   * This
   * Type
   * Extends
   * Extends Zstring
   * Extends Wstring
   * Option Base



------------------------------------------------------------- KeyPgBase ----
Base (Member Access)

Provides explicit access to base type members in non-static methods of a 
Type

Syntax
   Base.member
   Base [ .Base ... ] .member

Description
   Base provides a way to explicitly access members of a specific base 
   type, in the context of non-static methods of a user-defined type 
   derived from another type using Extends.

   By using Base repeatedly, as in base.base.base.member, it is possible to 
   access any desired base type, in case there are multiple levels of 
   inheritance.

   Base is especially useful when a base type's member is shadowed by a 
   local variable or member of a derived type using the same identifier. 
   Base then allows unambiguous access to the base type.

   For virtual methods, base.method() always calls the base method and 
   never the overriding method.

   Note: There is no specific syntax with Base to access a member operator 
   of a specific base type. The only way is to apply the operator on the 
   instance beforehand up-casted to the right type (but for virtual 
   operators, this workaround does not allow to call the base operator when 
   overridden, because that does not modify the run-time type of the 
   instance but only its compile-time type).

Example
   Type Parent
      As Integer a
      Declare Constructor(ByVal As Integer = 0)
      Declare Sub show()
   End Type

   Constructor Parent(ByVal a As Integer = 0)
      This.a = a
   End Constructor

   Sub Parent.show()
      Print "parent", a
   End Sub

   Type Child Extends Parent
      As Integer a
      Declare Constructor(ByVal As Integer = 0)
      Declare Sub show()
   End Type

   Constructor Child(ByVal a As Integer = 0)
      '' Call base type's constructor
      Base(a * 3)
      This.a = a
   End Constructor

   Sub Child.show()
      '' Call base type's show() method, not ours
      Base.show()
      
      '' Show both a fields, the base type's and ours'
      Print "child", Base.a, a
   End Sub

   Type GrandChild Extends Child
      As Integer a
      Declare Constructor(ByVal As Integer = 0)
      Declare Sub show()
   End Type

   Constructor GrandChild(ByVal a As Integer = 0)
      '' Call base type's constructor
      Base(a * 2)
      This.a = a
   End Constructor

   Sub GrandChild.show()
      '' Call base type's show() method, not ours
      Base.show()
      
      '' Show both a fields, the base.base type's, the base type's and ours'
      Print "grandchild", Base.Base.a, Base.a, a
   End Sub

   Dim As GrandChild x = GrandChild(3)
   x.show()

Dialect Differences
   * Methods are only supported in the -lang fb dialect, hence Base has no 
     function in other dialects.

Differences from QB
   * New to FreeBASIC

See also
   * Base (Initializer)
   * This
   * Type
   * Extends
   * Extends Zstring
   * Extends Wstring
   * Option Base



------------------------------------------------------------- KeyPgBeep ----
Beep

Produces a beep sound.

Syntax
   Declare Sub Beep ( )

Usage
   Beep

Description
   Beep tells the system to sound a beep noise. Note that this might not 
   work on some platforms. Since this command is not reliable and there is 
   no way to specify the frequency and duration, you might want to avoid it 
   in favor of other / better solutions, for example: 
   http://www.freebasic.net/forum/viewtopic.php?p=20441#20441 by yetifoot.

Example
   Beep

Differences from QB
   *  In QB, this was a single tone noise generated through the PC 
     speaker. Now this might not be the case.

See also
   * Out - producing sound using CPU ports



-------------------------------------------------------------- KeyPgBin ----
Bin

Returns a binary (base 2) string representation of an integer

Syntax
   Declare Function Bin ( ByVal number As UByte ) As String
   Declare Function Bin ( ByVal number As UShort ) As String
   Declare Function Bin ( ByVal number As ULong ) As String
   Declare Function Bin ( ByVal number As ULongInt ) As String
   Declare Function Bin ( ByVal number As Const Any Ptr ) As String

   Declare Function Bin ( ByVal number As UByte, ByVal digits As Long ) As 
   String
   Declare Function Bin ( ByVal number As UShort, ByVal digits As Long ) As 
   String
   Declare Function Bin ( ByVal number As ULong, ByVal digits As Long ) As 
   String
   Declare Function Bin ( ByVal number As ULongInt, ByVal digits As Long ) 
   As String
   Declare Function Bin ( ByVal number As Const Any Ptr, ByVal digits As 
   Long ) As String

Usage
   result = Bin[$]( number [, digits ] )

Parameters
   number
      A number or expression evaluating to a number.  A floating-point 
      number will be converted to a LongInt.
   digits
      Desired number of digits in the returned string.

Return Value
   A string containing the unsigned binary representation of number.

Description
   Returns a string representing the unsigned binary value of the integer 
   number. Binary digits range from 0 to 1.

   If you specify digits > 0, the result string will be exactly that 
   length.  It will be truncated or padded with zeros on the left, if 
   necessary.

   The length of the string will not go longer than the maximum number of 
   digits required for the type of number (32 for a Long, 64 for a LongInt)
   .

   If you want to do the opposite, i.e. convert an binary string back into 
   a number, the easiest way to do it is to prepend the string with "&B", 
   and convert it to an integer type, using a function like CInt, similarly 
   to a normal numeric string.  E.g. CInt("&B101")

Example
   Print Bin(54321)
   Print Bin(54321, 5)
   Print Bin(54321, 20)

   will produce the output:

   1101010000110001
   10001
   00001101010000110001

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Bin.
   * The string type suffix "$" is ignored in the -lang fblite dialect, 
     always warn.
   * The string type suffix "$" is ignored in the -lang fb dialect, always 
     warn.

Differences from QB
   * New to FreeBASIC

See also
   * Oct
   * Hex
   * ValInt
   * ValLng



----------------------------------------------------------- KeyPgBinary ----
Binary

Specifies file or device to be opened for binary mode

Syntax
   Open filename for Binary [Access access_type] [Lock lock_type] as [#]
   filenum 

Parameters
   filename
      file name to open
   access_type
      indicates whether the file may be read from, written to or both
   lock_type
      locking to be used while the file is open
   filenum
      unused file number to associate with the open file

Description
   Opens a file or device for reading and/or writing binary data in the 
   file filenum, with free format.
   If the file does not exist, a new file will be created. The file pointer 
   is initialized by Open at byte no. 1. 
   Get # and Put # file operations move the file pointer according to the 
   size of the data, the pointer can be set to any byte in the file.
   The data existing in the file is preserved by Open. 
   This file mode can use any buffer variable to read/write data in the 
   file.   
   The data is saved in binary mode, in the same internal format FreeBASIC 
   uses, by means of Get # and Put #.

   filename must be a string expression resulting in a legal file name in 
   the target OS, without wildcards. The file will be sought for in the 
   present directory, unless a path is given.

   Access_type By default Binary mode allows to both read and write the 
   file, unless an Access type is specified, it must be one of: 
      * Read - the file is opened for input only
      * Write - the file is opened for output only
      * Read Write - the file is opened for input and output (the default)

   Lock_type indicates the way the file is locked  for other processes 
   (users or threads), it is one of:
      * Shared - The file can be freely accessed by other processes     
      * Lock Read - The file can't be opened simultaneously for reading
      * Lock Write - The file can't be opened simultaneously for writing
      * Lock Read Write - The file cannot be opened simultaneously by 
        other processes.
      If no lock type is stated, the file will be Shared for other threads 
      of the program and Lock Read Write for other programs.
      Lock and Unlock can be used to restrict temporally access to parts of 
      a file.

   filenum is a valid file number (in the range 1..255) not being used for 
   any other file presently open. The file number identifies the file for 
   the rest of file operations. A free file number can be found using the 
   FreeFile function.

Example
   '' Create a binary data file with one number in it
   Dim x As Single = 17.164

   Open "MyFile.Dat" For Binary As #1
     '' put without a position setting will put from the last known file position
     '' in this case, the very beginning of the file.
     Put #1, , x
   Close #1

   '' Now read the number from the file
   Dim x As Single = 0

   Open "MyFile.Dat" For Binary As #1
     Get #1, , x
   Close #1

   Print x

   '' Read entire contents of a file to a string
   Dim txt As String

   Open "myfile.txt" For Binary Access Read As #1
     If LOF(1) > 0 Then
      '' our string has as many characters as the file has in bytes
      txt = String(LOF(1), 0)
      '' size of txt is known.  entire string filled with file data
      Get #1, , txt
     End If
   Close #1

   Print txt

Differences from QB
   * None

See also
   * Open
   * Put #
   * Get #
   * Random
   * Append
   * Output
   * Input



-------------------------------------------------------------- KeyPgBit ----
Bit

Gets the state of an individual bit in an integer value.

Syntax
   #define Bit( value, bit_number ) (((value) And (Cast(TypeOf(value), 1) 
   Shl (bit_number))) <> 0)

Usage
   result = Bit( value, bit_number )

Parameters
   value
      The integer value.
   bit_number
      The index of the bit.

Return Value
   Returns an Integer value of -1 if the bit is set, or 0 if the bit is 
   cleared.

Description
   This macro expands to an integer value indicating whether or not the bit 
   specified by bit_number is set in the integer value. Behaves as `(value 
   And 1 Shl bit_number) <> 0`.

   The valid range of values for bit_number depends on the size, in bits, 
   of `TypeOf(value)`, which is `0` (from the lowest bit) through `SizeOf(
   value) * 8 - 1` (up to the highest bit). See Standard Datatype Limits 
   for a table of the standard datatypes and their sizes.
   For the bit_number values outside the valid range, the results of this 
   macro are undefined.

Example
   Print Bit(&B1000, 3)
   Print Bit(4,2)
   Print Bit(5,1)
   Print Bit(&H8000000000000000ULL,63)

   will produce the output:


   -1
   -1
    0
   -1

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Bit.

Differences from QB
   * New to FreeBASIC

See also
   * BitSet
   * BitReset



--------------------------------------------------------- KeyPgBitreset ----
BitReset

Gets the value with a specified bit cleared, from a copied integer.

Syntax
   #define BitReset( value, bit_number ) ((value) And Not (Cast(TypeOf(
   Value), 1) Shl (bit_number)))

Usage
   result = BitReset( value, bit_number )

Parameters
   value
      The integer value.
   bit_number
      The index of the bit to clear.

Return Value
   Returns the integer value with the specified bit cleared.

Description
   This macro expands to a copy of the integer value with the specified 
   bit_number cleared (to off, or `0`). Behaves as `value And Not (1 Shl 
   bit_number)`.
   To clear a specified bit in a variable, the following assignment can be 
   used: variable = BitReset( variable, bit_number )

   The valid range of values for bit_number depends on the size, in bits, 
   of `TypeOf(value)`, which is `0` (from the lowest bit) through `SizeOf(
   value) * 8 - 1` (up to the highest bit). See Standard Datatype Limits 
   for a table of the standard datatypes and their sizes.
   For the bit_number values outside the valid range, the results of this 
   macro are undefined.

Example
   Print Bin(BitReset(&b10101, 2))
   Print BitReset(5,0)
   Print Hex(BitReset(&h8000000000000001,63))

   will produce the output:

   10001
    4
   1

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Bitreset.

Differences from QB
   * New to FreeBASIC.

See also
   * Bit
   * BitSet



----------------------------------------------------------- KeyPgBitset ----
BitSet

Gets the value with a specified bit set, from a copied integer.

Syntax
   #define BitSet( value, bit_number ) ((value) Or (Cast(TypeOf(Value), 1) 
   Shl (bit_number)))

Usage
   result = BitSet( value, bit_number )

Parameters
   value
      The integer value.
   bit_number
      The index of the bit to set.

Return Value
   Returns the integer value with the specified bit set.

Description
   This macro expands to a copy of the integer value with the specified 
   bit_number set (to on, or `1`). Behaves as `value Or (1 Shl bit_number)
   `.
   To set a specified bit in a variable, the following assignment can be 
   used: variable = BitSet( variable, bit_number )

   The valid range of values for bit_number depends on the size, in bits, 
   of `TypeOf(value)`, which is `0` (from the lowest bit) through `SizeOf(
   value) * 8 - 1` (up to the highest bit). See Standard Datatype Limits 
   for a table of the standard datatypes and their sizes.
   For the bit_number values outside the valid range, the results of this 
   macro are undefined.

Example
   Print Bin(BitSet(&b10001,2))
   Print BitSet(4, 0)
   Print Hex(BitSet(1ull, 63))

   will produce the output:

   10101
    5
   8000000000000001

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Bitset.

Differences from QB
   * New to FreeBASIC.

See also
   * Bit
   * BitReset



------------------------------------------------------------ KeyPgBload ----
BLoad

Loads arbitrary data from a file created with BSave, or a compatible BMP 
image file.

Syntax
   Declare Function BLoad ( ByRef filename As Const String, ByVal dest As 
   Any Ptr = 0, ByVal pal As Any Ptr = 0 ) As Long

Usage
   result = BLoad( filename [, [ dest ] [, pal ] ] )

Parameters
   filename
      the name of the file to load the image from; can include a file path
   dest
      the memory location to load the image to, or null (0) to copy the 
      image to the current graphics screen work page
   pal
      the memory location to load the palette to, or null (0) to change the 
      current graphics screen palette, if it uses one

Return Value
   Returns zero (0) if successful, or a non-zero error code to indicate a 
   failure. (throws a runtime error)

Description
   BLoad can be used to load image data or any other data from a file 
   created with BSave, and store that data in an array or paste it to the 
   screen. If dest is absent or null (0), the image data is pasted to the 
   current graphics screen work page.  Otherwise it is loaded as image data 
   to the address given by dest.
   BLoad must be called only if a graphics mode is initialized, else the 
   program crashes (see BLOAD/BSAVE text mode work-around to work in text 
   mode).

   BLoad can load 3 different types of files:
      * Old QB-like data files, saved with BSAVE from QB code, containing 
        "raw" data preceded by a 7-byte header, beginning with &HFD, up to 
        64 KiB in size
      * New FB-like data files, saved with BSave from FB code, containing 
        "raw" data preceded by a 5-byte header, beginning with &HFE. There 
        is no 64 KiB limit with this format
      * BMP image files, supports a subset of valid ("Windows") .BMP 
        files, beginning with "BM", saved from FB code with BSave, or 
        created / saved in a compatible format using a graphics editor / 
        converter.
   QB-like data files and BMP files are converted to an FB-compatible image 
   format when opened.

   Image files with 8-bit per pixel resolution or lower contain a palette 
   that describes the color values used in the images. If pal is not null (
   0), the palette is copied to memory starting at the address specified. 
   Otherwise, if the current graphics screen uses a palette then its 
   palette is changed to match that of the image file.

   When using one of the 2 "non-BMP" file formats to save images, the image 
   files must have been created with BSave in the same graphics screen mode 
   as it is being loaded into. When using the BMP file format, this 
   restriction doesn't apply. 

   When loading a BMP file using BLoad,  the images must be true-color 
   (15-, 16-, 24- or 32-bits per pixel) or palettized/indexed (8-bit or 
   lower). The image data will be converted to the proper pixel format for 
   the current color depth, except that true-color can't be reduced to a 
   palettized image. BLoad doesn't support BMP files using RLE compression 
   or other image file types (PNG, JPG, GIF, ...).  BLoad will load alpha 
   channel information, if available, from 32-bit BMP files with 
   BITMAPV4HEADER or BITMAPV5HEADER file headers.

   The error code returned by BLoad can be checked using Err in the next 
   line. The function version of  BLoad returns directly the error code as 
   a 32 bit Long.

Runtime errors:
   BLoad throws one of the following runtime errors:
      (1) Illegal function call
         * dest was not specified or was null (0), and no graphics screen 
           was set.
         * The Bitmap uses an unsupported BMP file compression type (
           BI_RLE4, BI_RLE8)
         * The Bitmap is true-color (16, 24, or 32 bits per pixel) and the 
           current graphics screen uses a palette (8 bits per pixel or 
           lower).
      (2) File not found
         * The file filename could not be found.
      (3) File I/O error
         * The file doesn't have any of the supported types 
         * A general read error occurred.

   Note: When you use BLoad to load a BMP file into an image buffer, the 
   original dimensions of the image are not changed.  If you want the image 
   buffer to have the same dimensions as the BMP file, you have to find out 
   the dimensions beforehand, and create an image of the right size 
   yourself.  See the example below for an example of how to do this.

Example
   'Load a graphic to current work page
   Screen 18, 32
   Cls
   BLoad "picture.bmp"
   Sleep

   'Load a 48x48 bitmap into an image
   ScreenRes 320, 200, 32
   Dim myImage As Any Ptr = ImageCreate( 48, 48 )
   BLoad "picture.bmp", myImage
   Put (10,10), myImage
   ImageDestroy( myImage )
   Sleep

   ScreenRes 640, 480, 8 '' 8-bit palette graphics mode
   Dim pal(0 To 256-1) As Integer '' 32-bit integer array with room for 256 colors

   '' load bitmap to screen, put palette into pal() array
   BLoad "picture.bmp", , @pal(0)

   WindowTitle "Old palette"
   Sleep

   '' set new palette from pal() array
   Palette Using pal(0)

   WindowTitle "New palette"
   Sleep

   '' A function that creates an image buffer with the same 
   '' dimensions as a BMP image, and loads a file into it.

   Const NULL As Any Ptr = 0

   Function bmp_load( ByRef filename As Const String ) As Any Ptr

      Dim As Long filenum, bmpwidth, bmpheight
      Dim As Any Ptr img

      '' open BMP file
      filenum = FreeFile()
      If Open( filename For Binary Access Read As #filenum ) <> 0 Then Return NULL

         '' retrieve BMP dimensions
         Get #filenum, 19, bmpwidth
         Get #filenum, 23, bmpheight

      Close #filenum

      '' create image with BMP dimensions
      img = ImageCreate( bmpwidth, Abs(bmpheight) )

      If img = NULL Then Return NULL

      '' load BMP file into image buffer
      If BLoad( filename, img ) <> 0 Then ImageDestroy( img ): Return NULL

      Return img

   End Function

   Dim As Any Ptr img

   ScreenRes 640, 480, 32

   img = bmp_load( "picture.bmp" )

   If img = NULL Then
      Print "bmp_load failed"

   Else

      Put (10, 10), img

      ImageDestroy( img )

   End If

   Sleep

Differences from QB
   * Support for loading BMP files is new to FreeBASIC.
   * Support for retrieving the palette from BMP files is new to FreeBASIC
     .
   * FreeBASIC uses a different file format from QBASIC internally, which 
     doesn't have the 64 KiB limit, and is unsupported by QBASIC.

See also
   * BSave
   * Palette
   * ImageCreate
   * ImageDestroy
   * Internal Graphics Formats



---------------------------------------------------------- KeyPgBoolean ----
Boolean

Standard data type

Syntax
   Dim variable As Boolean

Description
   Boolean data type. Can hold the values True or False
   Default value on initialization is False

   Notes on definition of boolean data type:
      - Ideally, the definition of the boolean data type is that it holds 
      the value of True or False, and that's it. However, to make this 
      concept a reality, we need a definition that uses real world 
      connections.
      - A more realistic definition is that the boolean data type is a 
      1-bit integer, having the value 0 to indicate False and 1 to indicate 
      True.
      - For a practical definition, we must consider, yet again, additional 
      factors. The most significant factor is that the hardware (processor) 
      on which code is executed does not directly support a 1-bit data 
      type; the smallest register or memory size we can work with is 8-bits 
      or 1-byte.
      - Assume "false" is 0 in both C/C++ and FB.  C/C++ has logical 'not' 
      operator '!' such that '!0' produces '1'.  FB has a bitwise Not 
      operator such that 'not 0' produces '-1'.
      - Nevertheless the definition under the hood for a FB boolean remains 
      an unsigned 1-bit integer, zero extended to fill larger integer 
      types.
      - Therefore when assigning a boolean with an integer value (by 
      implicit conversion and not with the False or True value), '0' 
      induces the False state and '1' or '-1' induces the True state (any 
      other value also induces the True state, but with a warning message).
      - Otherwise when assigning a numeric type with a boolean (by implicit 
      conversion), False induces the '0' value and True induces the '-1' 
      value.
      - However, the purpose and intent of the boolean data type remains, 
      that it should only ever hold a True value or False value, regardless 
      of the underlying details.

Example
   Dim boolvar As Boolean
   boolvar = True
   Print "boolvar = ", boolvar

   Output:

   boolvar =     True

Version
   * Since fbc 1.04.0

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Boolean.

Differences from QB
   * New to FreeBASIC

See also
   * CBool
   * True
   * False
   * Table with variable types overview, limits and suffixes



------------------------------------------------------------ KeyPgBsave ----
BSave

Saves an array of arbitrary data and palette information to a file on disk

Syntax
   Declare Function BSave ( ByRef filename As Const String, ByVal source As 
   Any Ptr, ByVal size As ULong = 0, ByVal pal As Any Ptr = 0, ByVal 
   bitsperpixel As Long = 0 ) As Long

Usage
   result = BSave( filename, source [,[ size ][,{ pal | pal, bitsperpixel 
   }]] )

Parameters
   filename
      the name of the file to create for storing the pixel and palette 
      data.
   source
      the address of the data to store, or null (0) to store pixel data 
      from the current screen work page.
   size
      optional, the total number of bytes of data to store.  This value is 
      needed unless the output is a BMP file.
   pal
      optional, the address of a buffer holding 256 Palette colors, or null 
      (0) for the current screen palette.
   bitsperpixel
      optional, a requested bit depth for the output BMP image. If 
      bitsperpixel is specified, pal must also be specified (at a least 
      null (0) value), otherwise an error is obtained.

Return Value
   Returns zero (0) if successful, or a non-zero error code to indicate a 
   failure. (throws a runtime error)

Description
   BSave is used for saving arbitrary data from memory into a file, using a 
   file format specific to FB, or saving images into a standard BMP image 
   file, replacing an existing file if necessary.
   BSave must be called only if a graphics mode is initialized, else the 
   program crashes (see BLOAD/BSAVE text mode work-around to work in text 
   mode).

   BSave outputs a total of size bytes of arbitrary data located at source 
   to a specified file. If source is null (0), then BSave outputs a maximum 
   of size bytes from the current work page's pixel buffer, which is 
   structured in the current screen mode's internal pixel format. (This 
   data is not compatible with the image buffer format as it has no 
   header.)  For 8-bit images, palette information is obtained from pal if 
   present and non-null, or if pal omitted or null (0), from the current 
   screen palette.

   A BMP image file can be created if filename has a file extension of "
   .bmp" (case insensitive). source is assumed to point to a valid image 
   buffer whose entire pixel data will be stored in the BMP file. If source 
   is null (0), the contents of the current work page will be stored 
   instead. For 8-bit images, palette information is obtained from pal if 
   non-null, or if null (0), from the current screen palette. The size 
   parameter is ignored when saving BMP files.

   The default bit depth for BMP files is 8-bit for 8-bit (palette) images, 
   24-bit for 16-bit images, and 32-bit for 32-bit images.  The 
   bitsperpixel parameter can be used to request 24-bit output for 8-bit 
   images, or 24-bit output for 32-bit images.

   The error code returned by BSave can be checked using Err in the next 
   line. The function version of  BSave returns directly the error code as 
   a 32 bit Long.

Runtime errors:
   BSave throws one of the following runtime errors:

   (1) Illegal function call
      * size is less than zero (0), or size is zero and source is 
        non-null, or a problem is detected with the image buffer.
   (2) File not found
      * The file could not be created.
   (3) File I/O error
      * The file could not be written to.

Example
   ' Set gfx mode
   ScreenRes 320, 200, 32

   ' Clear with black on white
   Color RGB(0, 0, 0), RGB(255, 255, 255)
   Cls

   Locate 13, 15: Print "Hello world!"

   ' Save screen as BMP
   BSave "hello.bmp", 0

Save image buffer to bitmap file:
   'set graphics screen 640 x 480 pixels, 32 bit colors
   Const W = 640, H = 480 'width & hight
   ScreenRes W, H, 32
   'draw a smiley at screen center
   Circle (W \ 2, H \ 2), 180, &h00ffff00, , , , f 'yellow circle
   Circle (W \ 2 - 55, H \ 2 - 70), 35, &h00000000, , , 1.5, f 'left eye
   Circle (W \ 2 + 55, H \ 2 - 60), 35, &h00000000, , , 1.5, f 'right eye
   Circle (W \ 2, H \ 2 + 80), 70, &h00000000, , , 0.4, f 'mouth
   'allocate memory for image buffer
   Dim As Any Ptr pImageBuffer = ImageCreate(250, 250)
   'copy screen section to buffer
   Get (W \ 2 - 125, H \ 2 - 125)-Step(250 - 1, 250 - 1), pImageBuffer
   'save image buffer to file
   Dim As String fileName = "Smiley.bmp"
   If BSave(fileName, pImageBuffer) = 0 Then
      Print "Saved succesful: " + fileName
   Else
      Print "Error saving: " + fileName
   End If
   'free memory for image buffer
   ImageDestroy(pImageBuffer)
   'keep graphics screen open until key press
   Sleep

Differences from QB
   * Support for saving more than 64KiB of arbitrary data is new to 
     FreeBASIC.
   * Support for saving BMP files is new to FreeBASIC.
   * QB cannot use BLoad to load files created with BSave in FreeBASIC, 
     but FreeBASIC can use BLoad to load files created with BSave in QB

See also
   * BLoad
   * Palette



------------------------------------------------------------ KeyPgByref ----
Byref (Parameters)

Declaration specifier to explicitly pass a parameter by reference

Syntax
   ByRef param As datatype

Usage
   [ Declare ] { Sub | Function } proc_name ( ByRef param As datatype  )

Description
   Passes a variable by reference, that is its address, to a subroutine or 
   function. When a variable is passed by reference, the contents of the 
   variable can be changed by the target subroutine or function.

   In -lang qb and -lang fblite dialects, ByRef is the default parameter 
   passing convention, unless Option ByVal is in effect.

   Opposite of ByVal.

   Note: A constant or a literal expression can also be passed to such a 
   procedure (which gets by reference), but they are obviously not 
   modifiable from the procedure body. In that case, the compiler passes by 
   reference a temporary variable initialized with the constant or the 
   literal expression.

   Warning: When passing by reference, it is recommended to pass an 
   argument of the same type (or fully compatible, like a derived type for 
   example) as that of the declared parameter. Although in some cases the 
   compiler accepts to pass a different type, often the result is not the 
   one expected.

Example
   Dim MyVar As Integer

   Sub ChangeVar(ByRef AVar As Integer)
      AVar = AVar + 1
   End Sub

   MyVar = 1
   Print "MyVar: "; MyVar 'output = 1
   ChangeVar MyVar
   Print "MyVar: "; MyVar 'output = 2
   Sleep
   End

Dialect Differences
   * In -lang fb dialect, ByVal is the default parameter passing 
     convention for all built-in types except String and user-defined Type 
     which are passed ByRef by default. The ZString and WString built-in 
     types are also passed ByRef by default, but passing ByVal is 
     forbidden. Arrays are always passed ByRef and the use of the specifier 
     ByRef or ByVal is forbidden.
   * In -lang qb and -lang fblite dialects, ByRef is the default parameter 
     passing convention.

Differences from QB
   * New to FreeBASIC

See also
   * Passing Arguments to Procedures
   * Declare
   * ByVal
   * Byref (Function Results)
   * Byref (Variables)



---------------------------------------------------- KeyPgByrefFunction ----
Byref (Function Results)

Specifies that a function result is returned by reference

Syntax
   Function name ( parameter-list ) ByRef As datatype

Description
   Causes the function result to be returned by reference, rather than by 
   value. A function returning ByRef will return the address of a variable, 
   instead of making a copy like when returning by value. This allows the 
   caller of the function to modify the variable which the function result 
   points to.

   If ByRef is not specified, the default is to return the function result 
   by value.

   Functions with ByRef result should not return local variables from the 
   function, because they will be destroyed upon returning from the 
   function, invalidating any pointer or reference to them. To help with 
   writing safe code, the compiler will show an error message when a local 
   variable is used with Function = x (or name = x) assignments and Return 
   x statements.

   Note: On the left-hand side of an assignment expression using the '=' 
   symbol, the result of the function (returned by reference) must be 
   enclosed in parentheses when the function calls one single argument, in 
   order to solve the parsing ambiguity. '=>' can be used for assignments, 
   in place of '=', same as for initializers, allowing to avoid parsing 
   ambiguity (without parentheses). As for the arguments list, it should 
   always be surrounded with parentheses even if empty.

   Operators (member or global), when used as functions, have also the 
   capability to return results by reference, by using the same syntax.

Example
   Function min( ByRef I As Integer , ByRef J As Integer ) ByRef As Integer
      '' The smallest integer will be returned by reference, no copy will be created.
      If I < J Then
         Return I
      Else
         Return J
      End If
   End Function

   Dim As Integer A = 13, B = 7
   Print A, B
   Print min( A , B )
   min( A , B ) = 0
   Print A, B

   Function f( ) ByRef As Const ZString
      '' This string literal (because statically allocated in memory) will be returned by reference, no copy will be created.
      Function = "abcd"
   End Function

   Print f( )

   Dim Shared As String s

   Function f1( ) ByRef As String
      '' This variable-length string will be returned by reference, no copy will be created.
      Function = s
   End Function

   Function f2( ByRef _s As String ) ByRef As String
      '' This variable-length string will transit by reference (input and output), no copy will be created.
      Function = _s
   End Function

   s = "abcd"
   Print s

   f1( ) = f1( ) & "efgh"
   Print s

   '' The enclosing parentheses are required here on the left-hand side.
   ( f2( s ) ) = f2( s ) & "ijkl"
   Print s

   '' The enclosing parentheses are not required here on the left-hand side.
   f2( s ) => f2( s ) & "mnop"
   Print s

   Function power2( ByRef _I As Integer ) ByRef As Integer
      _I *= _I
      '' This integer will be returned by reference, no copy will be created.
      Function = _I
   End Function

   Dim As Integer I = 2
   power2( power2( power2( I ) ) )  '' Function return-byref cascading is equivalent to ((I*I)*(I*I))*((I*I)*(I*I)) = I^8
   Print I

Differences from QB
   * New to FreeBASIC

See also
   * Returning values
   * Byref (Parameters)
   * Byref (Variables)



--------------------------------------------------- KeyPgByrefVariables ----
Byref (Variables)

Declares a reference

Syntax
      (Dim | Static) [Shared] ByRef name1 As DataType = variable1 [, ByRef 
      name2 As DataType = variable2, ...]
   or
      (Dim | Static) [Shared] ByRef As DataType name1 = variable1 [, name2 
      = variable2, ...]
   or
      [Static] Var [Shared] ByRef name1 = variable1 [, ByRef name2 = 
      variable2, ...]

Parameters
   name
      reference name
   variable
      variable name to refer

Description
   Declares a reference (by name) to a variable.

   A reference is an entity that is a way to access data located in memory. 
   A reference is not the data itself but only information about its 
   location. A reference can be thought of as a pointer that is implicitly 
   dereferenced. In many cases, it can be used as an alternative to 
   pointer.

   A reference must always be initialized with a variable when it is 
   created.
   DataType must be the same type as that of the variable, or a compatible 
   type (for example one from the types of its Bases in case of 
   inheritance):
      * Only when the two types are identical (or using the third syntax 
        with Var), a reference can be considered as an alias of the 
        variable. One can do the same operations through such a reference 
        as one can do with the original variable.
      * Otherwise (types compatible but not identical), one cannot do all 
        same operations than with the original variable:
            For example, a base type reference referring to a derived type 
            object allows to activate polymorphism when a virtual method is 
            called on it, similarly to a base type pointer referring to a 
            derived type object. One can do the same operations through 
            such a reference as one can do with a dereferenced pointer of 
            same type (but for both not the same operations as using 
            directly the derived type instance).

   A reference can be reassigned to refer to another variable (of 
   compatible type) by doing:
      @refname = @othervariable

   NOTE: The arrays of references and the non-static reference fields for 
   UDT are not supported yet.

Example
   '' Comparison between:
   ''   - a copy ('ci') of a variable ('i')
   ''   - a reference ('ri') to a variable ('i')

   Dim As Integer i = 12
   Print @i, i

   Dim As Integer ci = i  '' or Var ci = i
   Print @ci, ci

   Dim ByRef As Integer ri = i  '' or Var Byref ri = i
   Print @ri, ri

   Print

   Print i, ci, ri
   i = 34
   Print i, ci, ri
   ci = 56
   Print i, ci, ri
   ri = 78
   Print i, ci, ri

   Sleep
      

   '' Use reference allows to simplify expressions compared to pointer
   '' (avoid to use operator '@' and especially '*')

   Function fp () As ZString Ptr
      Static As ZString * 256 z
      Return @z
   End Function

   Dim As ZString Ptr pz = fp()
   *pz = "FreeBASIC Zstring Ptr"
   Print *pz
   *pz &= " 1.3.0"
   Print *pz

   Print

   Function fr () ByRef As ZString
      Static As ZString * 256 z
      Return z
   End Function

   Dim ByRef As ZString rz = fr()  '' or Var Byref rz = fr()
   rz = "FreeBASIC Zstring Ref"
   Print rz
   rz &= " 1.4.0"
   Print rz

   Sleep
      

   '' It is possible to reassign a reference.
   '' An example with an UDT to control the successive constructions & destructions of objects handled with one only reference.

   Type UDT
     Declare Constructor ()
     Declare Destructor ()
     Dim As Integer I
   End Type

   Constructor UDT ()
     Static As Integer nb
     nb += 1
     This.I = nb
     Print "UDT.Constructor()"
   End Constructor

   Destructor UDT ()
     Print "UDT.Destructor()"
   End Destructor

   Var ByRef ru = *New UDT  '' or Dim Byref As UDT ru = *New UDT
   Print ru.I
   Delete @ru

   Print

   @ru = New UDT
   Print ru.I
   Delete @ru

   Sleep
      

   '' Polymorphism (by using inheritance and virtuality) can be activated through any of the 3 following kinds of entities:
   ''   - base-type pointers referring to derived-type objects,
   ''   - dereferenced base-type pointers referring to derived-type objects,
   ''   - base-type references referring to derived-type objects.
   '
   '' If in the first line of the below code, FALSE is put instead TRUE, the polymorphism by virtuality is no more activated.

   #define virtuality True

   Type myBase Extends Object
     #if virtuality = True
      Declare Virtual Sub hello()
     #else
      Declare Sub Hello()
     #endif
   End Type

   Sub myBase.hello()
     Print "myBase.hello()"
   End Sub

   Type myDerived Extends myBase
     Declare Sub hello()
   End Type

   Sub myDerived.hello()
     Print "myDerived.hello()"
   End Sub

   Dim As myBase mb
   Dim As myBase Ptr pmb = @mb
   Dim ByRef As myBase rmb = mb  '' or Var Byref rmb = mb
   pmb->hello()    '' pmb is a base-type pointer referring to a base-type object
   (*pmb).hello()  '' *pmb is a dereferenced base-type pointer referring to a base-type object
   rmb.hello()     '' rmb is a base-type reference referring to a base-type object

   Print

   Dim As myDerived md
   Dim As myBase Ptr pmd = @md
   Dim ByRef As myBase rmd = md  '' only syntax because the reference data-type must be different from the one of object
   pmd->hello()    '' pmd is a base-type pointer referring to a derived-type object
   (*pmd).hello()  '' *pmd is a dereferenced base-type pointer referring to a derived-type object
   rmd.hello()     '' rmd is a base-type reference referring to a derived-type object

   Sleep
      

Version
   * Since fbc 1.04.0

Dialect Differences
   * Only supported in -lang fb, -lang fblite and -lang deprecated 
     dialects.

Differences from QB
   * New to FreeBASIC.

See also
   * Dim
   * Static
   * Var
   * Shared
   * Byref (Parameters)
   * Byref (Function Results)



------------------------------------------------------------- KeyPgByte ----
Byte

Standard data type: 8 bit signed

Syntax
   Dim variable As Byte

Description
   8-bit signed whole-number data type. Can hold a value in the range of 
   -128 to 127.

Example
     Dim bytevar As Byte
     bytevar = 100
     Print "bytevar= ", bytevar

   Dim x As Byte = CByte(&H80)
   Dim y As Byte = CByte(&H7F)
   Print "Byte Range = "; x; " to "; y

   Output:
   Byte Range = -128 To  127

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Byte.

Differences from QB
   * New to FreeBASIC

See also
   * UByte
   * CByte
   * Table with variable types overview, limits and suffixes



------------------------------------------------------------ KeyPgByval ----
ByVal

Declaration specifier to explicitly pass a parameter by value

Syntax
   ByVal param As datatype

Usage
   [ Declare ] { Sub | Function } proc_name ( ByVal param As datatype  )

Description
   ByVal in a parameter list of a declare statement causes a copy of the 
   variable to be passed to the procedure (for example, a sub or function) 
   by its value.

   This means that if the value of the variable x is passed, then the 
   original variable x will not be modified in any way; however, if the 
   variable were passed ByRef, the value of the original variable x could 
   be modified by the called function.

   Opposite of ByRef.

   The ByVal keyword is also used in the context of Byref Parameters and 
   Function Results, where it can be used to explicitly override the 
   by-reference semantics in order to pass or assign a pointer as-is to a 
   Byref parameter or function result. For reference:
      * Manually passing pointers to by-reference parameters
      * Manually returning pointers as-is from Byref functions

   Note: ByVal (passing by copy) is good for small objects (4 or 8 bytes, a 
   bit more will still be ok) that are easy to copy, like numeric types. 
   Passing ByVal avoids the overhead of the pointer used by ByRef.
   ByRef is better for passing huge objects like strings or big UDTs that 
   should not be copied. Even though ByRef has some overhead because it has 
   to pass a pointer (and dereference at each access to the object), this 
   is still better than copying a multitude of bytes on to the stack 
   every-time the procedure is called.

Example
   Sub MySub(ByVal value As Integer)
      value += 1
   End Sub

   Dim MyVar As Integer

   MyVar = 1
   Print "MyVar: "; MyVar 'output = 1
   MySub MyVar
   Print "MyVar: "; MyVar 'output = 1, because byval won't change the values passed into it globally.
   Sleep
   End

Dialect Differences
   * In the -lang fb dialect, ByVal is the default parameter passing 
     convention for all built-in types except String and user-defined Type 
     which are passed ByRef by default. The ZString and WString built-in 
     types are also passed ByRef by default, but passing ByVal is 
     forbidden. Arrays are always passed ByRef and the use of the specifier 
     ByRef or ByVal is forbidden.
   * In -lang qb and -lang fblite dialects, ByRef is the default parameter 
     passing convention.

Differences from QB
   * QB only used ByVal in declarations to non-Basic subroutines

See also
   * Passing Arguments to Procedures
   * Declare
   * ByRef




============================================================================
    C

------------------------------------------------------------- KeyPgCall ----
Call

Statement to invoke a subroutine

Syntax
   Call procname ([parameter list])

Description
   Calls a Sub or Function.

   This keyword is a holdover from earlier dialects of BASIC, and is mainly 
   deprecated.

   In -lang qb, it can be used to call Subs in code before they are 
   declared.  The function will be implicitly Declare'd, with any 
   parameters passed ByRef As Any.
   Note: until the function is declared, no type-checking is done on the 
   parameters, so it is up to the programmer to ensure they are of the 
   correct type.

Example
   '' Compile with -lang qb or -lang fblite

   #lang "fblite"

   Declare Sub foobar(ByVal x As Integer, ByVal y As Integer)
   Call foobar(35, 42)

   Sub foobar(ByVal x As Integer, ByVal y As Integer)
   Print x; y
   End Sub

   '' Compile with -lang qb or -lang fblite

   #lang "fblite"

   Function f ( ) As Integer
   f = 42
   End Function

   Call f ' execute function f, but ignore the answer

   '' Compile with -lang qb

   '$lang: "qb"

   Call mysub(15, 16) '' call "mysub" before it has been declared, or even mentioned.

   Sub mysub(ByRef a As Integer, ByRef b As Integer)
      
      Print a, b
      
   End Sub

Dialect Differences
   * The use of Call is not allowed in the -lang fb dialect.
   * The -lang fblite dialect does not allow you to call functions that 
     have not been previously declared.

Differences from QB
   * The procedure must have already been declared.
   * Call in QB will make a copy of all parameters, so changes made to the 
     arguments inside the called Sub will not be reflected in the variables 
     in the caller.

See also
   * Declare
   * Sub



-------------------------------------------------------- KeyPgCallocate ----
CAllocate

Allocates memory for a certain number of elements from the free store and 
clears the contents

Syntax
   Declare Function CAllocate cdecl ( ByVal num_elements As UInteger, ByVal 
   size As UInteger = 1 ) As Any Ptr

Usage
   result = CAllocate( num_elements [, size ] )

Parameters
   num_elements
      The number of elements to allocate memory for.
   size
      The size, in bytes, of each element.

Return Value
   If successful, the address of the start of the allocated memory is 
   returned. Otherwise, the null pointer (0) is returned.

Description
   CAllocate initializes the allocated memory with zeros.
   Consequently, CAllocate can be also directly used with String or Udt 
   containing string, because the string descriptor is cleared (set to 0) 
   first.
   Similarly, CAllocate can also be used directly with ZString or WString 
   because string data is created with null characters.

Example
   ' Allocate and initialize space for 10 integer elements.
   Dim p As Integer Ptr = CAllocate(10, SizeOf(Integer))

   ' Fill the memory with integer values.
   For index As Integer = 0 To 9
      p[index] = (index + 1) * 10
   Next

   ' Display the integer values.
   For index As Integer = 0 To 9
      Print p[index] ;
   Next

   ' Free the memory.
   Deallocate(p)
      
Outputs:

    10 20 30 40 50 60 70 80 90 100
   	

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Callocate.

Differences from QB
   * New to FreeBASIC

See also
   * Allocate
   * Deallocate
   * Reallocate



------------------------------------------------------------- KeyPgCase ----
Case

Control flow statement

Syntax
   Case expression

Example
   See example at Select Case.

Differences from QB
   * None

See also
   * Select Case



------------------------------------------------------------- KeyPgCast ----
Cast

Converts an expression to a specified data type

Syntax
   Cast( datatype, expression )

Parameters
   datatype 
      a built-in data type (standard type)
   expression 
      a variable of another built-in data type

Description
   Converts expression into a different datatype. Useful to be used in 
   macros when datatype is unknown and also when converting to Type Alias.

   This is a general form of conversion operators such as CInt or CDbl.
   Cast is more versatile because it can be used on built-in types that 
   have a built-in Cast Operator, but don't have a built-in keyword for it: 
   e.g. Cast( Byte, boolean ).
   It is also suitable for use in cases where the type of a variable is not 
   fixed in the code - for example, it might be Defined earlier, or may be 
   the Type Of a different variable or expression.

   Note: If you want to use an operator specifically for converting to 
   different types of Pointers, consider using CPtr instead.

   Upcasting: In an inheritance structure, the upcasting is converting a 
   derived type reference or pointer into a base type.
   In this special use, Cast applied on a derived-type instance (expression
   ) can be used to return a base-type (datatype) reference.

   By using a member Operator Cast, Cast can be overloaded for a user 
   defined type expression.
  
Example
   '' will print -128 because the integer literal will be converted to a signed Byte
   '' (this Casting operation is equivalent to using CByte)
   Print Cast( Byte, &h0080 )

   '' will print 3 because the floating-point value will be converted to an Integer
   '' (this Casting operator is equivalent to using CInt)
   Print Cast( Integer, 3.1 )

   Sleep

   '' macro sizeofDerefPtr(): returns the size of the dereferenced pointer
   #define sizeofDerefPtr(ptrToDeref) SizeOf(*Cast(TypeOf(ptrToDeref), 0))

   '' macro typeofDerefPtr(): returns the type of the dereferenced pointer
   #define typeofDerefPtr(ptrToDeref) TypeOf(*Cast(TypeOf(ptrToDeref), 0))

   ' Allocate dynamically memory for a Double by New
   Dim As Double Ptr pd
   pd = New typeofDerefPtr(pd)
   *pd = 3.14159
   Print *pd

   ' Allocate dynamically memory for a Zstring*10 by Callocate
   Dim As ZString Ptr pz
   pz = CAllocate(10, sizeofDerefPtr(pz))
   *pz = "FreeBASIC"
   Print *pz

   Sleep
   Delete pd
   Deallocate(pz)

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Cast.

Differences from QB
   * New to FreeBASIC

See also
   * Cast (Operator)
   * CPtr
   * CInt
   * TypeOf
   * Coercion and Conversion
    


------------------------------------------------------------ KeyPgCbool ----
CBool

Converts numeric or string expression to a boolean (Boolean)

Syntax
   Declare Function CBool ( ByVal expression As datatype ) As Boolean

   Type typename
      Declare Operator Cast ( ) As Boolean
   End Type

Usage
   result = CBool( numeric expression )
   result = CBool( string expression )
   result = CBool( user defined type )

Parameters
   expression
      a numeric, string, or user defined type to cast to a Boolean value
   datatype
      any numeric, string, or user defined type
   typename
      a user defined type

Return Value
   A Boolean value.

Description
   The CBool function converts a zero value to False and a non-zero value 
   to True.

   The name can be explained as 'Convert to Boolean'.

   If the argument is a string expression, it is converted to boolean using 
   a case insensitive to the string "false" to return a False value or 
   "true" to return a True value.

Example
   ' Using the CBOOL function to convert a numeric value

   'Create an BOOLEAN variable
   Dim b As Boolean

   'Convert a numeric value
   b = CBool(1)

   'Print the result, should return True
   Print b
   Sleep

Version
   * Since fbc 1.04.0

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Cbool.

Differences from QB
   * New to FreeBASIC

See also
   * CByte
   * CUByte
   * CShort
   * CUShort
   * CInt
   * CUInt
   * CLng
   * CULng
   * CLngInt
   * CULngInt
   * CSng
   * CDbl
   * Str



------------------------------------------------------------ KeyPgCbyte ----
CByte

Converts numeric or string expression to Byte.

Syntax
   Declare Function CByte ( ByVal expression As datatype ) As Byte

   Type typename
      Declare Operator Cast ( ) As Byte
   End Type

Usage
   result = CByte( numeric expression )
   result = CByte( string expression )
   result = CByte( user defined type )

Parameters
   expression
      A numeric, string, or pointer expression to cast to a Byte value.
   datatype
      Any numeric, string, or pointer data type.
   typename
      A user defined type.

Return Value
   A Byte value.

Description
   The CByte function rounds off the decimal part and returns a 8-bit Byte 
   value. The function does not check for an overflow, and results are 
   undefined for values which are less than -128 or larger than 127.

   The name can be explained as 'Convert to Byte'.

   If the argument is a string expression, it is converted to numeric by 
   using ValInt.

Example
   ' Using the CBYTE function to convert a numeric value

   'Create an BYTE variable
   Dim numeric_value As Byte

   'Convert a numeric value
   numeric_value = CByte(-66.30)

   'Print the result, should return -66
   Print numeric_value
   Sleep

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Cbyte.

Differences from QB
   * New to FreeBASIC

See also
   * CUByte
   * CShort
   * CUShort
   * CInt
   * CUInt
   * CLng
   * CULng
   * CLngInt
   * CULngInt
   * CSng
   * CDbl



------------------------------------------------------------- KeyPgCdbl ----
CDbl

Converts numeric or string expression to Double precision floating point

Syntax
   Declare Function CDbl ( ByVal expression As datatype ) As Double

   Type typename
      Declare Operator Cast ( ) As Double
   End Type

Usage
   result = CDbl( numeric expression )
   result = CDbl( string expression )
   result = CDbl( user defined type )

Parameters
   expression
      a numeric, string, or pointer expression to cast to a Double value
   datatype
      any numeric, string, or pointer data type
   typename
      a user defined type

Return Value
   A Double precision value.

Description
   The CDbl function returns a 64-bit Double value. The function does not 
   check for an overflow, so be sure not to pass a value outside the 
   representable range of the Double data type. The name can be explained 
   as 'Convert to DouBLe'.

   If the argument to CDbl is a string expression, it is first converted to 
   numeric by using Val.

Example
   ' Using the CDBL function to convert a numeric value

   'Create an DOUBLE variable
   Dim numeric_value As Double

   'Convert a numeric value
   numeric_value = CDbl(-12345678.123)

   'Print the result, should return -12345678.123
   Print numeric_value
   Sleep

Differences from QB
   * The string argument was not allowed in QB

See also
   * CByte
   * CUByte
   * CShort
   * CUShort
   * CInt
   * CUInt
   * CLng
   * CULng
   * CLngInt
   * CULngInt
   * CSng



------------------------------------------------------------ KeyPgCdecl ----
cdecl

Specifies a cdecl-style calling convention in a procedure declaration

Syntax
   Sub name cdecl [Overload] [Alias "alias"] ( parameters )
   Function name cdecl [Overload] [Alias "alias"] ( parameters ) [ ByRef ] 
   As return_type

Description
   In procedure declarations, cdecl specifies that a procedure will use the 
   cdecl calling convention. In the cdecl calling convention, any 
   parameters are to be passed (pushed onto the stack) in the reverse order 
   in which they are listed, that is, from right to left. The procedures 
   need not preserve the EAX, ECX or EDX registers, and must not clean up 
   the stack (pop any parameters) before it returns - that is left to the 
   calling code.

   cdecl is allowed to be used with variadic procedure declarations (those 
   with the last parameter listed as "...").

   cdecl is the default calling convention on Linux, the *BSDs, and DOS, 
   unless another calling convention is explicitly specified or implied by 
   one of the Extern Blocks. cdecl is typically the default calling 
   convention for C compilers, and it's used almost exclusively on 
   Unix-like systems.

Example
   ' declaring 'strcpy' from the standard C library
   Declare Function strcpy cdecl Alias "strcpy" (ByVal dest As ZString Ptr, ByVal src As ZString Ptr) As ZString Ptr

Differences from QB
   * New to FreeBASIC

See also
   * pascal, stdcall
   * Declare
   * Sub, Function



------------------------------------------------------------ KeyPgChain ----
Chain

Temporarily transfers control to an external program

Syntax
   Declare Function Chain ( ByRef program As Const String ) As Long

Usage
   result = Chain( program )

Parameters
   program
      The file name (including file path) of the program (executable) to 
      transfer control to.

Return Value
      Returns the external program's exit code if executed successfully, or 
      negative one (-1) otherwise.

Description
   Transfers control over to an external program. When the program exits, 
   execution resumes immediately after the call to Chain.

Example
   #ifdef __FB_LINUX__
      Dim As String program = "./program"
   #else
      Dim As String program = "program.exe"
   #endif

   Print "Running " & program & "..."
   If (Chain(program) <> 0) Then
      Print program & " not found!"
   End If

Platform Differences
   * Linux requires the program name case matches the real name of the 
     file. Windows and DOS  are case insensitive. The program  chained may 
     be case sensitive for its command line parameters.
   * Path separators in Linux are forward slashes / . Windows uses 
     backward slashes \ but it allows for forward slashes .  DOS uses 
     backward  \ slashes.
   * Exit code is limited to 8 bits in DOS.

Differences from QB
   * Common does not allow to keep the values of certain variables when 
     chaining programs with Chain.

See also
   * Exec transfer temporarily, with arguments  
   * Run one-way transfer
   * Command pick arguments



------------------------------------------------------------ KeyPgChdir ----
ChDir

Changes the current drive and directory

Syntax
   Declare Function ChDir ( ByRef path As Const String ) As Long

Usage
   result = ChDir( path )

Parameters
   path
      A String argument specifying the path to change to.

Return Value
   Returns zero (0) on success and negative one (-1) on failure.

Description
   Changes the current drive and directory to that specified.

Example
   Dim pathname As String = "x:\folder"
   Dim result As Integer = ChDir(pathname)

   If 0 <> result Then Print "error changing current directory to " & pathname & "."

Platform Differences
   * Linux requires the filename case matches the real name of the file. 
     Windows and DOS are case insensitive. 
   * Path separators in Linux are forward slashes / . Windows uses 
     backward slashes \ but it allows for forward slashes .  DOS uses 
     backward  \ slashes. 

Differences from QB
   * In QB, the drive could not be specified.

See also
   * CurDir
   * MkDir
   * RmDir



-------------------------------------------------------------- KeyPgChr ----
Chr

Returns a string of characters from one or more ASCII integer values

Syntax
   Declare Function Chr ( ByVal ch As Integer [, ... ] ) As String

Usage
   result = Chr[$]( ch0 [, ch1 ... chN ] )

Parameters
   ch
      The ASCII integer value of a character.

Return Value
   Returns a string containing the character(s).

Description
   Chr returns a string containing the character(s) represented by the ASCII
   values passed to it.

   When Chr is used with numerical constants or literals, the result is 
   evaluated at compile-time, so it can be used in variable initializers.

   Asc performs the opposite function, returning the ASCII code of a 
   character represented by a string.

Example
   Print "the character represented by";
   Print " the ASCII code of 97 is: "; Chr(97)

   Print Chr(97, 98, 99) ' prints abc

   ' s initially has the value "abc"
   Dim s As String = Chr(97, 98, 99)

   Print s

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * FreeBASIC accepts multiple integer values as arguments, QB accepted 
     only one.
   * FreeBASIC evaluates the CHR function at compile time when used with 
     constants or literals.

See also
   * ASCII Character Codes
   * Asc
   * Str
   * Val



------------------------------------------------------------- KeyPgCint ----
CInt

Converts a numeric or string expression to an Integer or an Integer<bits>

Syntax
   Declare Function CInt ( ByVal expression As datatype ) As Integer
   Declare Function CInt<bits> ( ByVal expression As datatype ) As Integer<
   bits>

   Type typename
      Declare Operator Cast ( ) As Integer
      Declare Operator Cast ( ) As Integer<bits>
   End Type

Usage
   result = CInt( expression )
   result = CInt( string expression )
   result = CInt( user defined type )

Parameters
   bits
      A numeric constant expression indicating the size in bits of integer 
      desired.  The values allowed are 8, 16, 32 or 64.
   expression
      a numeric, string, or pointer expression to cast to a Integer value
   datatype
      any numeric, string, or pointer data type
   typename
      a user defined type

Return Value
   An Integer or Integer<bits> containing the converted value.

Description
   If CInt is passed a numeric expression, it rounds it using using the 
   round-to-even method - i.e. it rounds to the closest integer value, 
   choosing the closest even integer if the number is equidistant from two 
   integers - and returns an Integer, or if a bits value is supplied, an 
   integer type of the given size.

   The function does not check for an overflow; for example, for a 32-bit 
   Integer the results are undefined for values which are less than -2 147 
   483 648 or larger than 2 147 483 647.

   If the argument is a string expression, it is converted to numeric by 
   using ValInt or ValLng, depending on the size of the result type.

   The name "CINT" is derived from 'Convert to INTeger'.

Example
   ' Using the CINT function to convert a numeric value

   'Create an INTEGER variable
   Dim numeric_value As Integer

   'Convert a numeric value
   numeric_value = CInt(300.5)

   'Print the result, should return 300, because 300 is even

   numeric_value = CInt(301.5)

   'Print the result, should return 302, because 301 is odd
   Print numeric_value

Dialect Differences
   * In the -lang qb dialect, CInt will return a 16-bit integer, like in 
     QB.

Differences from QB
   * The string argument was not allowed in QB
   * The <bits> parameter was not allowed in QB

See also
   * Cast
   * CByte
   * CUByte
   * CShort
   * CUShort
   * CUInt
   * CLng
   * CULng
   * CLngInt
   * CULngInt
   * CSng
   * CDbl
   * Integer



----------------------------------------------------------- KeyPgCircle ----
Circle

Graphics statement to draw an ellipse or a circle

Syntax
   Circle [target,] [STEP] (x,y), radius[, [color][, [start][, [end][, 
   [aspect][, F]]]]]

Parameters
   target
      optional; specifies the image buffer to draw on
   STEP
      indicates that coordinates are relative
   (x, y)
      coordinates of the center of the ellipse
   radius
      the radius of the circle - or for an ellipse, the semi-major axis 
      (i.e. the longest radius)
   color
      the color attribute
   start
      starting angle
   end
      ending angle
   aspect
      aspect ratio of the ellipse, the ratio of the height to the width
   F
      fill mode indicator

Description
   Circle will draw a circle, ellipse, or arc based on the parameters given 
   to it. 

   target specifies a buffer to draw on.  target may be an image created 
   with ImageCreate or Get (Graphics).  If omitted, target defaults to the 
   screen's current work page.  (See ScreenSet)

   The center of the shape will be placed on the destination surface at (x, 
   y). 

   Radius denotes the radius of the shape. If aspect ratio is not 1.0, the 
   biggest radius must be given here.

   Color denotes the color attribute, which is mode specific (see Color and 
   Screen (Graphics) for details). If omitted, the current foreground color 
   as set by the Color statement is used.

   The Step option specifies that x and y are offsets relative to the 
   current graphics cursor position.

   start and end are angles are in radians. These can range -2*PI to 2*PI, 
   where PI is the constant &pi;, approximately 3.141593; if you specify a 
   negative angle, its value is changed sign and a line is drawn from the 
   center up to that point in the arc. end angle can be less than start. If 
   you do not specify start and end, a full circle/ellipse is drawn; if you 
   you specify start but not end, end is assumed to be 2*PI; if you specify 
   end but not start, start is assumed to be 0.0.

   aspect is the aspect ratio, or the ratio of the y radius over the x 
   radius. If omitted, the default for ScreenRes modes is 1.0, while for 
   Screen modes the default value is the value required to draw a perfect 
   circle on the screen, keeping the pixel aspect ratio in mind. This value 
   can be calculated as follows:

   ratio = (y_radius / x_radius) * pixel_aspect_ratio

   Where pixel_aspect_ratio is the ratio of the current mode width over the 
   current mode height, assuming a 4:3 standard monitor. If aspect ratio is 
   less than 1.0, radius is the x radius; if aspect is more or equal to 1.0
   , radius is the y radius.

   F is the fill flag. If you specify this flag, the circle/ellipse will be 
   filled with the selected color. This only takes effect if you are 
   drawing a full circle/ellipse.

   Custom coordinates system set up by Window and/or View (Graphics) affect 
   the drawing operation; clipping set by View also applies. When Circle 
   finishes drawing, the current graphics cursor position is set to the 
   supplied center.

   Note: Curves drawn with Circle can induce pixels overdrawn at some 
   locations. Thus, the resultant (blended) color of these overdrawn pixels 
   is affected if a transparent color (in conjunction with the 
   GFX_ALPHA_PRIMITIVES option flag) is used.

Example
   ' Set 640x480 mode, 256 colors
   Screen 18

   ' Draws a circle in the center
   Circle (320, 240), 200, 15

   ' Draws a filled ellipse
   Circle (320, 240), 200, 2, , , 0.2, F

   ' Draws a small arc
   Circle (320, 240), 200, 4, 0.83, 1.67, 3

   Sleep

Differences from QB
   * target is new to FreeBASIC
   * The FreeBASIC implementation uses a different algorithm for 
     ellipse/arc drawing than QB, so the result may not be equal to QB for 
     every pixel.
   * The F flag to draw filled circles/ellipses is new to FreeBASIC.

See also
   * Screen (Graphics)
   * Color



------------------------------------------------------------ KeyPgClass ----
Class

Declares a class object

Syntax
   Class typename ...

Parameters
   typename
      name of the Class

Description
   We would have put something useful here (honest) except this feature 
   isn't implemented in the compiler yet.  But since it will get added in 
   future, and there are several other document pages that need to link 
   here, we thought it safe to include in anyway.

Example
   '' sample code

Output:

   sample Output

Dialect Differences
   * Object-related features are supported only in the -lang fb option

Differences from QB
   * New to FreeBASIC

See also
   * Enum
   * Type



------------------------------------------------------------ KeyPgClear ----
Clear

Clears or initializes some memory

Syntax
   Declare Sub Clear cdecl ( ByRef dst As Any, ByVal value As Long = 0, 
   ByVal bytes As UInteger )

Usage
   Clear( dst, [value], bytes )

Parameters
   dst
      starting address of some memory
   value
      the value to set all bytes equal to
   bytes
      number of bytes to clear

Description
   Clear sets one or more bytes in memory to a certain value (the default 
   value is zero (0) if not specified). The starting address is taken from 
   a reference to a variable or array element.

   NOTE: In order to clear memory referenced by a Pointer, it must be 
   dereferenced first (or else specifying in argument term the ByVal 
   keyword in front of the pointer name). Otherwise, Clear will try to 
   clear the bytes at the pointer variable's memory location.

Example
   'create an array with 100 elements
   Dim array(0 To 99) As Integer

   'clear the contents of the array to 0, starting with the first element
   Clear array(0), , 100 * SizeOf(Integer)

   'allocate 20 bytes of memory
   Dim As Byte Ptr p = Allocate(20)

   'set each of the first ten bytes to 0
   Clear *p, 0, 10

   'set each of the next ten bytes to 42
   Clear p[10], 42, 10

   'check the values of the allocated bytes
   For i As Integer = 0 To 19
      Print i, p[i]
   Next

   'deallocate memory
   Deallocate p

Differences from QB
   * The behavior and usage is new to FreeBASIC
   * The keyword CLEAR was used in QB to erase all variables, close all 
     files, and optionally change the stack size. This use is not supported 
     in FreeBASIC.

See also
   * Erase
   * Reset



------------------------------------------------------------- KeyPgClng ----
CLng

Converts numeric or string expression to Long

Syntax
   Declare Function CLng ( ByVal expression As datatype ) As Long

   Type typename
      Declare Operator Cast ( ) As Long
   End Type

Usage
   result = CLng( numeric expression )
   result = CLng( string expression )
   result = CLng( user defined type )

Parameters
   expression
      a numeric, string, or pointer expression to cast to a Long value
   datatype
      any numeric, string, or pointer data type
   typename
      a user defined type

Return Value
   A Long value.

Description
   The CLng function rounds off the decimal part and returns a 32-bit Long 
   value.  The function does not check for an overflow, and results are 
   undefined for values which are less than -2 147 483 648 or larger than 2 
   147 483 647.

   The name can be explained as 'Convert to LoNG'.

   If the argument is a string expression, it is converted to numeric by 
   using ValInt.

Example

   ' Using the CLNG function to convert a numeric value

   'Create an LONG variable
   Dim numeric_value As Long

   'Convert a numeric value
   numeric_value = CLng(-300.23)

   'Print the result, should return -300
   Print numeric_value
   Sleep

Differences from QB
   * The string argument was not allowed in QB

See also
   * CByte
   * CUByte
   * CShort
   * CUShort
   * CInt
   * CUInt
   * CULng
   * CLngInt
   * CULngInt
   * CSng
   * CDbl



---------------------------------------------------------- KeyPgClngint ----
CLngInt

Converts numeric or string expression to 64-bit integer (LongInt)

Syntax
   Declare Function CLngInt ( ByVal expression As datatype ) As LongInt

   Type typename
      Declare Operator Cast ( ) As LongInt
   End Type

Usage
   result = CLngInt( numeric expression )
   result = CLngInt( string expression )
   result = CLngInt( user defined type )

Parameters
   expression
      a numeric, string, or pointer expression to cast to a LongInt value
   datatype
      any numeric, string, or pointer data type
   typename
      a user defined type

Return Value
   A LongInt value.

Description
   The CLngInt function rounds off the decimal part and returns a 64-bit 
   LongInt value.  The function does not check for an overflow, and results 
   are undefined for values which are less than -9 223 372 036 854 775 808 
   or larger than 223 372 036 854 775 807.

   The name can be explained as 'Convert to LoNG INTeger'.

   If the argument is a string expression, it is converted to numeric by 
   using ValLng.

Example
   ' Using the CLNGINT function to convert a numeric value

   'Create an LONG INTEGER variable
   Dim numeric_value As LongInt

   'Convert a numeric value
   numeric_value = CLngInt(-12345678.123)

   'Print the result, should return -12345678
   Print numeric_value
   Sleep

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Clngint.

Differences from QB
   * New to FreeBASIC

See also
   * CByte
   * CUByte
   * CShort
   * CUShort
   * CInt
   * CUInt
   * CLng
   * CULng
   * CULngInt
   * CSng
   * CDbl



------------------------------------------------------------ KeyPgClose ----
Close

Stream I/O function to terminate access to a device

Syntax
   Close [[#]filenum ] [, [#]filenum ...]
             or 
   result = Close( [#filenum] )

Parameters
   filenum
      List of file numbers to close.

Return Value
   Close returns a 32 bit Long: a zero (0) on success and a non-zero error 
   code otherwise.

Description
   Closes the files whose file numbers are passed as arguments. If an 
   unused file number is passed, Close returns an error.

   Close without arguments closes all the files presently opened.

   Terminating the program using an End statement will automatically close 
   all files.

   The error code returned by Close can be checked using Err in the next 
   line. The function version of  Close returns directly the error code as 
   a 32 bit Long.

Example
   ' Create a string and fill it.
   Dim buffer As String, f As Integer

   buffer = "Hello World within a file."

   ' Find the first free file number.
   f = FreeFile

   ' Open the file "file.ext" for binary usage, using the number "f".
   Open "file.ext" For Binary As #f

     ' Place our string inside the file, using number "f".
     Put #f, , buffer

   ' Close the file.  We could also do 'Close #f', but it's only necessary if more than one number is open.
   Close

   ' End of program. (Check the file "file.ext" upon running to see the output.)

Differences from QB
   * Close can be called as a function that returns an error code.
   * FB throws an error on trying to close an unused file number, if 
     compiled with error checking and if not used with the function-style 
     syntax

See also
   * Open
   * Put (File I/O) 
   * Get (File I/O)
   * FreeFile



-------------------------------------------------------------- KeyPgCls ----
Cls

Clears the screen in both text modes and graphics modes

Syntax
   Declare Sub Cls ( ByVal mode As Long = 1 )

Usage
   Cls mode

Parameters
   mode
      A optional numeric variable with a value from 0 to 2.  If omitted, it 
      defaults to 1.

Description
   An optional mode parameter may be given,

      If omitted, Cls clears either the text or graphics viewport.  If a 
      graphics viewport has been defined using the View (Graphics) 
      statement, the graphics viewport is cleared.  Otherwise, the text 
      viewport, defined by View Print, is cleared.  (If there is no 
      explicit text viewport defined, the entire screen is cleared.)

      If 0, clears the entire screen

      If 1, clears the graphics viewport if defined.  Otherwise, clears the 
      text viewport

      If 2, clears the text viewport

Example
   '' set the color to light grey text on a blue background
   Color 7, 1

   '' clear the screen to the background color
   Cls

   '' print text in the center of the screen
   Locate 12, 33
   Print "Hello Universe!"

In graphics modes, if you want to clear the entire screen to color 0, it 
can be faster using  Clear to write zeroes to the screen memory than 
calling Cls.

   Dim scrbuf As Byte Ptr, scrsize As Integer
   Dim As Long scrhei, scrpitch
   Dim As Integer r = 0, dr = 1

   ScreenRes 640, 480, 8

   scrbuf = ScreenPtr: Assert( scrbuf <> 0 )
   ScreenInfo( , scrhei, , , scrpitch )
   scrsize = scrpitch * scrhei

   Do
      
      '' lock the screen (must do this while working directly on screenbuffer)
      ScreenLock
         
         '' clear the screen (could use Cls here):
         Clear *scrbuf, 0, scrsize
         
         '' draw circle
         Circle (320, 240), r
         
      ScreenUnlock
      
      '' grow/shrink circle radius
      r += dr
      If r <= 0 Then dr = 1 Else If r >= 100 Then dr = -1
      
      '' short pause in each frame (prevents hogging the CPU)
      Sleep 1, 1
      
      '' run loop until user presses a key
   Loop Until Len(Inkey) > 0

Differences from QB
   * None

See also
   * Color
   * Locate
   * Print
   * ?
   * View (Graphics)



------------------------------------------------------------ KeyPgColor ----
Color

Sets the display foreground / background color that is used with console 
output and graphics output of text

Syntax
   Declare Function Color ( ByVal foreground As ULong , ByVal background As 
   ULong ) As ULong

Usage
   Color [foreground] [, background]
   result = Color [( [foreground] [, background] )]

Parameters
   foreground
      the foreground color to set
   background
      the background color to set

Return Value
   Returns a 32-bit value containing the current foreground color in the 
   Low Word and the current background color in the High Word.
   In hi/truecolor modes, only the foreground color is returned, taking up 
   the whole 32 bits. Instead, see ScreenControl to return the current 
   graphics mode color (foreground and background).

   The old color values can be retrieved at the same time as setting new 
   ones.

Description
   The Color statement sets the current foreground and/or background 
   colors. Circle, Draw, Line (Graphics), Cls, Paint, Print, PReset and PSet
   all use the last colors set by this function when you don't specify a 
   color to them, where applicable. The color values that Color accepts 
   depend on the current graphics mode.

      +---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
      |Mode     |Meaning                                                                                                                                                                                                                             |
      |1        |foreground is screen color (ranging 0-15). background is the emulated CGA palette to be used: 0 (green, red, and brown), 1 (cyan, magenta and white), 2 (same as 0, but with bright colors) or 3 (same as 1, but with bright colors)|
      |2, 11    |foreground is a color index in current palette (ranging 0-1). background is a color index in current palette (ranging 0-1).                                                                                                         |
      |7, 8     |foreground is a color index in current palette (ranging 0-15). background is screen color index in current palette (ranging 0-15).                                                                                                  |
      |9        |foreground is a color index in current palette (ranging 0-63). background is screen color index in current palette (ranging 0-63).                                                                                                  |
      |12       |foreground is a color index in current palette (ranging 0-15). background is a color index in current palette (ranging 0-15).                                                                                                       |
      |13 and up|foreground is a color index in current palette (ranging 0-255). background is a color index in current palette (ranging 0-255).                                                                                                     |
      +---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

   If you are using a color depth higher than 8bpp, foreground and 
   background are direct RGB color values in the form &hAARRGGBB, where AA, 
   RR, GG and BB are the alpha, red, green and blue components ranging &h00
   -&hFF (0-255 in decimal notation). While in hi/truecolor modes, you can 
   use the RGB or RGBA macro to obtain a valid color value.
   A Default Palette is automatically set when entering a Screen mode. 

Example
   ' Sets 320x240 in 32bpp color depth
   Screen 14, 32

   ' Sets orange foreground and dark blue background color
   Color RGB(255, 128, 0), RGB(0, 0, 64)

   ' Clears the screen to the background color
   Cls                     

   ' Prints "Hello World!" in the middle of the screen
   Locate 15, 14
   Print "Hello World!"

   Sleep

   Dim c As ULong

   'retrieve current color values
   c = Color()

   'extract color values from c using LOWORD and HIWORD
   Print "Console colors:"
   Print "Foreground: " & LoWord(c)
   Print "Background: " & HiWord(c)

   ' In 32-bit color depth, Function Color() returns only the foreground color

   #include "fbgfx.bi"

   '' screencontrol expects integer/uinteger
   Dim As UInteger fgcolor, bkcolor

   ScreenRes 500, 500, 32
   Width 500\8, 500\16
   Color &HFFFF00, &H0000FF
   Cls

   Print "From Function Color():"
   Print "  Foreground Color: "; Hex(Color(), 8)
   Print

   ScreenControl FB.GET_COLOR, fgcolor, bkcolor
   Print "From Sub ScreenControl():"
   Print "  Foreground Color: "; Hex(fgcolor, 8)
   Print "  Background Color: "; Hex(bkcolor, 8)

   Sleep

Differences from QB
   * Direct color modes were not supported in QB.
   * There is no border argument.

See also
   * RGB
   * RGBA
   * LoWord
   * HiWord
   * Locate
   * Palette
   * Screen



---------------------------------------------------------- KeyPgCommand ----
Command

Returns command line parameters used to call the program

Syntax
   Declare Function Command ( ByVal index As Long = -1 ) As String

Usage
   result = Command[$]( [ index ] )

Parameters
   index
      Zero-based index for a particular command-line argument.

Return Value
     Returns the command-line arguments(s).

Description
   Command returns command-line arguments passed to the program upon 
   execution.

   If index is less than zero (< 0), a space-separated list of all 
   command-line arguments is returned, otherwise, a single argument is 
   returned. A value of zero (0) returns the name of the executable; and 
   values of one (1) and greater return each command-line argument.

   If index is greater than the number of arguments passed to the program, 
   the null string ("") is returned.

   When the command line is parsed for arguments, everything between double 
   quotes in the parameter list will be considered as a single block, and 
   is returned without the double quotes.

   By default, filename globbing for arguments (expansion of wildcards to 
   filenames) is used on all ports of FreeBASIC for compatibility.  
   Arguments on the command line containing wildcards are typically not 
   expanded if when no file is matched or if properly quoted.  Other 
   special characters for redirection are typically not returned unless 
   properly quoted.  Consult the documentation on the shell being used for 
   more information on the proper quoting of command line arguments.
   There may be some strange behavior when using backslash(es) in command 
   line arguments, and the result may even depend on the platform.

   WARNING: By nature of constructor precedence in FreeBASIC and main() 
   initialization, calling Command within a global constructor (module 
   constructor or UDT constructor called for static/shared object) is not 
   safe (may even induce a runtime error).

   Disabling filename globbing under Win32
      Define the following global variable(s) somewhere in the source:
   '' For MinGW.org and Cygwin runtimes:
   Extern _CRT_glob Alias "_CRT_glob" As Long
   Dim Shared _CRT_glob As Long = 0

   '' For MinGW-w64 runtime:
   Extern _dowildcard Alias "_dowildcard" As Long
   Dim Shared _dowildcard As Long = 0

   Disabling filename globbing under Dos
      Define the following function somewhere in the source:
   Function __crt0_glob_function Alias "__crt0_glob_function" ( ByVal arg As UByte Ptr ) As UByte Ptr Ptr
     Return 0
   End Function

   Disabling filename globbing under Linux
      Filename globbing is handled by the command shell.  Quote the 
      argument containing wildcards or disable filename globbing in the 
      shell prior to executing the command.  For example in bash use 'set 
      -f' to disable wildcard expansion

Example
   Print "program launched via: " & Command(0)

   Dim As Integer i = 1
   Do
      Dim As String arg = Command(i)
      If Len(arg) = 0 Then
         Exit Do
      End If

      Print "command line argument " & i & " = """ & arg & """"
      i += 1
   Loop

   If i = 1 Then
      Print "(no command line arguments)"
   End If

   Sleep

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * The numeric argument was not supported in QB.
   * QB converted the parameter list to uppercase before returning it, 
     FreeBASIC doesn't.
   * By default arguments containing wildcard characters are expanded 
     (filename globbing)

See also
   * __FB_ARGC__
   * __FB_ARGV__
   * Exec
   * Run



----------------------------------------------------------- KeyPgCommon ----
Common

Variable declaration and scope modifier

Syntax
   Common [Shared] symbolname[()] [AS DataType] [, ...]

Description
   Declares a variable which is shared between code modules, including 
   those to be compiled as static and dynamic libraries (DLLs).
   A matching Common statement must appear in all other code modules using 
   the variable. 

   Common variables cannot be initialized.
   Common arrays are always variable-length, and must be defined with an 
   empty parameter list (), and its dimensions set in a later Dim or ReDim 
   statement.
   Common variables cannot be instances of a user-defined type having a 
   constructor or a destructor even implicit.

   The Shared optional parameter makes the variable global so that it can 
   be used inside Subs and Functions, as well as at module level.

Example
   '' common1.bas

   Declare Sub initme()

   Common Shared foo() As Double

   ReDim foo(0 To 2)

   initme()

   Print foo(0), foo(1), foo(2)

   '' common2.bas

   Common Shared foo() As Double

   Sub initme()
     foo(0) = 4*Atn(1)
     foo(1) = foo(0)/3
     foo(2) = foo(1)*2
   End Sub

After compiling the two files like:
fbc common1.bas common2.bas
running common1 produces the output:

    3.141592653589793           1.047197551196598           2.094395102393195

Platform Differences
   * Windows does not support Common with a dynamic library (compiled with 
     -dll or -dylib).

Differences from QB
   * The arrays will be always variable-length.
   * blockname is not needed and must be removed because the order of 
     declaration no longer matters, only the symbol names.
   * Common does not allow to keep the values of certain variables when 
     chaining programs with Chain.

See also
   * Dim
   * Erase
   * Extern
   * LBound
   * ReDim
   * Preserve
   * Shared
   * Static
   * UBound
   * Var



---------------------------------------------------- KeyPgCondBroadcast ----
CondBroadcast

Restarts all threads CondWaiting for the handle

Syntax
   Declare Sub CondBroadcast ( ByVal handle As Any Ptr )

Usage
   CondBroadcast ( handle )

Parameters
   handle
      The handle of a conditional variable.

Description
   Once the conditional is CondCreate and the threads are started, one of 
   more of them (including the implicit main thread executing main program) 
   can be set to CondWait for the conditional, they will be stopped until 
   some other thread CondSignals that the waiting thread can restart. 
   CondBroadcast can be used to restart all threads waiting for the 
   conditional. At the end of the program CondDestroy must be used to avoid 
   leaking resources in the OS.

   Condbroadcast must be used instead of CondSignal to restart all threads 
   waiting on the conditional.

Example
   See CondCreate

Platform Differences
   * Condbroadcast is not available with the DOS version / target of 
     FreeBASIC, because multithreading is not supported by DOS kernel nor 
     the used extender.
   * In Linux the threads are always started in the order they are 
     created, this can't be assumed in Win32. It's an OS, not a FreeBASIC 
     issue. 

Dialect Differences
   * Threading is not allowed in -lang qb

Differences from QB
   * New to FreeBASIC

See also
   * CondCreate
   * CondDestroy
   * CondSignal
   * CondWait
   * ThreadCreate



------------------------------------------------------- KeyPgCondCreate ----
CondCreate

Creates a conditional variable to be used in synchronizing threads

Syntax
   Declare Function CondCreate ( ) As Any Ptr

Usage
   result = CondCreate

Return Value
   A handle to a newly created conditional variable, or the null pointer 
   (0) on failure.

Description
   Once the conditional is Condcreated and the threads are started, one or 
   more of them (including the implicit main thread executing main program) 
   can be set to CondWait for the conditional, they will be stopped until 
   some other thread CondSignals that the waiting thread can restart. 
   CondBroadcast can be used to restart all threads waiting for the 
   conditional. At the end of the program CondDestroy must be used to avoid 
   leaking resources in the OS.

Example
   See also CondWait and CondSignal

   ''
   '' make newly-created threads wait until all threads are ready, then start them all at once
   ''

   Dim Shared hcondstart As Any Ptr
   Dim Shared hmutexstart As Any Ptr
   Dim Shared start As Integer = 0

   Dim Shared threadcount As Integer
   Dim Shared hmutexready As Any Ptr
   Dim Shared hcondready As Any Ptr

   Sub mythread(ByVal id_ptr As Any Ptr)
      Dim id As Integer = Cast(Integer, id_ptr)
     
      '' signal that this thread is ready
      MutexLock hmutexready
      threadcount += 1
      Print "Thread #" & id & " is waiting..."
      CondSignal hcondready
      MutexUnlock hmutexready
      
      '' wait for the start signal
      MutexLock hmutexstart
      Do While start = 0   
         CondWait hcondstart, hmutexstart
      Loop

      '' now this thread holds the lock on hmutexstart
      
      MutexUnlock hmutexstart

      '' print out the number of this thread
      For i As Integer = 1 To 40
         Print id;
      Next i
   End Sub

   Dim threads(1 To 9) As Any Ptr

   hcondstart = CondCreate()
   hmutexstart = MutexCreate()

   hcondready = CondCreate()
   hmutexready = MutexCreate()

   threadcount = 0

   MutexLock(hmutexready)
   For i As Integer = 1 To 9
      threads(i) = ThreadCreate(@mythread, Cast(Any Ptr, i))
      If threads(i) = 0 Then
         Print "unable to create thread"
      End If
   Next i

   Print "Waiting until all threads are ready..."

   Do Until threadcount = 9
      CondWait(hcondready, hmutexready)
   Loop
   MutexUnlock(hmutexready)

   Print
   Print "Go!"

   MutexLock hmutexstart
   start = 1
   CondBroadcast hcondstart
   MutexUnlock hmutexstart

   '' wait for all threads to complete
   For i As Integer = 1 To 9
      If threads(i) <> 0 Then
         ThreadWait threads(i)
      End If
   Next i

   MutexDestroy hmutexready
   CondDestroy hcondready

   MutexDestroy hmutexstart
   CondDestroy hcondstart

   'Visual example of mutual exclusion + mutual synchronization between 2 threads
   'by using Mutex and CondVar:
   'the "user-defined thread" computes the points coordinates on a circle,
   'and the "main thread" plots the points.
   '
   'Principle of mutual exclusion + mutual synchronisation
   '          Thread#A               XOR + <==>             Thread#B
   '.....                                          .....
   'MutexLock(mut)                                 MutexLock(mut)
   '  Do_something_with_exclusion                    Do_something_with_exclusion
   '  While bool#1 <> true <------------------------ bool#1 = true
   '    CondWait(cond#1, mut) <--------------------- CondSignal(cond#1)
   '  Wend <-----------------------------------.     Do_something_with_exclusion
   '  bool#1 = false               .---------- | --> While bool#2 <> true
   '  Do_something_with_exclusion  |   .------ | ----> CondWait(cond#2, mut)
   '  bool#2 = true ---------------'   |   .-- | --> Wend
   '  CondSignal(cond#2) --------------'   |   |     bool#2 = false
   '  Do_something_with_exclusion          |   |     Do_something_with_exclusion
   'MutexUnlock(mut) ----------------------'   '-- MutexUnlock(mut)
   '.....                                          .....
   '
   'Behavior:
   '- Unnecessary to pre-calculate the first point.
   '- Each calculated point is plotted one time only.
   '
   'If you comment out the lines containing "MutexLock" and "MutexUnlock",
   '"CondWait" and "CondSignal", ".ready"
   '(inside "user-defined thread" or/and "main thread"),
   'there will be no longer mutual exclusion nor mutual synchronization
   'between computation of coordinates and plotting of points,
   'and many points will not be plotted on circle (due to non coherent coordinates).

   '-----------------------------------------------------------------------------------------------------

   Type ThreadUDT                                   'Generic user thread UDT
      Dim handle As Any Ptr                        'Any Ptr handle to user thread
      Dim sync As Any Ptr                          'Any Ptr handle to mutex
      Dim cond1 As Any Ptr                         'Any Ptr handle to conditional1
      Dim cond2 As Any Ptr                         'Any Ptr handle to conditional2
      Dim ready1 As Byte                           'Boolean to coordinates ready1
      Dim ready2 As Byte                           'Boolean to coordinates ready2
      Dim quit As Byte                             'Boolean to end user thread
      Declare Static Sub Thread (ByVal As Any Ptr) 'Generic user thread procedure
      Dim procedure As Sub (ByVal As Any Ptr)      'Procedure(Any Ptr) to be executed by user thread
      Dim p As Any Ptr                             'Any Ptr to pass to procedure executed by user thread
      Const False As Byte = 0                      'Constante "false"
      Const True As Byte = Not False               'Constante "true"
   End Type

   Static Sub ThreadUDT.Thread (ByVal param As Any Ptr) 'Generic user thread procedure
      Dim tp As ThreadUDT Ptr = param                  'Casting to generic user thread UDT
      Do
         Static As Integer I
         MutexLock(tp->sync)                          'Mutex (Lock) for user thread
         tp->procedure(tp->p)                         'Procedure(Any Ptr) to be executed by user thread
         I += 1
         Locate 30, 38
         Print I;
         tp->ready1 = True                            'Set ready1
         CondSignal(tp->cond1)                        'CondSignal to send signal1 to main thread
         While tp->ready2 <> True                     'Process loop against spurious wakeups
            CondWait(tp->cond2, tp->sync)            'CondWait to receive signal2 from main-thread
         Wend
         tp->ready2 = False
         If tp->quit = tp->True Then                  'Test for ending user thread
            MutexUnlock(tp->sync)                    'Mutex (Unlock) for user thread
            Exit Do
         End If
         MutexUnlock(tp->sync)                        'Mutex (Unlock) for user thread
         Sleep 5, 1
      Loop
   End Sub

   '-----------------------------------------------------------------------------------------------------

   Type Point2D
      Dim x As Integer
      Dim y As Integer
   End Type

   Const x0 As Integer = 640 / 2
   Const y0 As Integer = 480 / 2
   Const r0 As Integer = 200

   Const pi As Single = 4 * Atn(1)

   Sub PointOnCircle (ByVal p As Any Ptr)
      Dim pp As Point2D Ptr = p
      Dim teta As Single = 2 * pi * Rnd
      pp->x = x0 + r0 * Cos(teta)
      Sleep 5, 1                         'To increase possibility of uncorrelated data occurrence
      pp->y = y0 + r0 * Sin(teta)
   End Sub

   Screen 12
   Locate 30, 2
   Print "<any_key> : exit";
   Locate 30, 27
   Print "calculated:";
   Locate 30, 54
   Print "plotted:";

   Dim Pptr As Point2D Ptr = New Point2D

   Dim Tptr As ThreadUDT Ptr = New ThreadUDT
   Tptr->sync = MutexCreate
   Tptr->cond1 = CondCreate
   Tptr->cond2 = CondCreate
   Tptr->procedure = @PointOnCircle
   Tptr->p = Pptr
   Tptr->handle = ThreadCreate(@ThreadUDT.Thread, Tptr)

   Do
      Static As Integer I
      MutexLock(Tptr->sync)                 'Mutex (Lock) for main thread
      While Tptr->ready1 <> Tptr->True      'Process loop against spurious wakeups
         CondWait(Tptr->cond1, Tptr->sync) 'CondWait to receive signal1 from user-thread
      Wend
      Tptr->ready1 = Tptr->False
      PSet (Pptr->x, Pptr->y)               'Plotting one point
      I += 1
      Locate 30, 62
      Print I;
      Tptr->ready2 = Tptr->True             'Set ready2
      CondSignal(Tptr->cond2)               'CondSignal to send signal2 to user thread
      If Inkey <> "" Then
         Tptr->quit = Tptr->True           'Set quit
         MutexUnlock(Tptr->sync)           'Mutex (Unlock) for main thread
         Exit Do
      End If
      MutexUnlock(Tptr->sync)               'Mutex (Unlock) for main thread
      Sleep 5, 1
   Loop
    

   ThreadWait(Tptr->handle)
   MutexDestroy(Tptr->sync)
   CondDestroy(Tptr->cond1)
   CondDestroy(Tptr->cond2)
   Delete Tptr
   Delete Pptr

   Sleep

   See also the similar MutexCreate example

Platform Differences
   * Condcreate is not available with the DOS version / target of 
     FreeBASIC, because multithreading is not supported by DOS kernel nor 
     the used extender.

Dialect Differences
   * Threading is not allowed in -lang qb

Differences from QB
   * New to FreeBASIC

See also
   * CondBroadcast
   * CondDestroy
   * CondSignal
   * CondWait
   * MutexCreate
   * MutexLock
   * MutexUnlock
   * ThreadCreate



------------------------------------------------------ KeyPgCondDestroy ----
CondDestroy

Destroys a multi-threading conditional variable when it is no more needed

Syntax
   Declare Sub CondDestroy ( ByVal handle As Any Ptr )

Usage
   CondDestroy ( handle )

Parameters
   handle
      The handle of a conditional variable to destroy.

Description
   Once the conditional is CondCreated and the threads are started, one of 
   more of them (including the implicit main thread executing main program) 
   can be set to CondWait for the conditional, they will be stopped until 
   some other thread CondSignals that the waiting thread can restart. 
   CondBroadcast can be used to restart all threads waiting for the 
   conditional. At the end of the program CondDestroy must be used to avoid 
   leaking resources in the OS.

   Conddestroy destroys a condition variable, freeing the resources it 
   might hold. No threads must be waiting on the condition variable on 
   entrance to Conddestroy.

Example
   See CondCreate, CondWait and CondSignal

Platform Differences
   * Conddestroy is not available with the DOS version / target of 
     FreeBASIC, because multithreading is not supported by DOS kernel nor 
     the used extender.

Dialect Differences
   * Threading is not allowed in -lang qb

Differences from QB
   * New to FreeBASIC

See also
   * CondCreate
   * CondBroadcast
   * CondSignal
   * CondWait
   * ThreadCreate



------------------------------------------------------- KeyPgCondSignal ----
CondSignal

Restarts a thread suspended by a call to CondWait

Syntax
   Declare Sub CondSignal ( ByVal handle As Any Ptr )

Usage
   CondSignal ( handle )

Parameters
   handle
      The handle of a conditional variable.

Description
   Once the conditional is created with CondCreate and the threads are 
   started, one of more of them (including the implicit main thread 
   executing main program) can be set to CondWait for the conditional, they 
   will be stopped until some other thread CondSignals that the waiting 
   thread can restart. CondBroadcast can be used to restart all threads 
   waiting for the conditional. At the end of the program CondDestroy must 
   be used to avoid leaking resources in the OS.

   Condsignal restarts one thread waiting. It should be called after mutex 
   is locked (using the same mutex as one used with CondWait). If no 
   threads are waiting on the conditional, nothing happens (the signal is 
   lost forever); if several are waiting, only one is restarted. The caller 
   must then unlock mutex in order for CondWait subroutine to complete.

Example
   See also CondCreate and CondWait

   ' This very simple example code demonstrates the use of several condition variable routines.
   ' The main routine initializes a string and creates one thread.
   ' The main routine waits until receive the condition signal from the thread, then print the complemented string.
   ' The thread complements the string, then sends a condition signal.
   '
   'Principle of mutual exclusion + simple synchronization
   '          Thread#A             XOR + ==>            Thread#B
   '.....                                     .....
   'MutexLock(mut)                            MutexLock(mut)
   '  Do_something_with_exclusion               Do_something_with_exclusion
   '  Thread_signal = true -------------------> While Thread_signal <> true
   '  CondSignal(cond) -------------------------> CondWait(cond, mut)
   '  Do_something_with_exclusion      .------> Wend
   'MutexUnlock(mut) ------------------'        Thread_signal = false
   '.....                                       Do_something_with_exclusion
   '.....                                     MutexUnlock(mut)
   '.....                                     .....

   Dim Shared As Any Ptr mutex
   Dim Shared As Any Ptr cond
   Dim Shared As String txt
   Dim As Any Ptr pt
   Dim Shared As Integer ok = 0

   Sub thread (ByVal p As Any Ptr)
      Print "thread is complementing the string"
      MutexLock(mutex)
      Sleep 400, 1
      txt &= " complemented by thread"
      ok = 1
      CondSignal(cond)
      MutexUnlock(mutex)
      Print "thread signals the processing completed"
   End Sub

   mutex = MutexCreate
   cond = CondCreate

   txt = "example of text"
   Print "main() initializes a string = " & txt
   Print "main creates one thread"
   Print
   pt = ThreadCreate(@thread)
   MutexLock(mutex)
   While ok <> 1
      CondWait(cond, mutex)
   Wend
   Print
   Print "back in main(), the string = " & txt
   ok = 0
   MutexUnlock(mutex)

   ThreadWait(pt)
   MutexDestroy(mutex)
   CondDestroy(cond)

Dialect Differences
   * Threading is not allowed in -lang qb

Platform Differences
   * Condsignal is not available with the DOS version / target of 
     FreeBASIC, because multithreading is not supported by DOS kernel nor 
     the used extender.
   * In Linux the threads are always started in the order they are 
     created, this can't be assumed in Win32. It's an OS, not a FreeBASIC 
     issue. 

Differences from QB
   * New to FreeBASIC

See also
   * CondCreate
   * CondDestroy
   * CondBroadcast
   * CondWait
   * ThreadCreate



--------------------------------------------------------- KeyPgCondWait ----
CondWait

Stops execution of current thread until some condition becomes true

Syntax
   Declare Sub CondWait ( ByVal handle As Any Ptr, ByVal mutex As Any Ptr )

Usage
   CondWait ( handle, mutex )

Parameters
   handle
      The handle of a conditional variable.
   mutex
      The mutex associated with this conditional variable, which must be 
      locked when testing the condition and calling CondWait.

Description
   Function that stops the thread where it is called until some other 
   thread  CondSignals or CondBroadcasts  the handle.

   Once the conditional variable is created with CondCreate and the threads 
   are started, one of more of them (including the implicit main thread 
   executing main program) can be set to CondWait for the conditional; they 
   will be stopped until some other thread CondSignals that the waiting 
   thread can restart. CondBroadcast can be used to restart all threads 
   waiting for the conditional. At the end of the program CondDestroy must 
   be used to avoid leaking resources in the OS.

   When calling CondWait, mutex should already be locked (using the same 
   mutex as one used with CondSignal or CondBroadcast). An atomic unlock of 
   the mutex and wait on the conditional variable will occur. The calling 
   thread execution is suspended and does not consume any CPU time until 
   the condition variable is signaled. When the condition variable becomes 
   signaled, mutex will be locked again and then execution will return to 
   the thread after the CondWait call, but with the mutex owned by the 
   caller. The caller is then responsible for unlocking mutex in order to 
   complete CondWait subroutine so that execution after the CondWait call 
   can then resume.

   Note: It is a good habit to use CondWait in a protected way against 
   eventual spurious wakeups.
   For that, CondWait is put within a loop for checking that a Boolean 
   predicate is indeed true (predicate set true by another thread just 
   before executing CondSignal or CondBroadcast) when the thread has 
   finished waiting:
      While predicate <> true : Condwait(handle, mutex) : Wend [ : 
      predicate = false ]
      the loop can terminate only when the predicate is true.
   On the other hand, if the predicate is already true before the thread 
   reaches the loop, CondWait is downright skipped (allowing to take into 
   account a case of CondSignal or CondBroadcast that would have been lost 
   otherwise, because prematurely executed in a second thread before the 
   first thread is really waiting for this).
   See example below for detailed coding.

Example
   See also CondCreate and CondSignal

   ' This simple example code demonstrates the use of several condition variable routines.
   ' The main routine creates three threads.
   ' Two of the threads update a "count" variable.
   ' The third thread waits until the count variable reaches a specified value.

   #define numThread  3
   #define countThreshold 6

   Dim Shared As Integer count = 0
   Dim Shared As Any Ptr countMutex
   Dim Shared As Any Ptr countThresholdCV
   Dim As Any Ptr threadID(0 To numThread-1)
   Dim Shared As Integer ok = 0

   Sub threadCount (ByVal p As Any Ptr)
      Print "Starting threadCount(): thread#" & p
      Do
         Print "threadCount(): thread#" & p & ", locking mutex"
         MutexLock(countMutex)
         count += 1
         ' Check the value of count and signal waiting thread when condition is reached.
         ' Note that this occurs while mutex is locked.
         If count >= countThreshold Then
            If count = countThreshold Then
               Print "threadCount(): thread#" & p & ", count = " & count & ", threshold reached, unlocking mutex"
               ok = 1
               CondSignal(countThresholdCV)
            Else
               Print "threadCount(): thread#" & p & ", count = " & count & ", threshold exceeded, unlocking mutex"
            End If
            MutexUnlock(countMutex)
            Exit Do
         End If
         Print "threadCount(): thread#" & p & ", count = " & count & ", unlocking mutex"
         MutexUnlock(countMutex)
         Sleep 100, 1
      Loop
   End Sub

   Sub threadWatch (ByVal p As Any Ptr)
      Print "Starting threadWatch(): thread#" & p & ", locking mutex, waiting for conditional"
      MutexLock(countMutex)
      ' Note that the Condwait routine will automatically and atomically unlock mutex while it waits.
      While ok = 0
         CondWait(countThresholdCV, countMutex)
      Wend
      Print "threadWatch(): thread#" & p & ", condition signal received"
      Print "threadWatch(): thread#" & p & ", count now = " & count & ", unlocking mutex"
      MutexUnlock(countMutex)
   End Sub

   ' Create mutex and condition variable
   countMutex = MutexCreate
   countThresholdCV = CondCreate
   ' Create threads
   threadID(0) = ThreadCreate(@threadWatch, Cast(Any Ptr, 1))
   threadID(1) = ThreadCreate(@threadCount, Cast(Any Ptr, 2))
   threadID(2) = ThreadCreate(@threadCount, Cast(Any Ptr, 3))
   ' Wait for all threads to complete
   For I As Integer = 0 To numThread-1
      ThreadWait(threadID(I))
      Print "Main(): Waited on thread#" & I+1 & " Done"
   Next I
   MutexDestroy(countMutex)
   CondDestroy(countThresholdCV)

Platform Differences
   * Condwait is not available with the DOS version / target of FreeBASIC, 
     because multithreading is not supported by DOS kernel nor the used 
     extender.
   * In Linux the threads are always started in the order they are 
     created, this can't be assumed in Win32. It's an OS, not a FreeBASIC 
     issue. 

Dialect Differences
   * Threading is not allowed in -lang qb

Differences from QB
   * New to FreeBASIC

See also
   * CondCreate
   * CondDestroy
   * CondBroadcast
   * CondSignal
   * MutexCreate
   * MutexLock
   * MutexUnlock
   * ThreadCreate



------------------------------------------------------------ KeyPgConst ----
Const

Non-modifiable variable declaration.

Syntax
   Const symbolname1 [AS DataType] = value1 [, symbolname2 [AS DataType] = 
   value2, ...]
      or
   Const [AS DataType] symbolname1 = value1 [, symbolname2 = value2, ...]

Description
   Declares non-modifiable constant data that can be integer or decimal 
   (floating-point) numbers or strings. The constant type will be inferred 
   if DataType isn't explicitly given.

   Specifying String * Size, Zstring * Size or Wstring * Size as DataType 
   is not allowed.
   Specifying String as DataType is tolerated but without effect because 
   the resulting type is always a Zstring * Size.

   Constants follow visibility rules similar to those of variables for 
   Namespace blocks, Type blocks, and compound block statements.

Example
   Const Red = RGB(252, 2, 4)
   Const Black As UInteger = RGB(0, 0, 0)
   Const Text = "This is red text on a black bkgnd."

   Locate 1, 1
   Color Red, Black
   Print Text
   Sleep
   End

Differences from QB
   * QB does not support the As datatype syntax.

See also
   * #define
   * Const (Qualifier)
   * Const (Member)
   * Enum
   * Var



------------------------------------------------------ KeyPgConstMember ----
Const (Member)

Specifies that a member procedure is read only.

Syntax
   Type typename
      Declare Const Sub|Function|Property|Operator ...
   End Type

   [Const] Sub|Function|... typename ...
      ...
   End Sub|Function|...

Description
   Specifies that a method does not change the object it is called on. The 
   hidden This parameter will be considered read-only. The declaration can 
   be read as 'invoking a const method promises not to change the object', 
   and the compiler will error if the member procedure tries to change any 
   of the data fields, or calls a non-const member procedure. 

   Read-only (Const) declarations are a measure of type safety that can be 
   read as 'promises not to change.'  The compiler uses the const 
   declarations to check operations on variables and parameters and 
   generate an error at compile time if their data could potentially 
   change.  There is no runtime overhead for using Const qualifiers since 
   all of the checks are made at compile time.

   Constructors and destructors cannot be Const (not useful).
   Member procedures can not be both Const and Static since static member 
   procedures do not have a hidden This parameter.

   For methods with Const in their declaration, Const can also be specified 
   on the corresponding method bodies, for improved code readability.

Example
   '' Const Member Procedures

   Type foo
     x As Integer
     c As Const Integer = 0
     Declare Const Sub Inspect1()
     Declare Const Sub Inspect2()
     Declare Sub Mutate1()
     Declare Sub Mutate2()
   End Type

   ''
   Sub foo.Mutate1()
     '' we can change non-const data fields
     x = 1

     '' but we still can't change const data
     '' fields, they are promised not to change
     '' c = 1 '' Compile error

   End Sub

   ''
   Sub foo.Mutate2()
     '' we can call const members
     Inspect1()

     '' and non-const members
     Mutate1()

   End Sub

   ''
   Sub foo.Inspect1()
     '' can use data members
     Dim y As Integer
     y = c + x

     '' but not change them because Inspect1()
     '' is const and promises not to change foo
     '' x = 10 '' Compile error

   End Sub

   ''
   Sub foo.Inspect2()
     '' we can call const members
     Inspect1()

     '' but not non-const members
     '' Mutate1() '' Compile error

   End Sub

Differences from QB
   * New to FreeBASIC

See also
   * Const
   * Const (Qualifier)
   * Dim
   * Type



--------------------------------------------------- KeyPgConstQualifier ----
Const (Qualifier)

Specifies that a data type or pointer data type is read only.

Syntax
   ... As [Const] datatype [ [Const] Ptr ... ]

Parameters
   datatype
      Name of a standard or user defined data type.

Description
   Specifies that the datatype or Ptr immediately to the right of the Const 
   qualifier is to be considered as read only.  Read-only (Const) 
   declarations are a measure of type safety that can be read as 'promises 
   not to change.'  The compiler uses the const declarations to check 
   operations on variables and parameters and generate an error at compile 
   time if their data could potentially change.  There is no runtime 
   overhead for using Const qualifiers since all of the checks are made at 
   compile time.

   Const can be used anywhere data type declarations are made.  This 
   includes variables, parameters, function return results, user defined 
   type fields, type aliases, and casting.  The datatype can be any 
   built-in standard data type or user defined type.

   Read-only variables must have an initializer since modifying a read-only 
   variable through an assignment will generate a compiler error.  The 
   initializer may appear after the declaration of the variable.

   Both non-const and const variables may be passed to a procedure 
   expecting a const parameter.  However, a const variable may not be 
   passed to a procedure taking a non-const parameter, and will generate a 
   compile error.

   Procedures can be overloaded based on the const-ness of parameters.  For 
   example a procedure can be overloaded where one version of the procedure 
   takes a 'byref foo as bar' parameter and another version of the 
   procedure takes a 'byref foo as const bar' parameter.

   With pointer declarations, Const can be used to indicate which part of 
   the pointer declaration is read-only (all other parts are by default 
   read-write).  The read-only portion of the pointer data type could be 
   the pointer itself (the address), what the pointer points to (the data), 
   or both.  In a declaration with more than one level of Ptr indirection, 
   the right most Ptr indicates the highest order level of indirection and 
   is therefore dereferenced first.

   The compiler has an internal hard-limit of eight (8) levels of pointer 
   indirection with respect to const qualifiers and the behavior of using 
   Const with Ptr data types having greater than eight (8) levels of 
   indirection is undefined.

Example
   '' Const Variables

   '' procedure taking a const parameter
   Sub proc1( ByRef x As Const Integer )

     '' can't change x because it is const
     '' x = 10 '' compile error

     '' but we can use it in expressions and
     '' assign it to other variables
     Dim y As Integer
     y = x
     y = y * x + x

   End Sub

   '' procedure taking a non-const parameter
   Sub proc2( ByRef x As Integer )
     '' we can change the value
     x = 10
   End Sub

   '' declare a non-const and const variable
   Dim a As Integer
   Dim b As Const Integer = 5

   '' proc1() will accept a non-const or const
   '' argument because proc1() promises not to
   '' change the variable passed to it.
   proc1( a )
   proc1( b )

   '' proc2() will accept a non-const argument
   proc2( a )

   '' but not a const argument because proc2()
   '' might change the variable's data and we
   '' promised that 'b' would not change.
   '' proc2( b ) '' compile error

   '' Const Pointers

   '' an integer
   Dim x As Integer = 1
   Dim y As Integer = 2
   Dim z As Integer = 3

   '' To check that the compiler generates errors
   '' when attempting to reassign const variables,
   '' uncomment the assignments below.

   ''
   Scope
     '' a pointer to an integer
     Dim p As Integer Ptr = @x

     p = @y       /' OK - pointer can be changed '/
     *p = z       /' OK - data can be changed '/

   End Scope

   ''
   Scope
     '' a pointer to a constant integer
     Dim p As Const Integer Ptr = @x

     p = @y       /' OK - pointer can be changed '/
     '' *p = z    /' Error - data is const '/

   End Scope

   ''
   Scope
     '' a constant pointer to an integer
     Dim p As Integer Const Ptr = @x

     '' p = @y    /' Error - pointer is const '/
     *p = z       /' OK - data can be changed '/

   End Scope

   ''
   Scope
     '' a constant pointer to a constant integer
     Dim p As Const Integer Const Ptr = @x

     '' p = @y    /' Error - pointer is const '/
     '' *p = z    /' Error - data is const '/

   End Scope

   '' Const Parameters in an Overloaded Procedure

   '' procedure with non-const parameter
   Sub foo Overload( ByRef n As Integer )
     Print "called 'foo( byref n as integer )'"
   End Sub

   '' procedure with const parameter
   Sub foo Overload( ByRef n As Const Integer )
     Print "called 'foo( byref n as const integer )'"
   End Sub

   Dim x As Integer = 1
   Dim y As Const Integer = 2

   foo( x )
   foo( y )

   '' OUTPUT:
   '' called 'foo( byref n as integer )'
   '' called 'foo( byref n as const integer )'

Differences from QB
   * New to FreeBASIC

See also
   * Const
   * Const (Member)
   * Dim
   * Type



------------------------------------------------------ KeyPgConstructor ----
Constructor

Called automatically when a class or user defined type is created

Syntax
   Type typename
      Declare Constructor ( )
      Declare Constructor ( [ ByRef | ByVal ] parameter As datatype [ = 
      default ] [, ... ] )
   End Type

   Constructor typename ( [ parameters ] ) [ Export ]
      statements
   End Constructor

Parameters
   typename 
      name of the Type or Class

Description
   Constructor methods are called when a user defined Type or Class 
   variable is created.

   typename is the name of the type for which the Constructor method is 
   declared and defined.  Name resolution for typename follows the same 
   rules as procedures when used in a Namespace.

   More than one constructor may exist for a type or class.  The exact 
   constructor method called depends on the parameter signature matched 
   when the variable is initialized.  More than one parameter may exist in 
   a constructor method declaration.

   A constructor method is passed a hidden This parameter having the same 
   type as typename.  This is optionally used to access the fields of the 
   Type or Class which is to be initialized in the Constructor method.

   Constructors are called when declaring global or local static instances 
   of typename and when allocating typename dynamically using the 
   New Expression operator. See examples below for different constructor 
   syntaxes.

   A copy Constructor is a special constructor that initializes a new 
   object from an existing object. There are three general cases where the 
   copy Constructor is called: when instantiating one object and 
   initializing it with another object (in one instruction), when passing 
   an object by value, when an object is returned from a function by value 
   (by using Return x statement).
      Note: When an object is returned from a function by value, but by 
      using Function = x (or function_identifier = x) assignment, the 
      Constructor is called once at first, and then the Let (Assign) 
      operator at each assignment.
   A copy Constructor must be defined if the shallow implicit copy 
   constructor is not sufficient. This happens in cases when the object 
   manages dynamically allocated memory or other resources which need to be 
   specially constructed or copied (for example if a member pointer points 
   to dynamically allocated memory, the implicit copy constructor will 
   simply do an implicit pointer construction and a copy of value instead 
   of allocate memory and then perform the copy of data).
      Note: Even if is defined an explicit default Constructor, it is never 
      called by the implicit copy constructor.

   Chaining of constructors in nested types is supported.  Any fields that 
   have their own default constructor are called first.
   Chaining together constructors of a same type is allowed by using the 
   keyword Constructor(parameters) at the top of constructor. It prevents 
   the compiler from emitting field initialization code (instead, it relies 
   on the chained constructor to initialize everything).

   Constructor can be also called directly from the typename instance like 
   the other member methods (Sub) and with the same syntax, i.e. using a 
   member access operator, e.g. obj.Constructor(parameters). In particular, 
   doing this.Constructor(parameters) is not treated as chaining together 
   constructors of a same type, and it is allowed anywhere (not only at the 
   top of constructors). In general it's not safe to manually call the 
   constructor on an object, because no Destructor is called, and the old 
   object state - if any - is overwritten without any of its old members 
   being destroyed, which could cause memory/resource leaks.

Example
Simple constructor example for beginners.
   Type MyObj
     Foo As Integer Ptr
     
      '' Constructor to create our integer, and set its value.
     Declare Constructor( ByVal DefVal As Integer = 0 )
      '' Destroy our integer on object deletion.
     Declare Destructor()
   End Type

   Constructor MyObj( ByVal DefVal As Integer = 0 )
     Print "Creating a new integer in MyObj!"
     Print "The Integer will have the value of: " & DefVal
     Print ""
     
      '' Create a pointer, and set its value to the one passed to the
      '' Constructor.
     This.Foo = New Integer
     *This.Foo = DefVal
   End Constructor

   Destructor MyObj()
     Print "Deleting our Integer in MyObj!"
     Print ""
     
      '' Delete the pointer we created in MyObj.
     Delete This.Foo
     This.Foo = 0
   End Destructor

   Scope
      '' Create a MyObj type object
      '' Send the value of '10' to the constructor
     Dim As MyObj Bar = 10
     
      '' See if the integer's been created.  Print its value.
     Print "The Value of our integer is: " & *Bar.Foo
     Print ""
     
     Sleep
   End Scope
     '' We've just gone out of a scope.  The Destructor should be called now
     '' Because our objects are being deleted.
   Sleep

More advanced construction example, showing constructor overloading among 
other things.
   Type sample

     _text As String

     Declare Constructor ()
     Declare Constructor ( a As Integer )
     Declare Constructor ( a As Single  ) 
     Declare Constructor ( a As String, b As Byte ) 

     Declare Operator Cast () As String

   End Type

   Constructor sample ()
     Print "constructor sample ()"
     Print
     this._text = "Empty"
   End Constructor

   Constructor sample ( a As Integer )
     Print "constructor sample ( a as integer )"
     Print "  a = "; a
     Print
     this._text = Str(a)
   End Constructor

   Constructor sample ( a As Single )
     Print "constructor sample ( a as single )"
     Print "  a = "; a
     Print
     this._text = Str(a)
   End Constructor

   Constructor sample ( a As String, b As Byte )
     Print "constructor sample ( a as string, b as byte )"
     Print "  a = "; a
     Print "  b = "; b
     Print
     this._text = Str(a) + "," + Str(b)
   End Constructor

   Operator sample.cast () As String
     Return this._text
   End Operator

   Print "Creating x1"
   Dim x1 As sample

   Print "Creating x2"
   Dim x2 As sample = 1

   Print "Creating x3"
   Dim x3 As sample = 99.9

   Print "Creating x4"
   Dim x4 As sample = sample( "aaa", 1 )

   Print "Values:"
   Print "  x1 = "; x1
   Print "  x2 = "; x2
   Print "  x3 = "; x3
   Print "  x4 = "; x4

Example of copy constructor.
   Type UDT
     Dim As String Ptr p                     ''pointer to string
     Declare Constructor ()                  ''default constructor
     Declare Constructor (ByRef rhs As UDT)  ''copy constructor
     Declare Destructor ()                   ''destructor
   End Type

   Constructor UDT ()
     This.p = CAllocate(1, SizeOf(String))
   End Constructor

   Constructor UDT (ByRef rhs As UDT)
     This.p = CAllocate(1, SizeOf(String))
     *This.p = *rhs.p
   End Constructor

   Destructor UDT ()
     *This.p = ""
     Deallocate This.p
   End Destructor

   Dim As UDT u0
   *u0.p = "copy constructor exists"
   Dim As UDT u = u0
   *u0.p = ""  ''to check the independance of the result copy with the object copied
   Print *u.p
   Sleep

Dialect Differences
   * Object-related features are supported only in the -lang fb option

Differences from QB
   * New to FreeBASIC

See also
   * Class
   * Constructor (Module)
   * New Expression
   * Destructor
   * Type
   * Coercion and Conversion



------------------------------------------------ KeyPgModuleConstructor ----
Constructor (Module)

Specifies execution of a procedure before module-level code

Syntax
   [Public | Private] Sub procedure_name [Alias "external_identifier"] [()] 
   Constructor [priority] [Static]
      { procedure body }
   End Sub

Description
   The Constructor keyword is used in Sub definitions (forbidden at 
   declaration line level) to force execution of the procedure prior to 
   that of module-level code. Procedures defined as constructors may be 
   used the same way as ordinary procedures, that is, they may be called 
   from within module-level code, as well as other procedures.

   The procedure must have an empty parameter list.  A compile-time error 
   will be generated if the Constructor keyword is used in a Sub definition 
   having one or more parameters. In a set of overloaded procedures, only 
   one (1) constructor may be defined because of the ambiguity of having 
   multiple Subs which take no arguments.

   In a single module, depending on the build and run-time environment of 
   the target system:
      * constructors may execute in which they are defined, or reverse 
        order
      * constructors may execute before or after global static variables 
        having constructors
      * constructors may execute before or after other module constructors 
        having priority attribute
      * constructors with priority attribute may execute before or after 
        global static variables having constructors

   The priority attribute, an integer between 101 and 65535, can be used to 
   force constructors to be executed in a certain order, relative to other 
   constructors also having priority attribute.  The value of priority has 
   no specific meaning, only the relationship of the number with other 
   constructor priorities.  101 is the highest priority and is executed 
   first, relative to other constructors also having priority attribute.

   A module may define multiple constructor procedures, and multiple 
   modules may define additional constructors provided no two Public 
   constructors share the same procedure_name.

   When linking with modules that also define constructors, the order of 
   execution is not guaranteed at link-time unless the priority attribute 
   is used. Therefore, special care should be taken when using constructors 
   that may call on a secondary module also defining a constructor.  In 
   such a case it is advisable to use a single constructor that explicitly 
   calls initialization procedures in those modules.

   Public static member procedures (a Sub having an empty parameter list), 
   of user defined Type can be defined as a module constructor, by adding 
   the Constructor keyword used in the sub procedure definition.

   Initialization of static simple numeric type variables, that have a 
   value that can be determined at compile time (for example, default zero, 
   constants, pointers to static objects, pointers to functions, etc), are 
   initialized before any code is executed.  These values are part of the 
   executable image and have an initial value when the executable is loaded 
   in to memory.  Trivial static globals where no code is needed to 
   initialize, are guaranteed to be initialized and can be reliably used in 
   all code, including global static object constructors and module 
   constructors.

   The module constructor feature exposes a low-level link-time feature of 
   the build and run-time environment.  Accessing global static objects 
   having constructors from module constructors should be avoided due to 
   variations in execution order on different build systems.

   Warning for 64-bit compiler only: See the Identifier Rules page for the 
   choice of user procedure identifier names (and specially the 'Platform 
   Differences' paragraph).

Example
   '' ConDesExample.bas : An example program that defines two sets of
   '' constructors and destructors. Demonstrates when and in what order
   '' they are called when linking a single module.

   Sub Constructor1() Constructor
      Print "Constructor1() called"
   End Sub

   Sub Destructor1() Destructor
      Print "Destructor1() called"
   End Sub

   Sub Constructor2() Constructor
      Print "Constructor2() called"
   End Sub

   Sub Destructor2() Destructor
      Print "Destructor2() called"
   End Sub

      '' ----------------------
      Print "module-level code"

      End 0
      '' ----------------------

   Output:

   Constructor2() called
   Constructor1() called
   module-level code
   Destructor1() called
   Destructor2() called

Differences from QB
   * New to FreeBASIC

See also
   * Constructor (Class)
   * Destructor (Module)
   * Sub



--------------------------------------------------------- KeyPgContinue ----
Continue

Control flow statement to continue next iteration of a loop

Syntax
   Continue {Do | For | While}

Description
   Skips all code until the end clause of a loop structure, i.e. Do...Loop, 
   For...Next, or a While...Wend block, then executes the limit condition 
   check. In the case of a For...Next, the variable is incremented 
   according to the Step specified.

   Where there are multiple Do / For / While blocks nested, it will 
   continue on the innermost block of that type, i.e. the last one entered. 
   You can continue an earlier block of that type by giving the word 
   multiple times, separated by commas.  e.g. continue while, while

Example
   Dim As Integer n

   Print "Here are odd numbers between 0 and 10!"
   Print
   For n = 0 To 10

     If ( n Mod 2 ) = 0 Then 
      Continue For
     End If
     
     Print n
     
   Next n

    '' simple prime number finder

   Print "Here are the prime numbers between 1 and 20!"
   Print

   Dim n As Integer, d As Integer

   For n = 2 To 20
      
      For d = 2 To Int(Sqr(n))
         
         If ( n Mod d ) = 0 Then ' d divides n
            
            Continue For, For ' n is not prime, so try next n
            
         End If
         
      Next d
      
      Print n
      
   Next n

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Continue.

Differences from QB
   * New to FreeBASIC

See also
   * Exit



-------------------------------------------------------------- KeyPgCos ----
Cos

Returns the cosine of an angle

Syntax
   Declare Function Cos ( ByVal angle As Double ) As Double

Usage
   result = Cos( angle )

Parameters
   angle
      the angle (in radians)

Return Value
   Returns the cosine of the argument angle as a Double within the range of 
   -1.0 to 1.0.

Description
   The argument number is measured in radians (not degrees).

   The value returned by this function is undefined for values of angle 
   with an absolute value of 2 ^ 63 or greater.

   Cos can be overloaded as operator to accept user-defined types.

Example
   Const PI As Double = 3.1415926535897932
   Dim a As Double
   Dim r As Double
   Input "Please enter an angle in degrees: ", a
   r = a * PI / 180   'Convert the degrees to Radians
   Print ""
   Print "The cosine of a" ; a; " degree angle is"; Cos ( r ) 
   Sleep

Output:

   Please enter an angle in degrees: 30
   The cosine of a 30 degree angle Is 0.8660254037844387

Differences from QB
   * None

See also
   * Acos
   * Sin
   * Tan
   * A Brief Introduction To Trigonometry



------------------------------------------------------------- KeyPgCptr ----
CPtr

Converts a pointer expression to a specified data type pointer

Syntax
   CPtr( PointerDataType, expression )

Description
   Converts expression to PointerDataType.

   PointerDataType must be a Pointer type (e.g. a DataType Ptr or an Any Ptr
   ), or a Type (Alias) to one.
   expression may have a different pointer type or be an Integer.

   Note: Currently, FB does not actually enforce that PointerDataType must 
   be a pointer.  This will likely change in future versions though.  
   Currently, it may display a warning if you try to convert to a 
   non-pointer (for any conversion type if you compile with the -w pedantic 
   compiler switch).

Example
   Dim intval As Integer
   Dim intptr As Integer Ptr
   intval = &h0080
   intptr = @intval
   '' will print -128 and 128, as the first expression will be "seen" as an signed byte
   Print *CPtr( Byte Ptr, intptr ), *intptr

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Cptr.

Differences from QB
   * New to FreeBASIC

See also
   * Ptr
   * Cast
   * CByte
   * CShort
   * CInt
   * CLngInt
   * CSng
   * CDbl 



----------------------------------------------------------- KeyPgCshort ----
CShort

Converts numeric or string expression to an integer (Short)

Syntax
   Declare Function CShort ( ByVal expression As datatype ) As Short

   Type typename
      Declare Operator Cast ( ) As Short
   End Type

Usage
   result = CShort( numeric expression )
   result = CShort( string expression )
   result = CShort( user defined type )

Parameters
   expression
      a numeric, string, or pointer expression to cast to a Short value
   datatype
      any numeric, string, or pointer data type
   typename
      a user defined type

Return Value
   A Short value.

Description
   The CShort function rounds off the decimal part and returns a 16-bit 
   Short value.  The function does not check for an overflow, and results 
   are undefined for values which are less than -32 768 or larger than 32 
   767.

   The name can be explained as 'Convert to Short'.

   If the argument is a string expression, it is converted to numeric by 
   using ValInt.

Example
   ' Using the CSHORT function to convert a numeric value

   'Create an SHORT variable
   Dim numeric_value As Short

   'Convert a numeric value
   numeric_value = CShort(-4500.66)

   'Print the result, should return -4501
   Print numeric_value
   Sleep

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Cshort.

Differences from QB
   * New to FreeBASIC

See also
   * CByte
   * CUByte
   * CUShort
   * CInt
   * CUInt
   * CLng
   * CULng
   * CLngInt
   * CULngInt
   * CSng
   * CDbl



------------------------------------------------------------ KeyPgCsign ----
CSign

Converts an expression to signed

Syntax
   CSign ( expression )

Usage
   variable = CSign ( expression )

Description
   Converts an unsigned expression to a signed one, useful to force signed 
   behavior of division or multiplication (including with Shl and Shr).

   This is the opposite of CUnsg.

Example
   Dim value As UShort = 65535
   Print CSign(value)  '' will print -1

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Csign.

Differences from QB
   * New to FreeBASIC

See also
   * CUnsg



------------------------------------------------------------- KeyPgCsng ----
CSng

Converts numeric or string expression to Single precision floating point

Syntax
   Declare Function CSng ( ByVal expression As datatype ) As Single

   Type typename
      Declare Operator Cast ( ) As Single
   End Type

Usage
   result = CSng( numeric expression )
   result = CSng( string expression )
   result = CSng( user defined type )

Parameters
   expression
      a numeric, string, or pointer expression to cast to a Single value
   datatype
      any numeric, string, or pointer data type
   typename
      a user defined type

Return Value
   A Single precision value.

Description
   The CSng function returns a 32-bit Single value. The function does not 
   check for an overflow, so be sure not to pass a value outside the 
   representable range of the Single data type. The name can be explained 
   as 'Convert to SiNGle'.

   If the argument to CSng is a string expression, it is first converted to 
   numeric by using Val.

Example
   ' Using the CSNG function to convert a numeric value

   'Create an SINGLE variable
   Dim numeric_value As Single

   'Convert a numeric value
   numeric_value = CSng(-12345.123)

   'Print the result, should return -12345.123
   Print numeric_value
   Sleep

Differences from QB
   * The string argument was not allowed in QB

See also
   * CByte
   * CUByte
   * CShort
   * CUShort
   * CInt
   * CUInt
   * CLng
   * CULng
   * CLngInt
   * CULngInt
   * CDbl



----------------------------------------------------------- KeyPgCsrlin ----
CsrLin

Returns the row position of the cursor

Syntax
   Declare Function CsrLin ( ) As Integer

Usage
   result = CsrLin

Return Value
   An Integer specifying the current row of the cursor.

Description
   Returns the current row the cursor is on (i.e. the "cursor line").  The 
   topmost row is number 1.

Example
   Print "The cursor is on row:"; CsrLin

Differences from QB
   * None

See also
   * Locate
   * Pos



----------------------------------------------------------- KeyPgCubyte ----
CUByte

Converts numeric or string expression to an unsigned byte (UByte)

Syntax
   Declare Function CUByte ( ByVal expression As datatype ) As UByte

   Type typename
      Declare Operator Cast ( ) As UByte
   End Type

Usage
   result = CUByte( numeric expression )
   result = CUByte( string expression )
   result = CUByte( user defined type )

Parameters
   expression
      a numeric, string, or pointer expression to cast to a UByte value
   datatype
      any numeric, string, or pointer data type
   typename
      a user defined type

Return Value
   A UByte value.

Description
   The CUByte function rounds off the decimal part and returns a 8-bit UByte
   value. The function does not check for an overflow, and results are 
   undefined for values which are less than 0 or larger than 255.

   The name can be explained as 'Convert to Unsigned Byte'.

   If the argument is a string expression, it is converted to numeric by 
   using ValUInt.

Example
   ' Using the CUBYTE function to convert a numeric value

   'Create an UNSIGNED BYTE variable
   Dim numeric_value As UByte

   'Convert a numeric value
   numeric_value = CUByte(123.55)

   'Print the result, should return 124
   Print numeric_value
   Sleep

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Cubyte.

Differences from QB
   * New to FreeBASIC

See also
   * CByte
   * CShort
   * CUShort
   * CInt
   * CUInt
   * CLng
   * CULng
   * CLngInt
   * CULngInt
   * CSng
   * CDbl



------------------------------------------------------------ KeyPgCuint ----
CUInt

Converts numeric or string expression to a UInteger or UInteger<bits>

Syntax
   Declare Function CUInt ( ByVal expression As datatype ) As UInteger
   Declare Function CUInt<bits> ( ByVal expression As datatype ) As UInteger
   <bits>

   Type typename
      Declare Operator Cast ( ) As UInteger
      Declare Operator Cast ( ) As UInteger<bits>
   End Type

Usage
   result = CUInt( numeric expression )
   result = CUInt( string expression )
   result = CUInt( user defined type )

Parameters
   bits
      A numeric constant expression indicating the size in bits of unsigned 
      integer desired.  The values allowed are 8, 16, 32 or 64.
   expression
      a numeric, string, or pointer expression to cast to a UInteger or 
      UInteger<bits> value
   datatype
      any numeric, string, or pointer data type
   typename
      a user defined type

Return Value
   A UInteger or UInteger<bits> containing the converted value.

Description
   The CUInt function rounds off the decimal part and returns a UInteger 
   value, or if a bits value is supplied, an unsigned integer type of the 
   given size.

   The function does not check for an overflow; for example, for a 32-bit 
   UInteger results are undefined for values which are less than 0 or 
   larger than 4 294 967 296.

   The name can be explained as 'Convert to Unsigned INTeger'.

   If the argument is a string expression, it is converted to numeric by 
   using ValUInt or ValULng, depending on the size of the result type.

Example
   ' Using the CUINT function to convert a numeric value

   'Create an UNSIGNED INTEGER variable
   Dim numeric_value As UInteger

   'Convert a numeric value
   numeric_value = CUInt(300.23)

   'Print the result = 300
   Print numeric_value

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Cuint.

Differences from QB
   * New to FreeBASIC

See also
   * CByte
   * CUByte
   * CShort
   * CUShort
   * CInt
   * CLng
   * CULng
   * CLngInt
   * CULngInt
   * CSng
   * CDbl
   * UInteger



------------------------------------------------------------ KeyPgCulng ----
CULng

Converts numeric or string expression to ULong

Syntax
   Declare Function CULng ( ByVal expression As datatype ) As ULong

   Type typename
      Declare Operator Cast ( ) As ULong
   End Type

Usage
   result = CULng( numeric expression )
   result = CULng( string expression )
   result = CULng( user defined type )

Parameters
   expression
      a numeric, string, or pointer expression to cast to a ULong value
   datatype
      any numeric, string, or pointer data type
   typename
      a user defined type

Return Value
   A ULong value.

Description
   The CULng function rounds off the decimal part and returns a 32 bit ULong
   value. The function does not check for an overflow. The name can be 
   explained as 'Convert to Unsigned LoNG'.

   If the argument is a string expression, it is converted to numeric by 
   using ValUInt or ValULng.

Example
   ' Using the CULNG function to convert a numeric value

   'Create an UNSIGNED LONG variable
   Dim numeric_value As ULong

   'Convert a numeric value
   numeric_value = CULng(300.23)

   'Print the result = 300
   Print numeric_value
   Sleep

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Culng.

Differences from QB
   * New to FreeBASIC

See also
   * CByte
   * CUByte
   * CShort
   * CUShort
   * CInt
   * CUInt
   * CLng
   * CLngInt
   * CULngInt
   * CSng
   * CDbl



--------------------------------------------------------- KeyPgCulngint ----
CULngInt

Converts numeric or string expression to 64-bit unsigned integer (ULongInt)

Syntax
   Declare Function CULngInt ( ByVal expression As datatype ) As ULongInt

   Type typename
      Declare Operator Cast ( ) As ULongInt
   End Type

Usage
   result = CULngInt( numeric expression )
   result = CULngInt( string expression )
   result = CULngInt( user defined type )

Parameters
   expression
      a numeric, string, or pointer expression to cast to a ULongInt value
   datatype
      any numeric, string, or pointer data type
   typename
      a user defined type

Return Value
   A ULongInt value.

Description
   The CULngInt function rounds off the decimal part and returns a 64-bit 
   ULongInt value.  The function does not check for an overflow, and 
   results are undefined for values which are less than 0 or larger than 18 
   446 744 073 709 551 615.  Additionally, casts from floating-point 
   expressions are currently not guaranteed to work for values higher than 
   2^63 (9 223 372 036 854 775 808).

   The name can be explained as 'Convert to Unsigned LoNG INTeger'.

   If the argument is a string expression, it is converted to numeric by 
   using ValULng.

Example
   ' Using the CLNGINT function to convert a numeric value

   'Create an UNSIGNED LONG INTEGER variable
   Dim numeric_value As ULongInt

   'Convert a numeric value
   numeric_value = CULngInt(12345678.123)

   'Print the result, should return 12345678
   Print numeric_value
   Sleep

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Culngint.

Differences from QB
   * New to FreeBASIC

See also
   * CByte
   * CUByte
   * CShort
   * CUShort
   * CInt
   * CUInt
   * CLng
   * CULng
   * CLngInt
   * CSng
   * CDbl



------------------------------------------------------------ KeyPgCunsg ----
CUnsg

Converts an expression to unsigned

Syntax
   CUnsg ( expression )

Usage
   variable = CUnsg ( expression )

   Converts a signed expression to an unsigned one, useful to force 
   unsigned behavior of division or multiplication (including with Shl and 
   Shr).

   This is the opposite of CSign.

Example
   Dim value As Short = -1
   Print CUnsg(value)  '' will print 65535

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Cunsg.

Differences from QB
   * New to FreeBASIC

See also
   * CSign



----------------------------------------------------------- KeyPgCurdir ----
CurDir

Returns the current directory/folder

Syntax
   Declare Function CurDir ( ) As String

Usage
   result = CurDir

Return Value
   A String which is set to the name of the current directory/folder.

Description
   Returns the current directory/folder.

Example
   Print CurDir

   output will vary.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Curdir.

Differences from QB
   * New to FreeBASIC

See also
   * Open
   * Dir
   * ChDir
   * MkDir
   * RmDir



---------------------------------------------------------- KeyPgCushort ----
CUShort

Converts numeric or string expression to an unsigned integer (UShort)

Syntax
   Declare Function CUShort ( ByVal expression As datatype ) As UShort

   Type typename
      Declare Operator Cast ( ) As UShort
   End Type

Usage
   result = CUShort( numeric expression )
   result = CUShort( string expression )
   result = CUShort( user defined type )

Parameters
   expression
      a numeric, string, or pointer expression to cast to a UShort value
   datatype
      any numeric, string, or pointer data type
   typename
      a user defined type

Return Value
   A UShort value.

Description
   The CUShort function rounds off the decimal part and returns a 16-bit 
   UShort value.  The function does not check for an overflow, and results 
   are undefined for values which are less than 0 or larger than 65 535.

   The name can be explained as 'Convert to Unsigned Short'.

   If the argument is a string expression, it is converted to numeric by 
   using ValUInt.

Example
   ' Using the CUSHORT function to convert a numeric value

   'Create an USHORT variable
   Dim numeric_value As UShort

   'Convert a numeric value
   numeric_value = CUShort(36000.4)

   'Print the result, should return 36000
   Print numeric_value
   Sleep

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Cushort.

Differences from QB
   * New to FreeBASIC

See also
   * CByte
   * CUByte
   * CShort
   * CInt
   * CUInt
   * CLng
   * CULng
   * CLngInt
   * CULngInt
   * CSng
   * CDbl



-------------------------------------------------------- KeyPgCustomgfx ----
Custom

Parameter to the Put graphics statement which selects a custom method

Syntax
   Put [ target, ] [ STEP ] ( x,y ), source [ ,( x1,y1 )-( x2,y2 ) ], 
   Custom, custom_function_ptr [, parameter]

Parameters
   Custom
      Required.
   custom_function_ptr
      name of the custom user defined function.
   parameter
      optional Pointer to be passed to the custom function; if omitted, the 
      default value is zero (0).

Description
   Custom selects a custom user defined function as the method for blitting 
   an image buffer.

   The Custom method uses a user-defined function to calculate the final 
   pixel values to be drawn to the destination buffer. This function will 
   be called once for every pixel of the source image, and will receive the 
   source and destination pixel values, and a data pointer passed by the Put
   function. The pixel value returned will be the value used to draw to the 
   destination buffer. The function has the form:

   Declare Function identifier ( _
      ByVal source_pixel As ULong, _
      ByVal destination_pixel As ULong, _
      ByVal parameter As Any Ptr _
      ) As ULong

   identifier is the name of the function.
   source_pixel is the current pixel value of the source image.
   destination_pixel is the current pixel value of the destination image.
   parameter is the parameter that is passed by the Put command.  If it was 
   omitted, its value will be zero.

Example
   Function dither ( ByVal source_pixel As ULong, ByVal destination_pixel As ULong, ByVal parameter As Any Ptr ) As ULong
      
      ''either returns the source pixel or the destination pixel, depending on the outcome of rnd
      
      Dim threshold As Single = 0.5
      If parameter <> 0 Then threshold = *CPtr(Single Ptr, parameter)
      
      If Rnd() < threshold Then
         Return source_pixel
      Else
         Return destination_pixel
      End If
      
   End Function

   Dim img As Any Ptr, threshold As Single

   '' set up a screen
   ScreenRes 320, 200, 16, 2
   ScreenSet 0, 1

   '' create an image
   img = ImageCreate(32, 32)
   Line img, ( 0,  0)-(15,  15), RGB(255,   0,   0), bf
   Line img, (16,  0)-(31,  15), RGB(  0,   0, 255), bf
   Line img, ( 0, 16)-(15,  31), RGB(  0, 255,   0), bf
   Line img, (16, 16)-(31,  31), RGB(255,   0, 255), bf

   '' dither the image with varying thresholds
   Do Until Len(Inkey)
      
      Cls
      
      threshold = 0.2
      Put ( 80 - 16, 100 - 16), img, Custom, @dither, @threshold
      
      '' default threshold = 0.5
      Put (160 - 16, 100 - 16), img, Custom, @dither
      
      threshold = 0.8
      Put (240 - 16, 100 - 16), img, Custom, @dither, @threshold
      
      ScreenCopy
      Sleep 25
      
   Loop

   '' free the image memory
   ImageDestroy img

Dialect Differences
   * Not available in the -lang qb dialect.

Differences from QB
   * New to FreeBASIC

See also
   * Put (Graphics)



----------------------------------------------------------- KeyPgCvaArg ----
Cva_Arg

Macro to obtain the next argument from a variadic argument list object.

Syntax
   variable = Cva_Arg ( argument_list, datatype )

Parameters
   argument_list
      Cva_List data type variable to access for next value
   datatype
      The datatype of the next value in the variable argument list 
      argument_list

Description
   The Cva_Arg macro allows the use of a variable number of arguments 
   within a function:
      * 	Cva_Arg returns the current argument in the list, argument_list, 
        with an expected data type of datatype.
      * 	Before first Cva_Arg use, argument_list must be initialized with 
        the command Cva_Start or Cva_Copy.
      * 	Cva_Arg automatically increments argument_list to the next 
        argument within the list after obtaining the value of the current 
        argument.

Example
   '' Example of a simple custom printf
   Sub myprintf cdecl(ByRef formatstring As String, ...)
      Dim As Cva_List args

      '' Initialize the cva_list object to first var-arg
      Cva_Start( args, formatstring )

      '' For each char in format string...
      Dim As UByte Ptr p = StrPtr(formatstring)
      Dim As Integer todo = Len(formatstring)
      While (todo > 0)
         Dim As Integer char = *p
         p += 1
         todo -= 1

         '' Is it a format char?
         If (char = Asc("%")) Then
            If (todo = 0) Then
               '' % at the end
               Print "%";
               Exit While
            End If

            '' The next char should tell the type
            char = *p
            p += 1
            todo -= 1

            '' Print var-arg, depending on the type
            Select Case char
            '' integer?
            Case Asc("i")
               Print Str(Cva_Arg(args, Integer));

            '' long integer? (64-bit)
            Case Asc("l")
               Print Str(Cva_Arg(args, LongInt));

            '' single or double?
            '' Note: because the C ABI, all singles passed on
            '' var-args are converted to doubles.
            Case Asc( "f" ), Asc( "d" )
               Print Str(Cva_Arg(args, Double));

            '' string?
            Case Asc("s")
               '' Strings are passed byval, so the length is unknown
               Print *Cva_Arg(args, ZString Ptr);

            End Select

         '' Ordinary char, just print as-is
         Else
            Print Chr( char );
         End If
      Wend

      Cva_End( args )

   End Sub

   Dim As String s = "bar"

   myprintf(!"integer=%i, longint=%l single=%f, double=%d, string=%s, string=%s\n", _
          1, 1ll Shl 32, 2.2, 3.3, "foo", s)

Version
   * Since fbc 1.07.0

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __cva_arg.

Differences from QB
   * New to FreeBASIC

See also
   * ... (Ellipsis)
   * Cva_Copy
   * Cva_End
   * Cva_List
   * Cva_Start



---------------------------------------------------------- KeyPgCvaCopy ----
Cva_Copy

Macro to initialize variadic argument list object variable from an already 
initialized variadic argument list object variable

Syntax
   Cva_Copy( dst_list, src_list )

Parameters
   dst_list
      destination Cva_List variable to initialize
   src_list
      source Cva_List variable to copy from

Description
   Copies one Cva_List type variable to another Cva_List type variable.  
   dst_list is initialized using current state of src_list

   src_list must already have been initialized with a previous Cva_Start or 
   Cva_Copy statement.

   Cva_Copy is like a copy constructor for the a variadic argument list 
   object and must eventually have a matching call to Cva_End, which is 
   like the destructor.  After Cva_End for dst_list has been called, 
   dst_list can be reused and reinitialized with another call to Cva_Start 
   or Cva_Copy.  The Cva_Copy and Cva_End calls must both be called in the 
   same procedure (for cross platform compatibility).

Example
   '' example of using cva_copy to create
   '' a copy of the variable argument list

   Sub proc cdecl(count As Integer, ... )
      Dim args1 As Cva_List
      Dim args2 As Cva_List

      '' first list
      Cva_Start( args1, count )

      '' create a copy
      Cva_Copy( args2, args1 )

      For i As Integer = 1 To count
         Print Cva_Arg( args1, Integer ), Cva_Arg( args2, Integer )
      Next
      
      '' clean-up
      Cva_End( args2 )
      Cva_End( args1 )

   End Sub

   proc( 4, 4000, 300, 20, 1 )

   '' example of using cva_copy to create
   '' a copy of the variable argument list
   '' and pass it to another procedure

   Sub vproc cdecl(count As Integer, ByRef args As Cva_List )

      '' if we don't know that caller made a copy
      '' of args, it is safe to make our own copy
      '' and leave the passed in args untouched

      Dim a As Cva_List
      Cva_Copy( a, args )

      Print "vproc"
      For i As Integer = 1 To count
         Print Cva_Arg( a, Integer )
      Next
      
      '' clean-up
      Cva_End( a )

   End Sub

   Sub proc cdecl(count As Integer, ... )

      Dim args As Cva_List
      Cva_Start( args, count )

      '' if don't know that the called procedure
      '' will make it's own copy, it is safe to
      '' make a copy here and pass that instead

      Dim tmp As Cva_List
      Cva_Copy( tmp, args )
      vproc( count, tmp )
      Cva_End( tmp )

      '' args is still valid, we can use it
      Print "proc"
      For i As Integer = 1 To count
         Print Cva_Arg( args, Integer )
      Next
      
      '' clean-up
      Cva_End( args )

   End Sub

   proc( 4, 4000, 300, 20, 1 )

Version
   * Since fbc 1.07.0

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __cva_copy.

Differences from QB
   * New to FreeBASIC

See also
   * ... (Ellipsis)
   * Cva_Arg
   * Cva_End
   * Cva_List
   * Cva_Start



----------------------------------------------------------- KeyPgCvaEnd ----
Cva_End

Macro to clean-up a variadic argument list object variable

Syntax
   Cva_End( argument_list )

Parameters
   argument_list
      Cva_List variable to clean up

Description
   Cleans-up a Cva_List type variable that was previously initialized with 
   Cva_Start or Cva_Copy, like a destructor.

   argument_list must already have been initialized with a previous 
   Cva_Start or Cva_Copy statement in the same procedure as Cva_End (for 
   cross platform compatibility).

Example
   Sub proc cdecl(count As Integer, ... )
      Dim args As Cva_List

      Cva_Start( args, count )

      For i As Integer = 1 To count
         Print Cva_Arg( args, Integer )
      Next
      
      Cva_End( args )
   End Sub

   proc( 4, 4000, 300, 20, 1 )

Version
   * Since fbc 1.07.0

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __cva_end.

Differences from QB
   * New to FreeBASIC

See also
   * ... (Ellipsis)
   * Cva_Arg
   * Cva_Copy
   * Cva_List
   * Cva_Start



---------------------------------------------------------- KeyPgCvaList ----
Cva_List

Variadic argument list object type

Syntax
   Dim variable As Cva_List

Description
   Cva_List is a built in data type for working with the variable length 
   argument list in a variadic procedure.

   Use Cva_Start to initialize the Cva_List variable (constructor).
   Use Cva_Copy to copy a Cva_List variable (copy constructor).
   Use Cva_Arg to obtain the value of the next argument.
   Use Cva_End when finished with a Cva_List variable (destructor).

   The exact type and size of Cva_List varies depending on the target 
   platform.  This builtin type provides a layer of abstraction over the 
   underlying mechanism for obtaining the values passed to a variadic 
   procedure.

   fbc will select a default Cva_List type depending on -target, -arch, and 
   -gen command line options, as described in the following code.
   #if (__FB_BACKEND__ = "gcc")
      #if defined( __FB_64BIT__ ) 
         #if defined( __FB_ARM__ )
            Type __va_list Alias "__va_list"
               As Any Ptr __stack
               As Any Ptr __gr_top
               As Any Ptr __vr_top
               As Long __gr_offs
               As Long __vr_offs
            End Type
            Type Cva_List As __va_list Alias "__builtin_va_list"
         #elseif defined( __FB_WIN32__ )
            Type Cva_List As Any Alias "__builtin_va_list" Ptr
         #else
            Type __va_list_tag Alias "__va_list_tag"
               As ULong gp_offset
               As ULong fp_offset
               As Any Ptr overflow_arg_area
               As Any Ptr reg_save_area
            End Type  
            Type Cva_List As __va_list_tag Alias "__builtin_va_list[]"
         #endif   
      #else
         Type Cva_List As Any Alias "__builtin_va_list" Ptr
      #endif
   #else
      Type Cva_List As Any Alias "char" Ptr
   #endif

Example
   Function average cdecl(count As Integer, ... ) As Double

      Dim sum As Double = 0
      Dim i As Integer

      Dim args As Cva_List '' argument list object
      Cva_Start( args, count ) '' constructor
      For i = 1 To count
         sum += Cva_Arg(args, Double)
      Next
      Cva_End( args ) '' destructor
      
      Return sum / count
   End Function

   Print average(4, 3.4 ,5.0, 3.2, 4.1) '' all passed variable arguments must be of type double
   Print average(2, 65.2, 454.65481)    '' all passed variable arguments must be of type double

The output would look like:

    3.925
    259.927405

   '' pass the args list to a function taking an cva_list type argument
   #include "crt/stdio.bi"

   Sub myprintf cdecl( fmt As ZString Ptr, ... )
      Dim args As Cva_List
      Cva_Start( args, fmt )
      vprintf( fmt, args )
      Cva_End( args )
   End Sub

   Dim As String s = "bar"

   myprintf( !"integer=%i, longint=%lli float=%f\n", _
      1, 1ll Shl 32, 3.3 )

   myprintf( !"string=%s, string=%s\n", "foo", s )

Version
   * Since fbc 1.07.0

Platform Differences
   * The exact type and size of Cva_List depends on -target, -arch, -gen 
     command line options.
   * In -gen gas, Cva_List is a pointer
   * In -gen gcc, Cva_List is a pointer, a struct, or a struct array.  The 
     Cva_List type is replaced by "__builtin_va_list" in gcc.
   * On 32-bit targets, gas backend: type Cva_List as any alias "char" ptr
     .
   * On 32-bit targets, gcc backend: type Cva_List as any alias 
     "__builtin_va_list" ptr
   * On Windows 64-bit, gcc backend: type Cva_List as any alias 
     "__builtin_va_list" ptr
   * On Linux x86_64, gcc backend: type Cva_List as __va_list_tag alias 
     "__builtin_va_list[]"
   * On arm64, gcc backend: type Cva_List as __va_list alias 
     "__builtin_va_list"

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __cva_list.

Differences from QB
   * New to FreeBASIC

See also
   * ... (Ellipsis)
   * Cva_Arg
   * Cva_Start
   * Cva_Copy
   * Cva_End



--------------------------------------------------------- KeyPgCvaStart ----
Cva_Start

Macro to initialize variadic argument list object variable

Syntax
   Cva_Start( argument_list, last_param )

Parameters
   argument_list
      Cva_List data type variable to initialize
   last_param
      The last parameter in the procedures parameter list before the 
      Ellipsis ...

Description
   In a variadic procedure definition, argument_list is a variable having 
   the Cva_List type and must be initialized with Cva_Start to work with 
   the variable length argument list passed to the procedure.

   last_param is the last parameter before the Ellipsis ... in the variadic 
   procedure definition.

   Cva_Start can only be used in variadic procedures.  A variadic procedure 
   is declared or defined by specifying the Ellipsis ... as the last 
   parameter, and will accept a variable number of arguments when calling 
   the procedure.

   Cva_Start is like a constructor for the variadic argument_list object 
   and must eventually have a matching call to Cva_End, which is like a 
   destructor.  After Cva_End for argument_list has been called, 
   argument_list can be reused and reinitialized with another call to 
   Cva_Start.  The Cva_Start and Cva_End calls must both be called in pairs 
   in the same procedure (for cross platform compatibility).

   Cva_Copy is similar to Cva_Start except it initializes a variadic 
   argument_list object from an already initialized variadic argument_list 
   object, like a copy constructor.

Example
   '' typical usage of iterating through all arguments

   Sub proc cdecl(count As Integer, ... )
      Dim args As Cva_List
      Cva_Start( args, count )
      For i As Integer = 1 To count
         Print Cva_Arg( args, Integer )
      Next
      Cva_End( args )
   End Sub

   proc( 4, 4000, 300, 20, 1 )

   '' example of using cva_start to get the first argument
   '' then restarting to get all the arguments

   Sub proc cdecl(count As Integer, ... )
      Dim args As Cva_List

      '' get the first argument only
      Cva_Start( args, count )
      Print Cva_Arg( args, Integer )
      Cva_End( args )

      '' restart and get all the arguments
      Cva_Start( args, count )
      For i As Integer = 1 To count
         Print Cva_Arg( args, Integer )
      Next
      Cva_End( args )

   End Sub

   proc( 4, 4000, 300, 20, 1 )

Version
   * Since fbc 1.07.0

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __cva_start.

Differences from QB
   * New to FreeBASIC

See also
   * ... (Ellipsis)
   * Cva_Arg
   * Cva_Copy
   * Cva_End
   * Cva_List



-------------------------------------------------------------- KeyPgCvd ----
CVD

Converts a 64-bit integer or 8-byte string to a double-precision value

Syntax
   Declare Function CVD ( ByVal l As LongInt ) As Double
   Declare Function CVD ( ByRef str As Const String ) As Double

Usage
   result = CVD( l )
   result = CVD( str )

Parameters
   l
      A 64-bit LongInt with a binary copy of a double-precision variable 
      stored in it.
   str
      A String at least 8 bytes in length with a binary copy of a 
      double-precision variable stored in it.

Return Value
      Returns a Double value holding a binary copy of the input value.

Description
   Does a binary copy from a 64-bit LongInt or 8-byte String to a Double 
   variable.  A value of zero (0.0) is returned if the string is less than 
   8 bytes in length.  The result will make sense only if the parameter 
   contained a IEEE-754 formatted double-precision value, such as one 
   generated by CVLongInt or MKD.

   This function is useful to read numeric values from buffers without 
   using a Type definition.

Example
   Dim d As Double, l As LongInt
   d = 1.125
   l = CVLongInt(d)

   Print Using "l = _&H&"; Hex(l)
   Print Using "cvd(i) = &"; CVD(l)

Differences from QB
   * QB did not support integer arguments.

See also
   * MKD
   * CVS
   * CVLongInt



-------------------------------------------------------------- KeyPgCvi ----
CVI

Converts a floating-point number or string to an integer variable using a 
binary copy

Syntax
   32-bit:
   Declare Function CVI ( ByVal f As Single ) As Integer
   64-bit:
   Declare Function CVI ( ByVal f As Double ) As Integer

   Declare Function CVI ( ByRef str As Const String ) As Integer
   Declare Function CVI<bits> ( expr As DataType ) As Integer<bits>

Usage
   result = CVI( sng )
   result = CVI( str )
   result = CVI<bits>( expr )

Parameters
   f
      A floating-point number with a binary copy of an integer variable 
      stored in it.  Its precision (Single or Double) depends on the size 
      of Integer on the current platform
   str
      A String with a binary copy of an integer variable stored in it.
   bits
      Specifies a size of integer type to return.  The types and sizes of 
      expr accepted will depend on the corresponding function called.
   expr
      An expression that will be copied into an Integer<bits>.

Return Value
   An Integer or Integer<bits> variable containing a binary copy of the 
   input expression.

Description
   Returns an integer value using the binary data contained in a 
   floating-point value, or a String.  A value of zero (0) is returned if 
   the string contains fewer characters than the size of the return type.

   CVI can be used to convert strings created with MKI.

   This function can also be used to convert Integer-sized values from a 
   memory or file buffer without the need for a Type structure.  However, 
   just as with the type structure, special care should be taken when using 
   CVI to convert strings that have been read from a buffer.

   CVI supports an optional <bits> parameter before the argument.  If bits 
   is 16, CVShort will be called instead; if bits is 32, CVL will be 
   called; if bits is 64, CVLongInt will be called.  The return type and 
   accepted argument types will depend on which function is called.  See 
   each function's page for more information.

   CVI's behaviour changes depending on the size of the Integer data type 
   on the current platform.
   * For 16-bit Integer (-lang qb), a 16-bit value is returned, and no 
     floating-point types are accepted.
   * For 32-bit Integer, a 32-bit value is returned, and numeric arguments 
     are interpreted as Single precision values.
   * For 64-bit Integer, a 64-bit value is returned, and numeric arguments 
     are interpreted as Double precision values.

Example
   Dim i As Integer, s As String
   s = "ABCD"
   i = CVI(s)
   Print Using "s = ""&"""; s
   Print Using "i = _&H&"; Hex(i)

Dialect Differences
   * In the -lang qb dialect, CVI expects a 2-byte string, since a QB 
     integer is only 16 bits.  Only the first two bytes of the string are 
     used, even if the string happens to be longer than two bytes.
   * In the -lang qb dialect, CVI will not take a floating-point argument, 
     since a QB integer is only 16 bits and there is no 16-bit 
     floating-point data type.  Instead, CVI<32>/CVI<64> or CVL/CVLongInt 
     may be used.

Differences from QB
   * In QB an error occurs if the string passed is fewer than two bytes in 
     length.
   * QB did not support floating-point arguments.
   * QB did not support a <bits> parameter.

See also
   * MKI
   * CVShort
   * CVL
   * CVLongInt
   * Integer



-------------------------------------------------------------- KeyPgCvl ----
CVL

Converts a single-precision floating-point number or four-byte string to an 
integer (Long) variable

Syntax
   Declare Function CVL ( ByVal sng As Single ) As Long
   Declare Function CVL ( ByRef str As Const String ) As Long

Usage
   result = CVL( sng )
   result = CVL( str )

Parameters
   sng
      A Single floating-point number with a binary copy of an integer 
      variable stored in it.
   str
      A String at least four bytes in length with a binary copy of an 
      integer variable stored in it.

Return Value
      A Long variable to copy the binary copy of a integer to.

Description
   Returns a 32-bit Long integer value using the binary data contained in a 
   Single, or a String of at least four bytes in length.  A value of zero (
   0) is returned if the string is less than four bytes in length.

   CVL is used to convert 4-byte strings created with MKL.

   This function can also be used to convert 32-bit integer values from a 
   memory or file buffer without the need for a Type structure.  However, 
   just as with the type structure, special care should be taken when using 
   CVL to convert strings that have been read from a buffer.

Example
   Dim l As Long, s As String
   s = "ABCD"
   l = CVL(s)
   Print Using "s = ""&"""; s
   Print Using "l = &"; l

Differences from QB
   * In QB an error occurs if the string passed is less than four bytes in 
     length.
   * QB did not support floating-point arguments.

See also
   * MKL
   * CVShort
   * CVI
   * CVLongInt



-------------------------------------------------------- KeyPgCvlongint ----
CVLongInt

Converts a double-precision floating-point number or eight-byte string to a 
LongInt variable

Syntax
   Declare Function CVLongInt ( ByVal dbl As Double ) As LongInt
   Declare Function CVLongInt ( ByRef str As Const String ) As LongInt

Usage
   result = CVLongInt( dbl )
   result = CVLongInt( str )

Parameters
   dbl
      A Double floating-point number with a binary copy of a LongInt 
      variable stored in it.
   str
      A String at least eight bytes in length with a binary copy of a 
      LongInt variable stored in it.

Return Value
      A LongInt variable holding a binary copy of the input variable.

Description
   Returns a 64-bit LongInt value using the binary data contained in a 
   Double, or a String of at least eight bytes in length.  A value of zero 
   (0) is returned if the string is less than eight bytes in length.

   CVLongInt is used to convert 8-byte strings created with MKLongInt.

   This function can also be used to convert 64-bit integer values from a 
   memory or file buffer without the need for a Type structure.  However, 
   just as with the type structure, special care should be taken when using 
   CVLongInt to convert strings that have been read from a buffer.

Example
   Dim ll As LongInt, s As String
   s = "ABCDEFGH"
   ll = CVLongInt(s)
   Print Using "s = ""&"""; s
   Print Using "ll = _&H&"; Hex(ll)

Differences from QB
   * In QB an error occurs if the string passed is less than eight bytes 
     in length.
   * QB did not support floating-point arguments.

See also
   * MKLongInt
   * CVShort
   * CVI
   * CVL



-------------------------------------------------------------- KeyPgCvs ----
CVS

Converts a 32-bit integer or 4-byte string to a single-precision variable

Syntax
   Declare Function CVS ( ByVal i As Integer ) As Single
   Declare Function CVS ( ByRef str As Const String ) As Single

Usage
   result = CVS( i )
   result = CVS( str )

Parameters
   i
      A 32-bit Integer with a binary copy of a single-precision variable 
      stored in it.
   str
      A String at least 4 bytes in length with a binary copy of a 
      single-precision variable stored in it.

Return Value
      Returns a Single value holding a binary copy of the input value.

Description
   Does a binary copy from a 32-bit Integer or 4-byte String to a Single 
   variable.  A value of zero (0.0) is returned if the string is less than 
   4 bytes in length.  The result will make sense only if the parameter 
   contained a IEEE-754 formatted single-precision value, such as one 
   generated by CVI or MKS.

   This function is useful to read numeric values from buffers without 
   using a Type definition.

Example
   Dim f As Single, i As Integer
   f = 1.125
   i = CVI(f)

   Print Using "i = _&H&"; Hex(i)
   Print Using "cvs(i) = &"; CVS(i)

Differences from QB
   * QB did not support integer arguments.

See also
   * MKS
   * CVD
   * CVI



---------------------------------------------------------- KeyPgCvshort ----
CVShort

Converts a two-byte string to a Short integer variable

Syntax
   Declare Function CVShort ( ByRef str As Const String ) As Short

Usage
   result = CVShort( str )

Parameters
   str
      A String at least two bytes in length with a binary copy of a Short 
      integer variable stored in it.

Return Value
    Short variable holding the binary copy of a Keypgshort.

Description
   Returns a 16-bit Short integer value using the binary data contained in 
   a String of at least two bytes in length.  A value of zero (0) is 
   returned if the string is less than two bytes in length.

   CVShort is used to convert 2-byte strings created with MKShort.

   This function can also be used to convert 16-bit integer values from a 
   memory or file buffer without the need for a Type structure.  However, 
   just as with the type structure, special care should be taken when using 
   CVShort to convert strings that have been read from a buffer.

Example
   Dim si As Short, s As String
   s = "AB"
   si = CVShort(s)
   Print Using "s = ""&"""; s
   Print Using "si = _&H&"; Hex(si)

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Cvshort.

Differences from QB
   * In QB this function is called CVI

See also
   * MKShort
   * CVI
   * CVL
   * CVLongInt




============================================================================
    D

------------------------------------------------------------- KeyPgData ----
Data

Statement to store data at compile time.

Syntax
   Data constant_expression1 [,constant_expression2]...

Description
   Data stores a list of constant numeric or alphabetical expressions that 
   are evaluated at compile time (except with -lang qb) and stored as 
   constants that can be read into variables by using Read.

   All the Data statements in the program behave as a single chained list; 
   after the last element of one Data statement is read, the first element 
   of the following Data statement will be read.
   The program should not attempt to Read after the last Data element.  The 
   results are (in all dialects) undefined,  and the program may crash 
   (Page Fault).

   Data statements are only visible from within the module in which they 
   are defined; they must be only entered in module-level code.

   Data constants can only be of simple types (numeric or string).  A 
   numeric value can be read as a numeric literal into a string. A string 
   read into a numeric variable will be evaluated by the Val function.  
   Consts can be used as items of data except in the -lang qb dialect, 
   where their names are considered as normal text.

   The "Restore label" statement makes the first Data item after the label 
   the next item to be read, allowing the user to choose specific sections 
   of data to read.

   Data is normally used to initialize variables. FreeBASIC also allows the 
   initialization of static variables when they are Dimensioned - see 
   Variable Initializers for more information.

Example
   ' Create an array of 5 integers and a string to hold the data.
   Dim As Integer h(4)
   Dim As String hs
   Dim As Integer readindex

   ' Set up to loop 5 times (for 5 numbers... check the data)
   For readindex = 0 To 4

     ' Read in an integer.
     Read h(readindex)

     ' Display it.
     Print "Number" ; readindex ; " = " ; h(readindex)

   Next readindex

   ' Spacer.
   Print

   ' Read in a string.
   Read hs

   ' Print it.
   Print  "String = " + hs

   ' Await a keypress.
   Sleep

   ' Exit program.
   End

   ' Block of data.
   Data 3, 234, 435/4, 23+433, 87643, "Good" + "Bye!"

Dialect Differences
   * -lang fb and -lang fblite considers data items as constant 
     expressions that are evaluated during compilation and its result 
     stored in the program.
   * -lang qb considers unquoted words, including names of variables and 
     constants, as literal strings, and stores them without change, as in 
     QBASIC.  Unquoted strings are delimited by commas, and a colon or a 
     line-break signifies the end of the Data statement.  Unquoted strings 
     are trimmed of whitespace at the beginning and end.

Differences from QB
   * Outside of the -lang qb dialect, alphabetic string literals must be 
     enclosed within quotation marks, in QBASIC this was optional.
   * In QBASIC empty items evaluated to number 0 or to empty strings, in 
     FreeBASIC they give a compile error. In QBASIC a comma at the end of 
     the statement made an additional, empty item, evaluated to 0 or an 
     empty string. In FreeBASIC they give a compile error.

See also
   * Read
   * Restore



------------------------------------------------------------- KeyPgDate ----
Date

Returns the current system date as a string

Syntax
   Declare Function Date ( ) As String

Usage
   result = Date[$]

Return Value
   Returns the current system date, in the format mm-dd-yyyy

Description
   None

Example
   Print Date ' prints the current date

Differences from QB
   * The QB DATE statement (to set the system date) is now called SetDate.
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

See also
   * SetDate
   * Time
   * Timer



---------------------------------------------------------- KeyPgDateAdd ----
DateAdd

Offset a date with a specified interval

Syntax
   Declare Function DateAdd ( ByRef interval As Const String, ByVal number 
   As Double, ByVal date_serial As Double ) As Double

Usage
   #include "vbcompat.bi"
   result = DateAdd( interval, number, date_serial )

Parameters
   interval
      string indicating which period of time corresponds to one unit of 
      number
   number
      the number of intervals to add to the base date.  The number will be 
      rounded to the nearest integer.
   date_serial
      the base date

Return Value
   Returns a Date Serial corresponding to the received date_serial plus the 
   number of intervals.

Description
   Interval is specified as follows:

      +-----+---------------------+
      |value|interval             |
      |yyyy |years                |
      |q    |quarter(three months)|
      |m    |months               |
      |ww   |weeks                |
      |d,w,y|days                 |
      |h    |hours                |
      |n    |minutes              |
      |s    |seconds              |
      +-----+---------------------+
  

   The compiler will not recognize this function unless vbcompat.bi or 
   datetime.bi is included.

Example
   #include "vbcompat.bi"

   Const fmt = "ddddd ttttt"
   Dim d As Double
   d = Now()

   Print "1 hour from now is ";
   Print Format( DateAdd( "h", 1, d ), fmt )

   Print "1 day from now is ";
   Print Format( DateAdd( "d", 1, d ), fmt )

   Print "1 week from now is ";
   Print Format( DateAdd( "ww", 1, d ), fmt )

   Print "1 month from now is ";
   Print Format( DateAdd( "m", 1, d ), fmt )

Differences from QB
   * Did not exist in QB. This function appeared in Visual Basic.

See also
   * Date Serials

   


--------------------------------------------------------- KeyPgDateDiff ----
DateDiff

Gets the difference of two dates measured by a specified interval

Syntax
   Declare Function DateDiff ( ByRef interval As Const String, ByVal 
   serial1 As Double, ByVal serial2 As Double, ByVal firstdayofweek As Long 
   = fbUseSystem, ByVal firstdayofyear As Long = fbUseSystem ) As Long

Usage
   #include "vbcompat.bi"
   result = DateDiff( interval, date_serial1, date_serial2 [, 
   firstdayofWeek [, firstweekofyear ] ] )

Parameters
   interval
      the unit of time (interval) with which to measure the difference
   date_serial1
      starting date serial
   date_serial2
      end date serial
   firstdayofweek
      first day of the week
   firstdayofyear
      first day of the year

Return Value
   Returns an integer corresponding to the number of intervals found 
   between two Date Serials.

   If date_serial1 > date_serial2, the result is negative.

Description
   interval is specified as follows:

         +-----+---------------------+
         |value|interval             |
         |yyyy |years                |
         |q    |quarter(three months)|
         |m    |months               |
         |w    | seven day periods   |
         | ww  |calendar weeks       |
         |d,y  |days                 |
         |h    |hours                |
         |n    |minutes              |
         |s    |seconds              |
         +-----+---------------------+
  

   first_dayofweek Affects the counting when 'ww' interval is used.

         +-------+-----------------+-----------+
         |value  |first day of week|constant   |
         |omitted|sunday           |           |
         |0      |local settings   |fbUseSystem|
         |1      |sunday           |fbSunday   |
         |2      |monday           |fbMonday   |
         |3      |tuesday          |fbTuesday  |
         |4      |wednesday        |fbWednesday|
         |5      |thursday         |fbThursday |
         |6      |friday           |fbFriday   |
         |7      |saturday         |fbSaturday |
         +-------+-----------------+-----------+

   first_weekofyear specifies which year (previous or next) that the week 
   which spans the end of one year and the beginning of the next should 
   included with.

         +-----+-------------------------------------+---------------+
         |value|first week of year                   |constant       |
         |0    |local settings                       |fbUseSystem    |
         |1    |January 1's week                     |fbFirstJan1    |
         |2    |first weeks having 4 days in the year|fbFirstFourDays|
         |3    |first full week of year              |fbFirstFullWeek|
         +-----+-------------------------------------+---------------+

   Notice if you do an arithmetical subtraction of two date serials you get 
   the difference in days.

   The compiler will not recognize this function unless vbcompat.bi or 
   datetime.bi is included.

Example
   #include "vbcompat.bi"

   Dim s As String, d1 As Double, d2 As Double

   Line Input "Enter your birthday: ", s

   If IsDate( s ) Then
     d1 = DateValue( s )
     d2 = Now()

     Print "You are " & DateDiff( "yyyy", d1, d2 ) & " years old."
     Print "You are " & DateDiff( "d", d1, d2 ) & " days old."
     Print "You are " & DateDiff( "s", d1, d2 ) & " seconds old."

   Else
     Print "Invalid date"

   End If

Differences from QB
   * Did not exist in QB. This function appeared in Visual Basic.

See also
   * Date Serials



--------------------------------------------------------- KeyPgDatePart ----
DatePart

Gets an interval from a date

Syntax
   Declare Function DatePart ( ByRef interval As Const String, ByVal 
   date_serial As Double, ByVal firstdayofweek As Long = fbUseSystem, ByVal 
   firstdayofyear As Long = fbUseSystem ) As Long

Usage
   #include "vbcompat.bi"
   result = DatePart( interval, date_serial, first_dayofWeek [, 
   first_week_of_year ] )

Parameters
   interval
      string indicating which part of the date is required
   date_serial
      the date serial to decode 
   firstdayofweek
      first day of the week
   firstdayofyear
      first day of the year

Return Value
   Return an integer representing  the interval in the Date Serial.

Description

   interval string indicating which part of the date is required is 
   specified as follows:

         +-----+---------------------+
         |value|interval             |
         |yyyy |years                |
         |q    |quarter(three months)|
         |m    |months               |
         | w   | weekday             |
         | ww  | week of the year    |
         |y    |day of the year      |
         |d    |day of the month     |
         |h    |hours                |
         |n    |minutes              |
         |s    |seconds              |
         +-----+---------------------+
  

   first_dayofweek Affects the output when 'w' interval is required.

         +-------+-----------------+-----------+
         |value  |first day of week|constant   |
         |omitted|sunday           |           |
         |0      |local settings   |fbUseSystem|
         |1      |sunday           |fbSunday   |
         |2      |monday           |fbMonday   |
         |3      |tuesday          |fbTuesday  |
         |4      |wednesday        |fbWednesday|
         |5      |thursday         |fbThursday |
         |6      |friday           |fbFriday   |
         |7      |saturday         |fbSaturday |
         +-------+-----------------+-----------+

   first_weekofyear  specifies which year (previous or next) that the week 
   which spans the end of one year and the beginning of the next should 
   included with. Affects the output when 'ww' interval is required.

         +-----+-------------------------------------+---------------+
         |value|first week of year                   |constant       |
         |0    |local settings                       |fbUseSystem    |
         |1    |January 1's week                     |fbFirstJan1    |
         |2    |first weeks having 4 days in the year|fbFirstFourDays|
         |3    |first full week of year              |fbFirstFullWeek|
         +-----+-------------------------------------+---------------+

   The compiler will not recognize this function unless vbcompat.bi or 
   datetime.bi is included.

Example
   #include "vbcompat.bi"

   Dim d As Double

   d = Now()

   Print "Today is day " & DatePart( "y", d );
   Print " in week " & DatePart( "ww", d );
   Print " of the year " & DatePart( "yyyy", d )

Differences from QB
   * Did not exist in QB. This function appeared in Visual Basic.

See also
   * Date Serials



------------------------------------------------------- KeyPgDateSerial ----
DateSerial

Creates a date serial

Syntax
   Declare Function DateSerial ( ByVal year As Long, ByVal month As Long, 
   ByVal day As Long ) As Long

Usage
   #include "vbcompat.bi"
   result = DateSerial( year, month, day )

Parameters
   year
      the year
   month
      the month of the year
   day
      the day of the month

Return Value
   Returns a date serial containing the date formed by the values in the 
   year, month and day parameters.The date serial returned has no decimal 
   part.

Description
   The compiler will not recognize this function unless vbcompat.bi or 
   datetime.bi is included.

Example
   #include "vbcompat.bi"

   Dim a As Double = DateSerial(2005, 11, 28)

   Print Format(a, "yyyy/mm/dd hh:mm:ss") 

Differences from QB
   * Did not exist in QB. This function appeared in PDS and VBDOS

See also
   * Date Serials
   * DateSerial
   * TimeValue
   * DateValue



-------------------------------------------------------- KeyPgDateValue ----
DateValue

Returns a Date Serial from a string

Syntax
   Declare Function DateValue ( ByRef date_string As String ) As Double

Usage
   #include "vbcompat.bi"
   result = DateValue( date_string )

Parameters
   date_string
      the string to convert to a date serial

Return Value
   Returns a Date Serial from a date string.

Description
   The date string must be in the format set in the regional settings of 
   the Operating System. 

   DateValue( Date() ) will work correctly only if the regional settings 
   specify the same short date format QB used (mm-dd-yyyy).  Consider using 
   the Now function in the expression Fix(Now()) to obtain the current date 
   as a date serial.

   The compiler will not recognize this function unless vbcompat.bi or 
   datetime.bi is included.

Example
   #include "vbcompat.bi"

   Dim As Integer v1, v2
   Dim As String  s1, s2

   Print "Enter first date: ";
   Line Input s1

   If IsDate( s1 ) = 0 Then
     Print "not a date"
     End
   End If

   Print "Enter second date: ";
   Line Input s2

   If IsDate( s2 ) = 0 Then
     Print "not a date"
     End
   End If

   '' convert the strings to date serials
   v1 = DateValue( s1 )
   v2 = DateValue( s2 )

   Print "Number of days between dates is " & Abs( v2 - v1 )

Differences from QB
   * Did not exist in QB. This function appeared in PDS and VBDOS

See also
   * Date Serials
   * DateSerial
   * TimeValue



-------------------------------------------------------------- KeyPgDay ----
Day

Gets the day of the month from a Date Serial

Syntax
   Declare Function Day ( ByVal date_serial As Double ) As Long

Usage
   #include "vbcompat.bi"
   result = Day( date_serial )

Parameters
   date_serial
      the date

Return Value
   Returns the day of the month from a  variable containing a date in  
   Date Serial  format. 

Description

   The compiler will not recognize this function unless vbcompat.bi is 
   included.

Example
   #include "vbcompat.bi"

   Dim ds As Double = DateSerial(2005, 11, 28)

   Print Format(ds, "yyyy/mm/dd "); Day(ds)

Differences from QB
   * Did not exist in QB. This function appeared in PDS and VBDOS

See also
   * Date Serials



------------------------------------------------------- KeyPgDeallocate ----
Deallocate

Frees previously allocated memory

Syntax
   Declare Sub Deallocate cdecl ( ByVal pointer As Any Ptr )

Usage
   Deallocate( pointer )

Parameters
   pointer
      the address of the previously allocated buffer.

Description
   This procedure frees memory that was previously allocated with Allocate. 
   pointer must be a valid pointer. After the procedure returns, pointer 
   will be rendered invalid (pointing to an invalid memory address), and 
   its use (dereferencing or calling Deallocate again) will result in 
   undefined behavior.

   When memory was allocated to hold a string descriptor, the string must 
   always be destroyed (setting to "") before deallocate the string 
   descriptor (allowing to deallocate the memory taken up by the string 
   data), otherwise, it is not possible to deallocate it later, and it may 
   induce memory leak in the program continuation.

   Calling Deallocate on a null pointer induces no action.

Example
   The following example shows how to free previously allocated memory. 
   Note that the pointer is set to null following the deallocation:
   Sub DeallocateExample1()
      Dim As Integer Ptr integerPtr = Allocate( Len( Integer ) )  '' initialize pointer to
                                                   '' new memory address

      *integerPtr = 420                                     '' use pointer
      Print *integerPtr

      Deallocate( integerPtr )                              '' free memory back to system
      integerPtr = 0                                        '' and zero the pointer
   End Sub

      DeallocateExample1()
      End 0
      

   Although in this case it is unnecessary since the function immediately 
   exits afterwards, setting the pointer to null is a good habit to get 
   into. If the function deallocated memory from a pointer that was passed 
   in by reference, for instance, the pointer that was used in the function 
   call will be rendered invalid, and it is up to the caller to either 
   reassign the pointer or set it to null. Example 3 shows how to correctly 
   handle this kind of situation, and the next example shows the effects of 
   deallocating memory with multiple references.

   In the following example, a different pointer is used to free previously 
   allocated memory:
   '' WARNING: "evil" example showing how things should NOT be done

   Sub DeallocateExample2()
      Dim As Integer Ptr integerPtr = Allocate( Len( Integer ) )  
      '' initialize ^^^ pointer to new memory

      Dim As Integer Ptr anotherIntegerPtr = integerPtr
      '' initialize ^^^ another pointer to the same memory

      *anotherIntegerPtr = 69                     '' use other pointer
      Print *anotherIntegerPtr

      Deallocate( anotherIntegerPtr )             '' free memory back to system
      anotherIntegerPtr = 0                       '' and zero other pointer

   '' *integerPtr = 420                           '' undefined behavior; original
                                       '' pointer is invalid
   End Sub

      DeallocateExample2()
      End 0
      

   Note that after the deallocation, both pointers are rendered invalid. 
   This illustrates another one of the ways that bugs can arise when 
   working with pointers. As a general rule, only deallocate memory 
   previously allocated when you know that there is only one (1) pointer 
   currently pointing at it.

   Function createInteger() As Integer Ptr
      Return Allocate( Len( Integer ) )                     '' return pointer to newly
   End Function                                             '' allocated memory

   Sub destroyInteger( ByRef someIntegerPtr As Integer Ptr )
      Deallocate( someIntegerPtr )                          '' free memory back to system
      someIntegerPtr = 0                                    '' null original pointer
   End Sub

   Sub DeallocateExample3()
      Dim As Integer Ptr integerPtr = createInteger()       '' initialize pointer to
                                              '' new memory address

      *integerPtr = 420                                     '' use pointer
      Print *integerPtr

      destroyInteger( integerPtr )                          '' pass pointer by reference
      Assert( integerPtr = 0 )                              '' pointer should now be null
   End Sub

      DeallocateExample3()
      End 0
      

   In the program above, a reference pointer in a function is set to null 
   after deallocating the memory it points to. An Assert macro is used to 
   test if the original pointer is in fact null after the function call. 
   This example implies the correct way to pass pointers to functions that 
   deallocate the memory they point to is by reference.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Deallocate.

Differences from QB
   * New to FreeBASIC

See also
   * Allocate
   * Reallocate



---------------------------------------------------------- KeyPgDeclare ----
Declare

Declares a module-level or member procedure

Syntax
   Declare Sub name [ param_list ]
   Declare Function name [ param_list ] [ ByRef ] As return_type
   Declare Operator op_symbol param_list [ [ ByRef ] As return_type ]

   Type T
      Declare Constructor [ param_list ]
      Declare Destructor
      Declare Sub name [ param_list ]
      Declare Function name [ param_list ] [ ByRef ] As return_type
      Declare Operator name [ param_list ] [ [ ByRef ] As return_type ]
      Declare Property name [ ( [ param_list ] ) ] [ [ ByRef ] As 
      return_type ]
   End Type

Parameters
   param_list
      Parenthesized comma-separated list of parameters.
   return_type
      The return type of a Function, Operator, or Property procedure.
   name
      The name or symbol of the procedure.
   op_symbol
      The name or symbol of an operator.
   T
      The name of a new user-defined type.

Description
   The Declare statement declares a Sub, Function, Operator, Constructor, 
   or Destructor.
   The procedure can be referred to in code without seeing its definition, 
   although it must be defined somewhere. Essentially, the Declare 
   statement introduces a procedure, and states that its definition is 
   elsewhere. For example, a function can be declared at the top of a 
   source module, called, then defined at the bottom of the source file, as 
   shown below the example.

   A procedure's declaration is almost identical to the first line of its 
   definition, except the declaration is preceded by the Declare keyword 
   and has no body. Also, attributes such as Export are left off the 
   declaration.

   FreeBASIC, as QB, does not require the declaration of the functions 
   unless they are defined in a different source file or in the same file 
   past the point where they are called. This is no longer true for 
   procedures declared inside a Type body, which must always be declared 
   first in the Type's body before use. If you do not declare Type 
   procedures you will receive an error.

    As every file using a function must have its declaration, declarations 
   are usually kept in one or more include files to allow usage of the 
   function by any module that needs it using the #include statement. 

Example
Module-level Function:
   '' declare the function sum which takes two integers and returns an integer
   Declare Function sum( As Integer, As Integer ) As Integer

      Print "the sum of 420 and 69 is: " & sum( 420, 69 )    '' call the function sum

   '' define the function sum which takes two integers and returns an integer
   Function sum( a As Integer, b As Integer ) As Integer
      Return a + b
   End Function

Type-level Sub:
   Type my_type
      my_data As Integer
      Declare Sub increment_data( )
   End Type

   Sub my_type.increment_data( )
      my_data += 1
   End Sub

   Dim As my_type an_instance

   an_instance.my_data = 68

   an_instance.increment_data( )

   Print an_instance.my_data

Dialect Differences
   * In the -lang fb dialect, ByVal is the default parameter passing 
     convention.
   * In the -lang qb and -lang deprecated dialects, ByRef is the default 
     parameter passing convention.
   * Type-level Sub/Function/Operator/Constructor/Destructor's are only 
     allowed in -lang fb

Differences from QB
   * In FreeBASIC, the parameter names are optional.

See also
   * Sub
   * Function
   * Operator
   * Property
   * Constructor
   * Destructor
   * Constructor (Module)
   * Destructor (Module)
   * Type
   * Dim
   * Alias (Name)
   * Alias (Modifier)

   

---------------------------------------------------------- KeyPgDefbyte ----
DefByte

Specifies a default data type for a range of variable names

Syntax
   DefByte start_letter[-end_letter ][, ...]

Parameters
   start_letter
      the first letter in the range
   end_letter
      the last letter in the range

Description
   DefByte specifies that variables and arrays which aren't declared with a 
   data type - or not declared at all - are implicitly declared of type Byte
   if the first letter of their names matches a certain letter or lies 
   within an inclusive range of letters.

Example
   This will make bNumber a Byte number since it's first letter starts with 
   b:
   '' Compile with -lang fblite or qb

   #lang "fblite"

   DefByte b
   Dim bNumber

Dialect Differences
   * Available in the -lang fblite dialect.
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Defbyte.

Differences from QB
   * New to FreeBASIC

See also
   * Byte
   * DefInt
   * DefUByte
   * Dim



----------------------------------------------------------- KeyPgDefdbl ----
DefDbl

Specifies a default data type for a range of variable names

Syntax
   DefDbl start_letter[-end_letter ][, ...]

Parameters
   start_letter
      the first letter in the range
   end_letter
      the last letter in the range

Description
   DefDbl specifies that variables and arrays which aren't declared with a 
   data type - or not declared at all - are implicitly declared of type 
   Double if the first letter of their names matches a certain letter or 
   lies within an inclusive range of letters.

Example
   This will make aNum a Double-precision decimal number since it is in the 
   range of a-d:
   '' Compile with -lang fblite or qb

   #lang "fblite"

   DefDbl a-d
   Dim aNum 'implicit: As Double

   Print Len(aNum) ' Prints 8, the number of bytes in a double.

Dialect Differences
   * Only available in the -lang qb and -lang fblite dialects.

Differences from QB
   * None

See also
   * DefInt
   * DefSng
   * Dim
   * Double



---------------------------------------------------------- KeyPgDefined ----
defined

Preprocessor function to test if a symbol has been defined

Syntax
   defined (symbol_name)

Parameters
   symbol_name
      Name of the symbol to test

Return Value
   Returns non-zero (-1) if the symbol has been defined, otherwise returns 
   zero (0).

Description
   Given the symbol name, the defined() preprocessor function returns true 
   if the symbol has been defined - or false if the symbol is unknown.

   This is used mainly with #if.

   Similar to #ifdef except it allows more than one check to occur because 
   of its flexibility.

Example
   'e.g. - which symbols are defined out of a, b, c, and d ?

   Const a = 300
   #define b 12
   Dim c As Single

   #if defined(a)
    Print "a is defined"
   #endif
   #if defined(b)
    Print "b is defined"
   #endif
   #if defined(c)
    Print "c is defined"
   #endif
   #if defined(d)
    Print "d is defined"
   #endif

Differences from QB
   * New to FreeBASIC

See also
   * #define
   * #macro
   * #if
   * #else 
   * #elseif 
   * #endif 
   * #ifdef
   * #ifndef
   * #undef



----------------------------------------------------------- KeyPgDefint ----
DefInt

Specifies a default data type for a range of variable names

Syntax
   DefInt start_letter[-end_letter ][, ...]

Parameters
   start_letter
      the first letter in the range
   end_letter
      the last letter in the range

Description
   DefInt specifies that variables and arrays which aren't declared with a 
   data type - or not declared at all - are implicitly declared of type 
   Integer if the first letter of their names matches a certain letter or 
   lies within an inclusive range of letters.

Example
   This will make iNumber an Integer number since its first letter starts 
   with i.
   '' Compile with -lang fblite or qb

   #lang "fblite"

   DefInt i
   Dim iNumber

Dialect Differences
   * Only available in the -lang qb and -lang fblite dialects.

Differences from QB
   * None

See also
   * DefByte
   * DefDbl
   * DefLng
   * DefLongInt
   * DefShort
   * DefSng
   * DefStr
   * Integer



----------------------------------------------------------- KeyPgDeflng ----
DefLng

Specifies a default data type for a range of variable names

Syntax
   DefLng start_letter[-end_letter ][, ...]

Parameters
   start_letter
      the first letter in the range
   end_letter
      the last letter in the range

Description
   DefLng specifies that variables and arrays which aren't declared with a 
   data type - or not declared at all - are implicitly declared of type Long
   if the first letter of their names matches a certain letter or lies 
   within an inclusive range of letters.

Example
   This will make lNumber a Long integer number since it starts with l.
   '' Compile with -lang fblite or qb

   #lang "fblite"

   DefLng l
   Dim lNumber ' implicit: As Long

   Print Len(lNumber) ' Displays 4, the number of bytes in a long.

Dialect Differences
   * Only available in the -lang qb and -lang fblite dialects.

Differences from QB
   * None

See also
   * DefInt
   * Defulongint
   * Dim
   * LongInt



------------------------------------------------------- KeyPgDeflongint ----
DefLongInt

Specifies a default data type for a range of variable names

Syntax
   DefLongInt start_letter[-end_letter ][, ...]

Parameters
   start_letter
      the first letter in the range
   end_letter
      the last letter in the range

Description
   DefLongInt specifies that variables and arrays which aren't declared 
   with a data type - or not declared at all - are implicitly declared of 
   type LongInt if the first letter of their names matches a certain letter 
   or lies within an inclusive range of letters.

Example
   This will make lNumber a LongInt number since it's first letter starts 
   with l.
   '' Compile with -lang fblite

   #lang "fblite"

   DefLongInt l
   Dim lNumber

Dialect Differences
   * Available in the -lang fblite dialect.
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Deflongint.

Differences from QB
   * New to FreeBASIC

See also
   * DefInt
   * Defulongint
   * Dim
   * LongInt



--------------------------------------------------------- KeyPgDefshort ----
DefShort

Specifies a default data type for a range of variable names

Syntax
   DefShort start_letter[-end_letter ][, ...]

Parameters
   start_letter
      the first letter in the range
   end_letter
      the last letter in the range

Description
   DefShort specifies that variables and arrays which aren't declared with 
   a data type - or not declared at all - are implicitly declared of type 
   Short if the first letter of their names matches a certain letter or 
   lies within an inclusive range of letters.

Example
   This will make sNumber a Short number since its first letter starts with 
   s.
   '' Compile with -lang fblite or qb

   #lang "fblite"

   DefShort s
   Dim sNumber

Dialect Differences
   * Available in the -lang fblite dialect.
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Defshort.

Differences from QB
   * New to FreeBASIC
   * In QBasic, to make variables default to a 2 byte integer, DEFINT is 
     used.

See also
   * DefInt
   * DefUShort
   * Dim
   * Integer
   * Short



----------------------------------------------------------- KeyPgDefsng ----
DefSng

Specifies a default data type for a range of variable names

Syntax
   DefSng start_letter[-end_letter ][, ...]

Parameters
   start_letter
      the first letter in the range
   end_letter
      the last letter in the range

Description
   DefSng specifies that variables and arrays which aren't declared with a 
   data type - or not declared at all - are implicitly declared of type 
   Single if the first letter of their names matches a certain letter or 
   lies within an inclusive range of letters.

Example
   This will make sNumber and yNumber a Single-precision decimal number 
   since it is in the range of s-z.
   '' Compile with -lang fblite or qb

   #lang "fblite"

   DefSng s-z
   Dim sNumber, yNumber

Dialect Differences
   * Only available in the -lang qb and -lang fblite dialects.

Differences from QB
   * None

See also
   * DefInt
   * DefDbl
   * Single



----------------------------------------------------------- KeyPgDefstr ----
DefStr

Specifies a default data type for a range of variable names

Syntax
   DefStr start_letter[-end_letter ][, ...]

Parameters
   start_letter
      the first letter in the range
   end_letter
      the last letter in the range

Description
   DefStr specifies that variables and arrays which aren't declared with a 
   data type - or not declared at all - are implicitly declared of type 
   String if the first letter of their names matches a certain letter or 
   lies within an inclusive range of letters.

Example
   This will make sMessage a String since it starts with s.
   '' Compile with -lang fblite or qb

   #lang "fblite"

   DefStr s
   Dim sMessage

Dialect Differences
   * Only available in the -lang qb and -lang fblite dialects.

Differences from QB
   * None

See also
   * DefInt
   * DefSng
   * DefLng
   * DefDbl
   * Dim
   * String



--------------------------------------------------------- KeyPgDefubyte ----
DefUByte

Specifies a default data type for a range of variable names

Syntax
   DefUByte start_letter[-end_letter ][, ...]

Parameters
   start_letter
      the first letter in the range
   end_letter
      the last letter in the range

Description
   DefUByte specifies that variables and arrays which aren't declared with 
   a data type - or not declared at all - are implicitly declared of type 
   UByte if the first letter of their names matches a certain letter or 
   lies within an inclusive range of letters.

Example
   This will make uNumber a UByte number since it's first letter starts 
   with u.
   '' Compile with -lang fblite

   #lang "fblite"

   DefUByte u
   Dim uNumber

Dialect Differences
   * Available in the -lang fblite dialect.
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Defubyte.

Differences from QB
   * New to FreeBASIC

See also
   * DefByte
   * DefInt
   * Dim
   * UByte



---------------------------------------------------------- KeyPgDefuint ----
DefUInt

Specifies a default data type for a range of variable names

Syntax
   DefUInt start_letter[-end_letter ][, ...]

Parameters
   start_letter
      the first letter in the range
   end_letter
      the last letter in the range

Description
   DefUInt specifies that variables and arrays which aren't declared with a 
   data type - or not declared at all - are implicitly declared of type 
   UInteger if the first letter of their names matches a certain letter or 
   lies within an inclusive range of letters.

Example
   This will make uNumber a UInteger number since its first letter starts 
   with u.
   '' Compile with -lang fblite

   #lang "fblite"

   DefInt u
   Dim uNumber

Dialect Differences
   * Available in the -lang fblite dialect.
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Defuint.

Differences from QB
   * New to FreeBASIC

See also
   * DefInt
   * Dim
   * UInteger



------------------------------------------------------ KeyPgDefulongint ----
Defulongint

Specifies a default data type for a range of variable names

Syntax
   Defulongint start_letter[-end_letter ][, ...]

Parameters
   start_letter
      the first letter in the range
   end_letter
      the last letter in the range

Description
   Defulongint specifies that variables and arrays which aren't declared 
   with a data type - or not declared at all - are implicitly declared of 
   type ULongInt if the first letter of their names matches a certain 
   letter or lies within an inclusive range of letters.

Example
   This will make lNumber a ULongInt number since its first letter starts 
   with l.
   '' Compile with -lang fblite

   #lang "fblite"

   defulongint l
   Dim lNumber

Dialect Differences
   * Available in the -lang fblite dialect.
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Defulongint.

Differences from QB
   * New to FreeBASIC

See also
   * DefInt
   * DefLongInt
   * Dim
   * ULongInt



-------------------------------------------------------- KeyPgDefushort ----
DefUShort

Specifies a default data type for a range of variable names

Syntax
   DefUShort start_letter[-end_letter ][, ...]

Parameters
   start_letter
      the first letter in the range
   end_letter
      the last letter in the range

Description
   DefUShort specifies that variables and arrays which aren't declared with 
   a data type - or not declared at all - are implicitly declared of type 
   UShort if the first letter of their names matches a certain letter or 
   lies within an inclusive range of letters.

Example
   This will make uNumber a UShort number since its first letter starts 
   with u.
   '' Compile with -lang fblite

   #lang "fblite"

   DefUShort u
   Dim uNumber

Dialect Differences
   * Available in the -lang fblite dialect.
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Defushort.

Differences from QB
   * New to FreeBASIC

See also
   * DefInt
   * DefShort
   * Dim
   * UShort



--------------------------------------------------------- KeyPgOpDelete ----
Operator Delete Statement

Operator to destroy data and free memory allocated with the 
Operator New Expression

Usage
   Delete buf
      or
   Delete[] buf

Parameters
   buf 
      A pointer to memory that has been allocated by New Expression 
      operator or New[] Expression operator, the array-version of 
      New Expression operator (a typed pointer must be provided in 
      accordance to the data type to delete).

Description
   The Delete Statement operator is used to destroy and free the memory of 
   an object created with New Expression operator. When deleting a TYPE, 
   its destructor will be called. Delete Statement operator should only be 
   used with addresses returned from New Expression operator.

   The array version of Delete Statement operator, Delete[] Statement 
   operator, is used to destroy an array of objects previously created with 
   New[] Expression operator, the array-version of New Expression operator. 
   Destructors will be called here as well.

   Delete Statement operator must be used with addresses returned from 
   New Expression operator, and Delete[] Statement operator with New[] 
   Expression operator, the array-version of New Expression operator. You 
   cannot mix and match the different versions of the operators.

   After the memory is deleted, the buf pointer will be pointing at invalid 
   memory. Calling Delete Expression twice on the same pointer value leads 
   to undefined behavior. It may be a good idea to set the buf pointer to 
   null (0), in order to guard against later code using it accidentally, 
   since null pointer dereferences are easier to find and debug.

   Calling Delete Statement operator on a null pointer induces no action.

   The memory deallocation process part provided by the Delete Statement 
   operator can be overloaded for user-defined types as a member operator 
   Delete Overload. The previous process part for data destruction can 
   never be modified.

   Note: Any operator Delete[] (Statement or Overload) and the only 
   Overload operator Delete are not compatible with sub-type polymorphism, 
   even using Override Virtual Destructor that may in addition induce 
   crashing.
   Instead of having to call such an operator Delete([]) Statement on 
   derived-type pointer, the safest way is to simply call (on base-type 
   pointer) an overridden user Virtual member procedure that will 
   automatically launch the operator Delete([]) Statement at derived-type 
   level.

Example
   Type Rational
      As Integer numerator, denominator
   End Type

   ' Create and initialize a Rational, and store its address.
   Dim p As Rational Ptr = New Rational(3, 4)

   Print p->numerator & "/" & p->denominator

   ' Destroy the rational and give its memory back to the system. 
   Delete p

   ' Set the pointer to null to guard against future accesses
   p = 0

   ' Allocate memory for 100 integers, store the address of the first one.
   Dim p As Integer Ptr = New Integer[100]

   ' Assign some values to the integers in the array.
   For i As Integer = 0 To 99
      p[i] = i
   Next

   ' Free the entire integer array.
   Delete[] p

   ' Set the pointer to null to guard against future accesses
   p = 0

Dialect Differences
   * Only available in the -lang fb dialect.

Differences from QB
   * New to FreeBASIC

See also
   * New Expression
   * Delete Overload
   * Deallocate



------------------------------------------------------- KeyPgDestructor ----
Destructor

Called automatically when a class or user defined type goes out of scope or 
is destroyed

Syntax
   Type typename
      field declarations
      Declare Destructor ( )
   End Type

   Destructor typename ( ) [ Export ]
      statements
   End Destructor

Parameters
   typename 
      name of the Type of Class

Description
   The destructor method is called when a user defined Type or Class 
   variable goes out of scope or is destroyed explicitly with the 
   Delete Statement operator.

   typename is the name of the type for which the Destructor method is 
   declared and defined.  Name resolution for typename follows the same 
   rules as procedures when used in a Namespace.

   The Destructor method is passed a hidden This parameter having the same 
   type as typename.

   The destructor in a type is called before the destructors on any of its 
   fields.  Therefore, all fields are accessible with the hidden This 
   parameter in the destructor body.

   Only one destructor may be declared and defined per type (but several 
   destructors can be called in a chained way if the type contains or 
   inherits other types with their own destructors).

   Since the End statement does not close any scope, object destructors 
   will not automatically be called if the End statement is used to 
   terminate the program.

   Destructor can be also called directly from the typename instance like 
   the other member methods (Sub) and with the same syntax, i.e. using a 
   member access operator, e.g. obj.Destructor(). The object, and all its 
   members, are assumed to be constructed and in a valid state, otherwise 
   its effects are undefined and may cause crashes.  This syntax is useful 
   in cases where obj has been constructed manually, e.g. with obj.
   Constructor() or Placement New.

Example
   Type T
     value As ZString * 32
     Declare Constructor ( init_value As String )
     Declare Destructor ()
   End Type

   Constructor T ( init_value As String )
     value = init_value
     Print "Creating: "; value
   End Constructor

   Destructor T ()
     Print "Destroying: "; value
   End Destructor

   Sub MySub
     Dim x As T = ("A.x")
   End Sub

   Dim x As T = ("main.x")

   Scope
     Dim x As T = ("main.scope.x")
   End Scope

   MySub

Output:

   Creating: main.x
   Creating: main.scope.x
   Destroying: main.scope.x
   Creating: A.x
   Destroying: A.x
   Destroying: main.x

Dialect Differences
   * Object-related features are supported only in the -lang fb dialect.

Differences from QB
   * New to FreeBASIC

See also
   * Class
   * Constructor
   * Delete Statement
   * Destructor (Module)
   * Type



------------------------------------------------- KeyPgModuleDestructor ----
Destructor (Module)

Specifies execution of a procedure at program termination

Syntax
   [Public | Private] Sub identifier [Alias "external_identifier"] [()] 
   Destructor [priority] [Static]
      { procedure body }
   End Sub

Description
   Defines a procedure to be automatically called from a compiled program's 
   end-code.  End-code is generated by the compiler and is executed when 
   the program terminates normally.  Procedures defined as destructors may 
   be used the same way as ordinary procedures, that is, they may be called 
   from within module-level code, as well as other procedures.  

   The procedure must have an empty parameter list.  A compile-time error 
   will be generated if the Destructor keyword is used in a Sub definition 
   having one or more parameters. In a set of overloaded procedures, only 
   one (1) destructor may be defined because of the ambiguity of having 
   multiple Subs which take no arguments.

   In a single module, depending on the build and run-time environment of 
   the target system:
      * destructors may execute in which they are defined, or reverse 
        order
      * destructors may execute before or after global static variables 
        having dstructors
      * destructors may execute before or after other module destructors 
        having priority attribute
      * destructors with priority attribute may execute before or after 
        global static variables having destructors

   The priority attribute, an integer between 101 and 65535, can be used to 
   force destructors to be executed in a certain order.  The value of 
   priority has no specific meaning, only the relationship of the number 
   with other destructor priorities. 101 is the lowest priority and is 
   executed last, relative to other destructors also having priority 
   attribute.

   A module may define multiple destructor procedures.  Destructor 
   procedures may also appear in more than one module. All procedures 
   defined with the syntax shown above will be added to the list of 
   procedures to be called during the program's termination.

   The order in which destructors defined in multiple modules are executed 
   is known only at link time.  Therefore, special care should be taken 
   when using destructors that may call on a secondary module also defining 
   a destructors.  In such a case it is advisable to use a single 
   destructor that explicit calls termination procedures in multiple 
   modules to ensure a graceful termination of the application.

   Destructors will be called if the program terminates normally or if 
   error-checking is enabled and the program terminates abnormally.

   Public static member procedures (a Sub having an empty parameter list), 
   of user defined Type can be defined as a module destructor, by adding 
   the Constructor keyword used in the sub procedure definition.

   The module destructor feature exposes a low-level link-time feature of 
   the build and run-time environment.  Accessing global static objects 
   having destructors from module destructors should be avoided due to 
   variations in execution order on different build systems.

   Warning for 64-bit compiler only: See the Identifier Rules page for the 
   choice of user procedure identifier names (and specially the 'Platform 
   Differences' paragraph).

Example
   Sub pauseonexit Destructor
      
      '' If the program reaches the end, or aborts with an error, 
      '' it will run this destructor before closing
      
      Print "Press any key to end the program..."
      Sleep
      
   End Sub

   Dim array(0 To 10, 0 To 10) As Integer
   Dim As Integer i = 0, j = 11

   '' this next line will cause the program to abort with an 
   '' error if you compile with array bounds checking enabled (fbc -exx ...)
   Print array(i, j)

Differences from QB
   * New to FreeBASIC

See also
   * Destructor (Class)
   * Constructor (Module)
   * Sub



-------------------------------------------------------------- KeyPgDim ----
Dim

Declares a variable

Syntax
      Dim [Shared] name1 As DataType [, name2 As DataType, ...]
   or
      Dim [Shared] As DataType name1 [, name2, ...]

   Arrays:
      Dim name ( [lbound To] ubound [, ...] ) As DataType
      Dim name ( Any [, Any...] ) As DataType
      Dim name ( ) As DataType

   Initializers:
      Dim scalar_symbol As DataType = expression | Any
      Dim array_symbol (arraybounds) As DataType = { expression [, ...] } | 
      Any
      Dim udt_symbol As DataType = ( expression [, ...] ) | Any

Description
   Declares a variable by name and reserves memory to accommodate it.

   Variables must be declared before they can be used in the -lang fb 
   dialect or when using Option Explicit in the other dialects.  Only in 
   the -lang qb and -lang fblite dialects variables may be used without 
   first declaring them, in such a case they are called implicit variables.

   Dim can be used to declare and assign variables of any of the supported 
   data types, user defined types, or enumerations.

   Depending on where and how a variable or array is declared can change 
   how it is allocated in memory.  See Storage Classes.

   More than one variable may be declared in a single Dim statement by 
   separating each variable declaration with a comma.

   '' Variable declaration examples

   '' One variable per DIM statement
   Dim text As String
   Dim x As Double

   '' More than one variable declared, different data types
   Dim k As Single, factor As Double, s As String

   '' More than one variable declared, all same data types
   Dim As Integer mx, my, mz ,mb

   '' Variable having an initializer
   Dim px As Double Ptr = @x

Explicit Variables with Implicit Data Types
   In the -lang qb and -lang fblite dialects, even if the variable is 
   declared explicitly, it will be given a default data type if the data 
   type is not explicitly given either by name or by type suffix.  The 
   default data type is Single in the -lang qb dialect and Integer in the 
   -lang fblite dialect.  The default data type can be changed throughout a 
   source listing by use of the Def### statements. (for example, DefInt, 
   DefStr, DefSng)

   '' Compile with -lang qb

   '$lang: "qb"

   '' All variables beginning with A through N will default to the INTEGER data type
   '' All other variables default to the SINGLE data type
   DefInt I-N

   Dim I, J, X, Y, T$, D As Double
   '' I and J are INTEGERs
   '' X and Y are SINGLEs
   '' T$ is STRING
   '' D is DOUBLE

Arrays
   As with most BASIC dialects, FreeBASIC supports arrays with indexes 
   ranging from a lower bound to an upper bound.  In the syntaxes shown, 
   lbound refers to the lower bound, or the smallest index.  ubound refers 
   to the upper bound, or the largest index.  If a lower bound is not 
   specified, it is assumed to be zero by default, unless Option Base is 
   used.

   Const upperbound = 10

   '' Declare an array with indexes ranging from 0 to upperbound, 
   '' for a total of (upperbound + 1) indexes.
   Dim array(upperbound) As Single

   Multidimensional arrays can be declared as well, and are stored in this 
   definite order: values differing only in the last index are contiguous 
   (row-major order).
   The maximum number of dimensions of a multidimensional array is 8. 

   '' declare a three-dimensional array of single 
   '' precision floating-point numbers.
   Dim array(1 To 2, 6, 3 To 5) As Single

   '' The first dimension of the declared array 
   '' has indices from 1 to 2, the second, 0 to 6, 
   '' and the third, 3 to 5.

			

   For more information on arrays see Arrays Overview.

   If the values used  with Dim to declare the dimensions of an array are 
   all constants, the array will be created fixed length (of Static size, 
   unless Option Dynamic is specified), while using one or more variables 
   to declare the dimensions of an array makes it variable length, even if 
   Option Static is in effect.

   Arrays can be declared as variable length in several ways: Using Dim 
   with an empty set of indexes (Dim x()), using Dim with indexes that are 
   variables or using the keyword ReDim, or using Any in place of the array 
   bounds, or declaring it past the metacommand $Dynamic. Variable length 
   arrays can't use initializers.

   Arrays declared with Dim having constant indexes and not preceeded by 
   Option Dynamic are fixed length (not resizable at runtime) and can use 
   initializers.

   The upper bound can be an ellipsis (..., 3 dots).  This will cause to 
   upper bound to be set automatically based on the number of elements 
   found in the initializer.  When ellipsis is used in this manner, an 
   initializer must be used, and it may not be Any.  See the Ellipsis page 
   for a short example.

   See also Fixed-Length Arrays and Variable-Length Arrays.

Initializers
   Arrays, variables, strings, and user defined types (UDTs) are 
   initialized to zero (or False for Boolean) or null strings by default 
   when they are created.

   To avoid the overhead of default variable initialization, the Any 
   initializer can be used with Dim to tell the compiler to only reserve 
   the place for the variable in memory but not initialize it, so the 
   variable will contain garbage. In this case the programmer should not 
   make assumptions about the initial values.

   Fixed-length arrays, variables, zstrings and UDTs may be given a value 
   at the time of their declaration by following the variable declaration 
   with an initializer.  Arrays, variables and UDTs are initialized as they 
   would in a normal assignment, using an equal ( = ) sign.  The => sign 
   can also be used, allowing to avoid the declaration resembling an 
   expression for example when declaring fixed length strings.

   Array values are given in comma-delimited values enclosed by curly 
   brackets, and UDT values are given in comma delimited values enclosed by 
   parenthesis.  These methods of initializing variables can be nested 
   within one another for complex assignments. Nesting allows for arrays of 
   any dimension to be initialized.

   '' Declare an array of 2 by 5 elements
   '' and initialize
   Dim array(1 To 2, 1 To 5) As Integer => {{1, 2, 3, 4, 5}, {1, 2, 3, 4, 5}}

			

   '' declare a simple UDT
   Type mytype
      var1 As Double
      var2 As Integer
   End Type

   '' declare a 3 element array and initialize the first
   '' 2 mytype elements
   Dim myvar(0 To 2) As mytype => {(1.0, 1), (2.0, 2)}

	
   For module-level, fixed-length, or global variables, initialized values 
   must be constant expressions.  FreeBASIC will report a compile-time 
   error if otherwise.

   Note: Initializing UDT's with strings is not supported at this time. 
   Initializing UDT containing data-field initializer or string is not 
   valid.  Initializing UDT derived directly or indirectly from the the 
   built-in Object type is not valid.

Explicit Variables with Type Suffixes
   In the -lang qb and -lang fblite dialects, the data type of a variable 
   may be indicated with a type suffix ( $ % # ! & ).

   '' Compile with -lang qb or fblite

   '$lang: "qb"

   '' A string variable using the $ type suffix
   Dim strVariable$

   '' An integer variable using the % type suffix
   Dim intVariable%

   '' A long variable using the & type suffix
   Dim lngVariable&

   '' A single precision floating point variable using the ! type suffix
   Dim sngVariable!

   '' A double precision floating point variable using the # type suffix
   Dim dblVariable#

Example
   Dim a As Byte
   Dim b As Short
   Dim c As Integer
   Dim d As LongInt
   Dim au As UByte
   Dim bu As UShort
   Dim cu As UInteger
   Dim du As ULongInt
   Dim e As Single
   Dim f As Double
   Dim g As Integer Ptr
   Dim h As Byte Ptr
   Dim s1 As String * 10   '' fixed length string
   Dim s2 As String        '' variable length string
   Dim s3 As ZString Ptr   '' zstring

   s1 = "Hello World!"
   s2 = "Hello World from FreeBASIC!"
   s3 = Allocate( Len( s2 ) + 1 )
   *s3 = s2

   Print "Byte: "; Len(a)
   Print "Short: "; Len(b)
   Print "Integer: "; Len(c)
   Print "Longint: "; Len(d)
   Print "UByte: "; Len(au)
   Print "UShort: "; Len(bu)
   Print "UInteger: "; Len(cu)
   Print "ULongint: "; Len(du)
   Print "Single: "; Len(e)
   Print "Double: "; Len(f)
   Print "Integer Pointer: "; Len(g)
   Print "Byte Pointer: "; Len(h)
   Print "Fixed String: "; Len(s1)
   Print "Variable String: "; Len(s2)
   Print "ZString: "; Len(*s3)

   Deallocate(s3)

Dialect Differences
   * In the -lang qb and -lang fblite dialects, variables have procedure 
     scope if the variable is defined inside a procedure, and for the 
     entire module if the variable is defined with Dim Shared.
   * In the -lang qb dialect, variables cannot be initialised.  In the 
     -lang fblite dialect, the variable is initialised with a default value 
     at the start of the procedure/module, and assigned its initial value 
     if/when the Dim statement is executed at runtime.
   * In the -lang fb and -lang deprecated dialects, variables declared 
     inside compound block statements (For..Next, While..Wend, Do..Loop, 
     If..Then, Select..End Select, With..End With, Scope..End Scope) have 
     local working scopes, and are visible only within these blocks. To 
     access duplicated symbols defined as global outside these blocks, add 
     one or preferably two dot(s) as prefix: .SomeSymbol or preferably ..
     SomeSymbol (or only ..SomeSymbol if inside a With..End With block).
   * In the -lang fb dialect, Option statements (e.g. Option Base, 
     Option Dynamic), metacommands(e.g. $Static) and Def### statements 
     (e.g. DefInt) are not allowed.

Differences from QB
   * Variable Initializers are new to FreeBASIC.
   * The alternate syntax Dim As DataType symbolname, [...] is new to 
     FreeBASIC.
   * Multidimensional arrays are stored in this definite order: values 
     differing only in the last index are contiguous (row-major order), 
     they were stored in opposite order in QB by default: values differing 
     only in the first index were contiguous (column-major order).
   * Variable length arrays up to 2 GiB in size are possible in FreeBASIC. 
     In QB, $STATIC arrays were limited to 64 KiB , or to the DOS memory 
     available (several 100 KiB at best) if made $DYNAMIC and /AH was used.
   * The ellipsis form for upper bounds is new to FreeBASIC.

See also
   * Var
   * Common
   * Extern
   * ReDim
   * Preserve
   * Shared
   * Static
   * Byref (Variables)
   * Erase
   * LBound
   * UBound
   * ... (Ellipsis)
   * Any
   * Pointers to Procedures



-------------------------------------------------------------- KeyPgDir ----
Dir

Searches for and returns information about an item in the filesystem; 
performs a directory searchattrib

Syntax
   # Include "dir.bi"

   Declare Function Dir ( ByRef item_spec As Const String, ByVal 
   attrib_mask As Integer = fbNormal, ByRef out_attrib As Integer ) As 
   String
   Declare Function Dir ( ByRef item_spec As Const String, ByVal 
   attrib_mask As Integer = fbNormal, ByVal p_out_attrib As Integer Ptr = 0 
   ) As String
   Declare Function Dir ( ByVal attrib_mask As Integer = fbNormal, ByRef 
   out_attrib As Integer ) As String
   Declare Function Dir ( ByVal attrib_mask As Integer = fbNormal, ByVal 
   p_out_attrib As Integer Ptr = 0 ) As String

Usage
   result = Dir( item_spec, [ attrib_mask ], out_attrib ] )
   result = Dir( item_spec [, [ attrib_mask ] [, p_out_attrib ] ] )
   result = Dir( out_attrib )
   result = Dir( [ p_out_attrib ] )

Parameters
   item_spec
      The pattern to match an item's name against.
   attrib_mask
      The bit mask to match an item's attributes against.
   out_attrib
      Reference to a bit mask that's assigned each of the found item's 
      attributes, if any.
   p_out_attrib
      Pointer to a bit mask that's assigned each of the found item's 
      attributes, if any.

Return Value
   If no item matching the name item_spec or the attribute mask attrib_mask 
   was found, then out_attrib (or *p_out_attrib) is assigned to zero and an 
   empty string is returned. Otherwise, out_attrib (or *p_out_attrib) is 
   assigned the attribute mask of the item, and the item name, without a 
   path, is returned.

Description
   Dir returns the first filesystem item that matches the item_spec passed 
   as an argument. To retrieve the next file items that match this 
   item_spec pattern, call Dir again without this argument (or with an 
   empty string).
   So to obtain a list of items in a directory, Dir needs to be invoked 
   multiple times returning one item per invocation.

   If item_spec contains an absolute path, then the first procedure 
   searches the filesystem for an item that matches the name item_spec and 
   whose attributes are all contained in attrib_mask (fbNormal by default). 
   Otherwise, it searches relative to the current directory (see CurDir). 
   In any case, if a matching item is not found, out_attrib is assigned to 
   zero and an empty string is returned. Otherwise, out_attrib is assigned 
   with the attribute flags of the item, and the name of the item, without 
   a path, is returned.
   item_spec may include an asterisk (*, for matching any adjacent 
   characters) or one or more question marks (?, for matching any 
   individual character). If it does, the procedure searches for the first 
   such item.

   If an item is found, subsequent calls with item_spec omitted, or set to 
   an empty string, will return the next item matching the name item_spec 
   until no more such items are found. If attrib_mask is omitted from these 
   subsequent calls, the procedure searches for items with the same 
   attributes as in the previous call.

   The second syntax behaves the same as Dir( item_spec, attrib_mask, *
   p_out_attrib ).
   The third syntax behaves the same as Dir( "", , out_attrib ).
   The fourth syntax behaves the same as Dir( "", , *p_out_attrib ).

File Attributes:
   Files and directories and other items can be said to possess so-called 
   file attributes; metadata that describes the item. The meaning of this 
   metadata may vary depending on the operating system and the file system 
   it uses.
   The following defined constants are used as bit-flags in attrib_mask and 
   in out_attrib or *p_out_attrib. Their values can be combined to form a 
   mask using Operator Or. These values are the metadata that the returned 
   files are allowed to have. To access the defined flags, you must #include
   "dir.bi".

   Assuming the reader understands 'file' to mean any file system entry: 
   normal file, directory, etc.
   attrib_mask specifies the set of file attributes that are permitted for 
   file names returned (if a file has an attribute that is not specified in 
   attrib_mask, then it is excluded from file names returned).
   For example:
      fbDirectory will only allow the directory attribute not to be set, 
      meaning that only files or directories with no other attributes set 
      will be matched.
      (fbReadOnly Or fbDirectory) will allow read-only directories and 
      files, and writable directories and files.
      fbArchive Or fbDirectory will match against archived files, archived 
      directories, non-archived files and non-archived directories (it will 
      not match against, for example, read-only files).
   Logic condition:
         file name returned by Dir if the equality '((attrib_mask) OR 
         (file_attrib)) = (attrib_mask)' is true
      or
         file name returned by Dir if ((file_attrib) AND (Not attrib_mask)) 
         = 0

   More powerful filtering can be done by checking the returned out_attrib 
   for specifc flags using Operator And.

    # define fbReadOnly &h01 
      The item cannot be written to or deleted.
      DOS & Windows: The item has the "read-only" attribute set.
      Linux:The item has no write permissions associated with the current 
      user or group, nor is it globally writable.  (Whether or not the user 
      has root permissions is ignored.)

    # define fbHidden &h02 
      The item is hidden in ordinary directory listings.
      DOS & Windows: The item has the "hidden" attribute set.
      Linux: The item's name has a period (.) as the first character.

    # define fbSystem &h04 
      The item is used almost exclusively by the system.
      DOS & Windows: The item has the "system" attribute set.
      Linux: The item is either a character device, block device, named 
      pipe (FIFO) or Unix socket.

    # define fbDirectory &h10  
      The item is a directory. Includes the current (.) and parent (..) 
      directories as well.
      DOS & Windows & Linux: The item is a directory.

    # define fbArchive &h20 
      The item may be backed up after some automated operations.
      DOS & Windows: The item has the "archive" attribute set 
      (automatically set after every write access to a file).
      Linux: The item is not a directory; typical filesystems do not 
      support this metadata.

    # define fbNormal (fbReadOnly or fbArchive) 
      The item is read-only or "archived".

   (If attrib_mask does not include fbArchive, then Dir may widen the check 
   to include fbDirectory, but it is recommended to add fbDirectory 
   explicitly, if that is the behaviour sought.)

   Items found having no attributes are always matched, regardless of the 
   value of attrib_mask.
   An item will not be matched if it has one or more attributes that aren't 
   specified in attrib_mask.

   In general it is not possible to use attrib_mask to include a 
   file/folder with one set of attributes while excluding a file/folder 
   with a different set. For example, it is not possible to scan for 
   read-only directories while excluding read-only files (unless the files 
   also have other attributes).
   Finer control can be gained by checking the out_attrib value for the 
   desired set of attributes.

Example
   ' Number of files in the current directory.

   Dim As Integer FileCount

   If Dir("*") <> "" Then  ' Start a file search with no specified filespec/attrib *AND* get the first filename.
      Filecount = 1
      While Dir() <> ""  ' If dir() is "", exit the loop: no more filenames are left to be read.
         FileCount += 1  ' Increment the counter of number of files
      Wend
   End If

   Print FileCount & " files in the current directory."

   Sleep
      

   #include "dir.bi" 'provides constants to use for the attrib_mask parameter

   Sub list_files (ByRef filespec As String, ByVal attrib As Integer)
      Dim As String filename = Dir(filespec, attrib) ' Start a file search with the specified filespec/attrib *AND* get the first filename.
      Do While Len(filename) > 0 ' If len(filename) is 0, exit the loop: no more filenames are left to be read.
         Print filename
         filename = Dir() ' Search for (and get) the next item matching the initially specified filespec/attrib.
      Loop
   End Sub

   Print "directories:"
   list_files "*", fbDirectory

   Print
   Print "archive files:"
   list_files "*", fbArchive
      

   '' show any files that have directory attribute and don't care if it is system, hidden, read-only, or archive

   #include Once "dir.bi"

   '' allow everything
   Var mask = fbDirectory Or fbHidden Or fbSystem Or fbArchive Or fbReadOnly

   Var attrib = 0
   Var f = Dir( "*.*", mask, attrib )
   While( f > "" )
      '' show any files that have at least a directory attribute
      If( attrib And fbDirectory ) Then
         Print f
      End If
      f = Dir( attrib )
   Wend
      

   '' Example of using DIR function and retrieving attributes

   #include "dir.bi" '' provides constants to match the attributes against

   '' set input attribute mask to allow files that are normal, hidden, system or directory
   Const attrib_mask = fbNormal Or fbHidden Or fbSystem Or fbDirectory ' = &h37

   Dim As UInteger out_attr '' unsigned integer to hold retrieved attributes

   Dim As String fname '' file/directory name returned with
   Dim As Integer filecount, dircount

   fname = Dir("*.*", attrib_mask, out_attr) '' Get first file name/attributes, according to supplied file spec and attribute mask

   Print "File listing in " & CurDir & ":"

   Do Until Len(fname) = 0 '' loop until Dir returns empty string

      If (fname <> ".") And (fname <> "..") Then '' ignore current and parent directory entries

         Print fname,

         If (out_attr And fbDirectory) <> 0 Then
            Print "- directory";
            dircount += 1
         Else
            Print "- file";
            filecount += 1
         End If
         If (out_attr And fbReadOnly) <> 0 Then Print ", read-only";
         If (out_attr And fbHidden  ) <> 0 Then Print ", hidden";
         If (out_attr And fbSystem  ) <> 0 Then Print ", system";
         If (out_attr And fbArchive ) <> 0 Then Print ", archived";
         Print

      End If

      fname = Dir(out_attr) '' find next name/attributes

   Loop

   Print
   Print "Found " & filecount & " files and " & dircount & " subdirs"
      

Platform Differences
   * Linux requires the filename case to match the real name of the file. 
     Windows and DOS are case insensitive.
   * Path separators in Linux are forward slashes /. Windows uses 
     backslashes \ but it allows for forward slashes.  DOS uses 
     backslashes.
   * In DOS, the attrib mask value of &h37 (&h3F usually works also, but 
     &h37 is safer) returns all files and directories, including "." and 
     "..", but no Volume: the value 8 returns the Volume, even if current 
     directory is not the main directory.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Dir.

Differences from QB
   * Not found in QBasic but present in Visual Basic.  The out_attrib 
     parameter is new to FreeBASIC.

See also
   * Open
   * CurDir
   * ChDir
   * MkDir
   * RmDir



--------------------------------------------------------------- KeyPgDo ----
Do

Control flow statement for looping.

Syntax
   Do [ { Until | While } condition ]
      [ statement block ]
   Loop

   Do
      [ statement block ]
   Loop [ { Until | While } condition ]

Example
   See example at Do...Loop.

Differences from QB
   * None

See also
   * Do...Loop

   

----------------------------------------------------------- KeyPgDoloop ----
Do...Loop

Control flow statement for looping

Syntax
   Do [ { Until | While } condition ]
      [ statement block ]
   Loop
or
   Do
      [ statement block ]
   Loop [ { Until | While } condition ]

Description
   The Do statement executes the statements in the following statement 
   block until/while the condition, if any,  evaluates to true.

   If Until is used, the Do statement stops repetition of the statement 
   block when condition evaluates to true. The While keyword has opposite 
   effect, stopping the loop if condition evaluates to false. If both 
   condition and either Until or While are omitted, the Do statement loops 
   indefinitely.

   If an Exit Do statement is encountered inside the statement block, the 
   loop is terminated, and execution resumes immediately following the 
   enclosing Loop statement. If a Continue Do statement is encountered, the 
   rest of the statement block is skipped and execution resumes at the Do 
   statement.

   In the first syntax, the condition is checked when the Do statement is 
   first encountered, and if the condition is met, the statement block will 
   be skipped. In the second syntax, condition is initially checked after 
   the statement block is executed. This means that the statement block is 
   always guaranteed to execute at least once.

   condition may be any valid expression that evaluates to False (zero) or 
   True (non-zero).

Example
   In this example, a Do loop is used to count the total number of odd 
   numbers from 1 to 10. It will repeat until its n > 10 condition is met:
   Dim As Integer n = 1                            '' number to check
   Dim As Integer total_odd = 0                    '' running total of odd numbers
   Do Until( n > 10 )
     If( ( n Mod 2 ) > 0 ) Then total_odd += 1    '' add to total if n is odd (has remainder from division by 2)
     n += 1
   Loop
   Print "total odd numbers: " ; total_odd         '' prints '5'

   End 0

   Here, an infinite DO loop is used to count the total number of evens. We 
   place the conditional check inside the loop via an If...Then statement, 
   which exits the loop if and when n > 10 becomes true:
      Dim As Integer n = 1                            '' number to check
      Dim As Integer total_even = 0                   '' running total of even numbers
      Do
        If( n > 10 ) Then Exit Do                    '' exit if we've scanned our 10 numbers
      
        If( ( n Mod 2 ) = 0 ) Then total_even += 1   '' add to total if n is even (no remainder from division by 2)
        n += 1
      Loop
      Print "total even numbers: " ; total_even       '' prints '5'

      End 0

Dialect Differences
   * In the -lang qb and -lang fblite dialects, variables declared inside 
     a Do..Loop block have a function-wide scope  as in QB 
   * In the -lang fb and -lang deprecated dialects, variables declared 
     inside a Do..Loop block are visible only inside the block, and can't 
     be accessed outside it. To access duplicated symbols defined as global 
     outside this block, add one or preferably two dot(s) as prefix: .
     SomeSymbol or preferably ..SomeSymbol (or only ..SomeSymbol if inside 
     a With..End With block).

Differences from QB
   * None

See also
   * Continue
   * Exit
   * For...Next
   * While...Wend



----------------------------------------------------------- KeyPgDouble ----
Double

Standard data type: 64 bit floating point

Syntax
   Dim variable As Double

Description
   Double is a 64-bit, floating-point data type used to store more precise 
   decimal numbers. They can hold positive values in the range 
   4.940656458412465e-324 to 1.797693134862316e+308, or negative values in 
   the range -4.940656458412465e-324 to -1.797693134862316e+308, or zero (0)
   . They contain at most 53 bits of precision, or about 15 decimal digits.

   Doubles have a greater range and precision than Singles, they still have 
   limited accuracy which can lead to significant inaccuracies if not used 
   properly.  They are dyadic numbers - i.e. they can only accurately hold 
   multiples of powers of two, which will lead to inaccuracies in most 
   base-10 fractions.

Example
   'Example of using a double variable.

   Dim a As Double
   a = 1.985766472453666
   Print a

   Sleep

Differences from QB
   * None

See also
   * Single Less precise float type
   * CDbl
   * Table with variable types overview, limits and suffixes



------------------------------------------------------------- KeyPgDraw ----
Draw

Statement for sequenced pixel plotting

Syntax
   Draw [target,] cmd

Parameters
   target
      the buffer to draw on
   cmd
      a string containing the sequence of commands

Description
   Drawing will take place onto the current work page set via ScreenSet or 
   onto the target Get/Put buffer if specified.
   The Draw statement can be used to issue several drawing commands all at 
   once; it is useful to quickly draw figures. The command string accepts 
   the following commands:

   Commands to plot pixels:
      +-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
      |Command|Description                                                                                                                                                   |
      |       |Commands to plot pixels:                                                                                                                                      |
      |B      |Optional prefix: move but do not draw.                                                                                                                        |
      |N      |Optional prefix: draw but do not move.                                                                                                                        |
      |M x,y  |Move to specified screen location. if a '+' or '-' sign precedes x, movement is relative to current cursor position.  x's sign has no effect on the sign of y.|
      |U [n]  |Move n units up. If n is omitted, 1 is assumed.                                                                                                               |
      |D [n]  |Move n units down. If n is omitted, 1 is assumed.                                                                                                             |
      |L [n]  |Move n units left. If n is omitted, 1 is assumed.                                                                                                             |
      |R [n]  |Move n units right. If n is omitted, 1 is assumed.                                                                                                            |
      |E [n]  |Move n units up and right. If n is omitted, 1 is assumed.                                                                                                     |
      |F [n]  |Move n units down and right. If n is omitted, 1 is assumed.                                                                                                   |
      |G [n]  |Move n units down and left. If n is omitted, 1 is assumed.                                                                                                    |
      |H [n]  |Move n units up and left. If n is omitted, 1 is assumed.                                                                                                      |
      |       |Commands to color:                                                                                                                                            |
      |C n    |Changes current foreground color to n.                                                                                                                        |
      |P p,b  |PAINTs (flood fills) region of border color b with color p.                                                                                                   |
      |       |Commands to scale and rotate:                                                                                                                                 |
      |S n    |Sets the current unit length, default is 4.  A unit length of 4 is equal to 1 pixel.                                                                          |
      |A n    |Rotate n*90 degrees (n ranges 0-3).                                                                                                                           |
      |TA n   |Rotate n degrees (n ranges 0-359).                                                                                                                            |
      |       |Extra commands:                                                                                                                                               |
      |X p    |Executes commands at p, where p is a STRING PTR.                                                                                                              |
      +-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+

   Commands to set the color, size and angle will take affect all 
   subsequent Draw operations.

Draw respects the current clipping region as set by the View (Graphics) 
statement, but its coordinates are not affected by the custom coordinates 
system.

Example
   Screen 13

   'Move to (50,50) without drawing
   Draw "BM 50,50"

   'Set drawing color to 2 (green)
   Draw "C2"

   'Draw a box
   Draw "R50 D30 L50 U30"

   'Move inside the box
   Draw "BM +1,1"

   'Flood fill with color 1 (blue) up to border color 2 
   Draw "P 1,2"

   Sleep

   '' Draws a flower on-screen

   Dim As Integer i, a, c
   Dim As String fill, setangle

   '' pattern for each petal
   Dim As Const String petal = _
      _
      ("X" & VarPtr(setangle)) _ '' link to angle-setting string
      _
      & "C15" _       '' set outline color (white)
      & "M+100,+10" _ '' draw outline
      "M +15,-10" _
      "M -15,-10" _
      "M-100,+10" _
      _
      & "BM+100,0" _              '' move inside petal
      & ("X" & VarPtr(fill)) _    '' flood-fill petal (by linking to fill string)
      & "BM-100,0"                '' move back out

   '' set screen
   ScreenRes 320, 240, 8

   '' move to center
   Draw "BM 160, 120"

   '' set initial angle and color number
   a = 0: c = 32

   For i = 1 To 24

      '' make angle-setting and filling command strings
      setangle = "TA" & a
      fill = "P" & c & ",15"

      '' draw the petal pattern, which links to angle-setting and filling strings
      Draw petal
      
      '' short delay
      Sleep 100

      '' increment angle and color number
      a += 15: c += 1

   Next i

   Sleep

Differences from QB
   * target is new to FreeBASIC
   * QB used the special pointer keyword VARPTR$ with the X p command.
   * FB does not currently allow sub-pixel movements: all movements are 
     rounded to the nearest integer coordinate.

See also
   * Draw String
   * Screen (Graphics)
   * VarPtr
   * Paint



------------------------------------------------------- KeyPgDrawString ----
Draw String

Graphics statement to render text to an image or screen.

Syntax
   Draw String [buffer,] [STEP] (x, y), text [,color [, font [, method [, (
   alpha|blender) [, parameter] ] ] ] ]

Usage
   Draw String [buffer,] [STEP] (x, y), text [, color]
   Draw String [buffer,] [STEP] (x, y), text , , font [, method [, alpha ] 
   ]
   Draw String [buffer,] [STEP] (x, y), text , , font, Custom, blender [, 
   parameter]

Parameters
   buffer
      the sprite to draw the string on. If this is not supplied, it will be 
      drawn to the screen.
   STEP
      use relative coordinates. If STEP is added, the x and y coordinates 
      are translated relative to the last drawn point.
   x, y
      the horizontal / vertical position to draw to, relative to the top 
      left hand corner of the screen (unless STEP is used - see above).  
      The top left corner of the text will be drawn at this position.
   text
      the string containing the text to draw
   color
      if no font is supplied, this allows you to choose the color of the 
      text.  If omitted, the default foreground Color is used.
      If a font is supplied, color is ignored, and the font itself 
      specifies the color for each pixel.
   font
      an image buffer containing a custom font. If no font is supplied, the 
      standard font for the current text resolution is used, and the 
      following parameters are ignored.
   method | Custom
      specifies how the font characters are drawn on top of the target 
      surface. The same methods as found for the Put statement are allowed, 
      with the only difference that the default method is Trans for this 
      function.  This parameter only applies to custom fonts.
   alpha
      alpha value, ranging 0-255.  This parameter only applies to the Add 
      or Alpha methods.
   blender
      custom blender function for the Custom drawing method; see 
      Put (Graphics) statement description for details.  This parameter 
      only applies to the Custom method.
   parameter
      optional Pointer to be passed to the custom blender function; if 
      omitted, the default value is zero (0).

Description
   This graphics keyword prints a string to the screen with pixel 
   positioning, transparent background, and can use an user-supplied font. 
   Draw String does not update any text or graphics cursor.  It doesn't 
   wrap at the end of line.  Tabs, carriage returns and other special 
   characters have no special behavior in Draw String, and are treated as 
   normal characters.

   In graphics mode, this function provides a flexible alternative to Print
   .  It has several key advantages:
      * Draw String can print text to any coordinate on the screen, while 
        Print is constrained to the character grid accessible by Locate.
      * Print will override the background behind the text with the 
        current background color.  Draw String does not do this: it leaves 
        the pixels in the background untouched.
      * Like Put, Draw String has several different methods for printing 
        text, such as Alpha and Custom.
      * Draw String isn't limited to a single character set: it is 
        possible to supply a custom font to be used instead.

   Note: If a custom font isn't supplied, Draw String will default to the 
   standard font, as used by Print, with character size dictated by Width.  
   method - if passed - will be ignored, and the text will be drawn using 
   the color supplied, with a transparent background.

   Draw String coordinates are affected by custom coordinates system set 
   via Window and View (Graphics) statements, and the drawn text respects 
   clipping rectangle set by View (Graphics).

   The custom font format:
   The font is stored in a standard Get/Put buffer; the font has to be 
   stored in a buffer using the same depth as the current color depth, 
   otherwise Draw String will bump out with an illegal function call 
   runtime error.

   The first line of pixels in the font buffer holds the header of the 
   font, on a byte (not pixel) basis. The very first byte identifies the 
   font header version; currently this must be 0. The second byte gives the 
   ascii code of the first supported character in the font; the third byte 
   gives the ascii code of the last supported character. So if the font 
   supports the full range 0-255, 0 and 255 will be the contents of these 
   two bytes.
   Next comes the width of each of the supported characters, each in a 
   byte. Supposing the font holds 96 characters, ranging from 32 to 127 
   (inclusive), the header would have the first three bytes holding 0, 32 
   and 127, followed by 96 bytes giving the widths of the corresponding 
   chars.

   The font height is obtained by subtracting 1 from the buffer height, 
   that is, while the first buffer line of pixels acts as a font header, 
   the remaining lines define the glyphs' layout. The buffer must be as 
   wide as necessary to hold all the supported character sprites in the 
   same row, one after another.

Example
   This gives an example of basic Draw String usage: it uses it to print 
   "Hello world" in the center of the screen:
   Const w = 320, h = 200 '' screen dimensions

   Dim x As Integer, y As Integer, s As String

   '' Open a graphics window
   ScreenRes w, h

   '' Draw a string in the centre of the screen:

   s = "Hello world"
   x = (w - Len(s) * 8) \ 2
   y = (h - 1 * 8) \ 2

   Draw String (x, y), s

   '' Wait for a keypress before ending the program
   Sleep

   This example shows you how to create and use your own custom font.  For 
   simplicity, it uses Draw String with the default font to create the 
   glyphs.
   '' Define character range
   Const FIRSTCHAR = 32, LASTCHAR = 127

   Const NUMCHARS = (LASTCHAR - FIRSTCHAR) + 1
   Dim As UByte Ptr p, myFont
   Dim As Integer i

   '' Open a 256 color graphics screen (320*200)
   ScreenRes 320, 200, 8

   '' Create custom font into PUT buffer

   myFont = ImageCreate(NUMCHARS * 8, 9)

    '' Put font header at start of pixel data

   #ifndef ImageInfo '' older versions of FB don't have the ImageInfo feature
   p = myFont + IIf(myFont[0] = 7, 32, 4)
   #else
   ImageInfo( myFont, , , , , p )
   #endif

   p[0] = 0
   p[1] = FIRSTCHAR
   p[2] = LASTCHAR

    '' PUT each character into the font and update width information
   For i = FIRSTCHAR To LASTCHAR
      
      '' Here we could define a custom width for each letter, but for simplicity we use
      '' a fixed width of 8 since we are reusing the default font glyphs
      p[3 + i - FIRSTCHAR] = 8
      
      '' Create character onto custom font buffer by drawing using default font
      Draw String myFont, ((i - FIRSTCHAR) * 8, 1), Chr(i), 32 + (i Mod 24) + 24
      
   Next i

   '' Now the font buffer is ready; we could save it using BSAVE for later use
   Rem BSave "myfont.bmp", myFont

   '' Here we draw a string using the custom font
   Draw String (10, 10), "ABCDEFGHIJKLMNOPQRSTUVWXYZ", , myFont
   Draw String (10, 26), "abcdefghijklmnopqrstuvwxyz", , myFont
   Draw String (66, 58), "Hello world!", , myFont

   '' Free the font from memory, now we are done with it
   ImageDestroy myFont

   Sleep

Differences from QB
   * New to FreeBASIC

See also
   * Print
   * ?
   * Draw
   * ImageCreate
   * ImageDestroy
   * ImageInfo
   * Put (Graphics)
   * Width



-------------------------------------------------------- KeyPgDylibfree ----
DyLibFree

Unloads a dynamic link library from memory

Syntax
   Declare Sub DyLibFree ( ByVal libhandle As Any Pointer )

Usage
   DyLibFree( libhandle )

Parameters
   libhandle
      The handle of a library to unload.

Description
   DyLibFree is used to release at runtime libraries previously linked to 
   your program with DyLibLoad. The argument is the handle to the library 
   returned by DyLibLoad.

Example
   See the dynamic loading example on the Shared Libraries page.

Platform Differences
   * Dynamic link libraries are not available in DOS, as the OS doesn't 
     support them.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Dylibfree.

Differences from QB
   * New to FreeBASIC

See also
   * DyLibSymbol
   * DyLibLoad
   * Export



-------------------------------------------------------- KeyPgDylibload ----
DyLibLoad

Loads to a Dynamic Link Library (DLL) into memory at runtime

Syntax
   Declare Function DyLibLoad ( ByRef libname As String ) As Any Pointer

Usage
   result = DyLibLoad ( libname )

Parameters
   libname
      A String containing the name of the library to load.

Return Value
   The Pointer handle of the library loaded. Zero on error

Description
   DyLibLoad is used to link at runtime libraries to your program. This 
   function does the link and returns a handle that must be used with 
   DyLibSymbol when calling a function in the library and with DyLibFree 
   when releasing the library.

   Note: If the libname string (without extension) already includes a 
   character dot (.), it may be mandatory to explicitly specify the 
   filename extension to avoid any parser ambiguity.

Example
   See the dynamic loading example on the Shared Libraries page.

Platform Differences
   * Dynamic link libraries are not available in DOS, as the OS doesn't 
     support them.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Dylibload.

Differences from QB
   * New to FreeBASIC

See also
   * DyLibSymbol
   * DyLibFree
   * Export



------------------------------------------------------ KeyPgDylibsymbol ----
DyLibSymbol

Returns the address of a function or variable in a dll

Syntax
   Declare Function DyLibSymbol ( ByVal libhandle As Any Ptr, ByRef symbol 
   As String ) As Any Ptr
   Declare Function DyLibSymbol ( ByVal libhandle As Any Ptr, ByVal symbol 
   As Short ) As Any Ptr

Usage
   result = DyLibSymbol ( libhandle, symbol )

Parameters
   libhandle
      The Any Ptr handle of a DLL returned by DyLibLoad
   symbol
      A String containing name of the function, or variable in the library 
      to return the address of.  In Windows only, can also be a Short 
      containing the ordinal of the function/variable.

Return Value
   A Pointer to the function or variable in the library.

   If the function fails, the return value is 0.

Description
   DyLibSymbol returns a pointer to the variable or function named symbol , 
   in the dll pointed by libhandle. libhandle is obtained by loading the 
   dll with DyLibLoad. The symbol must have been Exported in the dll.
   If libhandle is 0, the symbol is searched in the current executable or 
   dll.

   If using cdecl functions, only the name of the procedure needs to be 
   specified. If dynamically linking to a function created using STDCALL 
   (default in windows), then the function must be decorated. To decorate a 
   function, use its name, '@', then the number of bytes passed as 
   arguments. For instance if the function FOO takes 3 integer arguments, 
   the decorated function would be 'FOO@12'. Remember, without an explicit 
   Alias, the procedure name will be uppercase.

   If linking to a dll created in Visual C++(tm), decoration need not be 
   used. For GCC, decoration is needed.

   Note: The dylibsymbol, if failing, will attempt to automatically 
   decorate the procedure, from @0 to @256, in 4 byte increments.

Example
   See the dynamic loading example on the Shared Libraries page.

Platform Differences
   * Dynamic link libraries are not available in DOS ,as the OS doesn't 
     support them.
   * Ordinals are not supported on Linux, 0 is always returned.
   * Windows does not support DyLibSymbol use with variables (only with 
     procedures).

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Dylibsymbol.

Differences from QB
   * New to FreeBASIC

See also
   * DyLibLoad
   * Export




============================================================================
    E

------------------------------------------------------------- KeyPgElse ----
Else

Control flow statement for conditional branching

Syntax
   If expression Then [statement(s)] [Else [statement(s)]] [End If]
or
   If expression Then : [statement(s)] [Else [statement(s)]] : End If
or
   If expression Then
      [statement(s)]
   [ ElseIf expression Then ]
      [statement(s)]
   [ Else ]
      [statement(s)]
   End If

   Remark: EndIf (without blank) is also supported like in QB for backward 
   compatibility.

Example
   See example at If...Then.

Differences from QB
   * None

See also
   * If...Then



----------------------------------------------------------- KeyPgElseif ----
ElseIf

Control flow statement for conditional branching

Syntax
   If expression Then
      [statement(s)]
   [ ElseIf expression Then ]
      [statement(s)]
   [ Else ]
      [statement(s)]
   End If

   Remark: EndIf (without blank) is also supported like in QB for backward 
   compatibility.

Example
   See example at If...Then.

Differences from QB
   * None

See also
   * If...Then



--------------------------------------------------------- KeyPgEncoding ----
Encoding

Specifies character format of a text file

Syntax
   Open filename for {Input|Output|Append} Encoding "utf-8"|"utf-16"|"
   utf-32"|"ascii" as [#]filenum 

Parameters
   filename for {Input|Output|Append}
      file name to open for Input, Output, or Append
   Encoding "utf-8"|"utf-16"|"utf-32"|"ascii"
      indicates encoding type for the file
   filenum
      unused file number to associate with the open file

Description
   Encoding specifies the format for an Unicode text file, so Winput # and 
   Print # use the correct encoding.  If omitted from an Open statement, 
   "ascii" encoding is the default.

   Only little endian character encodings are supported at the moment. 
      *"utf8", 
      *"utf16" 
      *"utf32" 
      *"ascii" (the default)

Example
   '' This example will:
   '' 1) Write a string to a text file with utf-16 encoding
   '' 2) Display the byte contents of the file
   '' 3) Read the text back from the file
   ''
   '' WSTRING's will work as well but STRING has been
   '' used in this example since not all consoles support
   '' printing WSTRING's.

   '' The name of the file to use in this example
   Dim f As String
   f = "sample.txt"

   ''
   Scope
     Dim s As String
     s = "FreeBASIC"

     Print "Text to write to " + f + ":"
     Print s
     Print

     '' open a file for output using utf-16 encoding
     '' and print a short message
     Open f For Output Encoding "utf-16" As #1

     '' The ascii string is converted to utf-16
     Print #1, s
     Close #1
   End Scope

   ''
   Scope
     Dim s As String, n As Integer

     '' open the same file for binary and read all the bytes
     Open f For Binary As #1
     n = LOF(1)
     s = Space( n )
     Get #1,,s
     Close #1
     
     Print "Binary contents of " + f + ":"
     For i As Integer = 1 To n
      Print Hex( Asc( Mid( s, i, 1 )), 2); " ";
     Next
     Print
     Print

   End Scope

   ''
   Scope
     Dim s As String
     
     '' open a file for input using utf-16 encoding
     '' and read back the message
     Open f For Input Encoding "utf-16" As #1

     '' The ascii string is converted from utf-16
     Line Input #1, s
     Close #1

     '' Display the text
     Print "Text read from " + f + ":"
     Print s
     Print
   End Scope

Output:

   Text To Write To sample.txt:
   FreeBASIC

   Binary contents of sample.txt:
   FF FE 46 00 72 00 65 00 65 00 42 00 41 00 53 00 49 00 43 00 0D 00 0A 00 

   Text Read from sample.txt:
   FreeBASIC

Platform Differences
   * Unicode (w)strings are not supported in the DOS port of FreeBASIC

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Encoding.

Differences from QB
   * QB had no support for Unicode

See also
   * Open



--------------------------------------------------------- KeyPgEndblock ----
End (Block)

Indicates the end of a compound statement block.

Syntax
   End { Sub | Function | If  | Select  | Type  | Enum  | Scope  | With  | 
   Namespace  | Extern  | Constructor  | Destructor  | Operator | Property 
   }

Description
   Used to indicate the end of the most recent code block.

   The type of the block must be included in the command: one of Sub, 
   Function, If, Select, Type, Enum, Scope, With, Namespace, Extern, 
   Constructor, Destructor, Operator, or Property.

   Ending a Sub, Function, If, Select, Scope, Constructor, Destructor, 
   Operator, or Property block also closes the scope for variables defined 
   inside that block.  When the scope is closed, variables defined inside 
   the scope are destroyed, calling their destructors as needed.

   To end a program, see End (Statement).

Example
   Declare Sub checkvalue( n As Integer )

   Dim variable As Integer

   Input "Give me a number: ", variable
   If variable = 1 Then
   Print "You gave me a 1"
   Else
   Print "You gave me a big number!"
   End If
   checkvalue(variable)

   Sub checkvalue( n As Integer )
   Print "Value is: " & n
   End Sub

Differences from QB
   * none

See also
   * Constructor
   * Destructor
   * End (Statement)
   * Enum
   * Extern
   * Function
   * If...Then
   * Namespace
   * Operator
   * Property
   * Scope
   * Select Case
   * Sub
   * Type
   * With



-------------------------------------------------------------- KeyPgEnd ----
End (Statement)

Control flow statement to end the program.

Syntax
   Declare Sub End ( ByVal retval As Long = 0 )

Usage
   End [ retval ]

Parameters
   retval
      Error code returned to system.

Description
   Used to exit the program, and return to the operating system. An 
   optional integer return value can be specified to indicate an error code 
   to the system. If no return value is given, a value of 0 is 
   automatically returned at the end of the program.

   Usage of this statement does not cleanly close scope. Local variables 
   will not have their destructors called automatically, because FreeBASIC 
   does not do stack unwinding. Only the destructors of global variables 
   will be called in this case.

   For this reason, it is discouraged to use End simply to mark the end of 
   a program; the program will come to an end automatically, and in a 
   cleaner fashion, when the last line of module-level code has executed.

Example
   '' This program requests a string from the user, and returns an error
   '' code to the OS if the string was empty

   Function main() As Integer

      '' assign input to text string
      Dim As String text
      Line Input "Enter some text ( try ""abc"" ): " , text

      '' If string is empty, print an error message and
      '' return error code 1 (failure)
      If( text = "" ) Then
         Print "ERROR: string was empty"
         Return 1
      End If

      '' string is not empty, so print the string and
      '' return error code 0 (success)
      Print "You entered: " & text
      Return 0

   End Function

   '' call main() and return the error code to the OS
   End main()

Platform Differences
   * In Linux, the retval parameter is a Byte.

Differences from QB
   * The END statement supports specifying a custom return value to be 
     returned to the operating system.

See also
   * End (Block)
   * Return (From Procedure)
   * Return (From Gosub)



------------------------------------------------------------ KeyPgEndif ----
End If

Control flow statement for conditional branching.

Syntax
   If expression Then [statement(s)] [Else [statement(s)]] [End If]
or
   If expression Then : [statement(s)] [Else [statement(s)]] : End If
or
   If expression Then
      [statement(s)]
   [ ElseIf expression Then ]
      [statement(s)]
   [ Else ]
      [statement(s)]
   End If

   Remark: EndIf (without blank) is also supported like in QB for backward 
   compatibility.

Example
   See example at If...Then.

Differences from QB
   * END IF was not supported in single-line IFs in QBASIC.

See also
   * If...Then

   


------------------------------------------------------------- KeyPgEnum ----
Enum

Declares an enumerated type.

Syntax
   Enum [typename [ Explicit ] ]
      symbolname [= expression] [, ...]
      ...
   End Enum

Parameters
   typename
      Name of the Enum
   symbolname
      Name of the constant
   expression
      A constant expression
   Explicit
      Requires that symbols must be explicitly referred to by typename.
      symbolname

Description
   Enum, short for enumeration, declares a list of symbol names that 
   correspond to discrete values. If no initial value is given, the first 
   item will be set to 0.  Each subsequent symbol has a value one more than 
   the previous unless expression is given.

   Symbols may be each on their own line, or separated on a single line by 
   commas.

   An Enum is a useful way of grouping together a set of related Constants. 
   A symbol can be accessed like a constant, e.g: a = symbolname.  But if 
   the name clashes with another symbol, it must be resolved using typename
   .symbolname.  This resolution method is always required if you make the 
   enum Explicit.

   A non-Explicit Enum declared inside an Extern ... End Extern block will 
   add its constants to the parent namespace directly, as in C, instead of 
   acting as a namespace on its own. It disallows the typename.symbolname 
   style of access, and the constants may conflict with other symbols from 
   the parent namespace.

   Enum can not contain any member procedure or member data (only symbols), 
   but it can be included (named or unnamed) in a Type by having.

   An Enum instance can be passed, as any user defined instance, to a 
   procedure (including for the definition of Overloaded operators).
   The size of an Enum instance will be always that of an Integer (no 
   matter how many defined symbols are just declarations for the compiler 
   assignment).

Example
   Enum MyEnum
      option1 = 1
      option2
      option3
   End Enum

   Dim MyVar As MyEnum

   MyVar = option1

   Select Case MyVar
      Case option1
         Print "Option 1"
      Case option2
         Print "Option 2"
      Case option3
         Print "Option 3"
   End Select

   You can reference formerly declared symbol names within the same enum:
   Enum MyEnum
      option1 = 1
      option2
      option3
      __
      MAX_VALUE = __ -1
   End Enum

   Print "Option #1:", MyEnum.option1
   Print "Option #2:", MyEnum.option2
   Print "Option #3:", MyEnum.option3
   Print "Max Value:", MyEnum.MAX_VALUE

	Output:

   Option #1:     1
   Option #2:     2
   Option #3:     3
   Max Value:     3

Dialect Differences
   * Explicit Enum not available in the -lang qb dialect unless referenced 
     with the alias __Explicit.

Differences from QB
   * New to FreeBASIC

See also
   * Const
   * Operator
   * Table with variable types overview, limits and suffixes



------------------------------------------------------- KeyPgSetenviron ----
SetEnviron

Sets a system environment variable

Syntax
   Declare Function SetEnviron ( ByRef varexpression As String ) As Long

Usage
   result = SetEnviron( varexpression )

Parameters
   varexpression
      Name and setting of an environment variable in the following (or 
      equivalent) form: varname=varstring.
      (varname being the name of the environment variable, and varstring 
      being its text value to set)

Return Value
   Return zero (0) if successful, non-zero otherwise.

Description
   Modifies system environment variables.  There are several variables 
   available for editing other than the default ones on your system.  An 
   example of this would be fbgfx, where you can choose the form of 
   graphics driver the FreeBASIC graphics library will use.

Example
   'e.g. to set the system variable "path" to "c:":

   Shell "set path" 'shows the value of path
   SetEnviron "path=c:"
   Shell "set path" 'shows the new value of path

     '' WINDOWS ONLY EXAMPLE! - We just set the graphics method to use
     '' GDI rather than DirectX (or Direct2D added on new systems).
     '' You may note a difference in FPS.
   SetEnviron("fbgfx=GDI")

     '' Desktop width/height
   Dim As Integer ScrW, ScrH, BPP
   ScreenInfo ScrW, ScrH, BPP

     '' Create a screen at the half width/height of your monitor.
     '' Normally this would be slow, but GDI is fairly fast for this kind
     '' of thing.
   ScreenRes ScrW/2, ScrH/2, BPP

     '' Start our timer/
   Dim As Double T = Timer

     '' Lock our page
   ScreenLock
   Do
     
      '' Print time since last frame
     Locate 1, 1
     Print "FPS: " & 1 / ( Timer - T )
     T = Timer
     
      '' Flip our screen
     ScreenUnlock
     ScreenLock
      '' Commit a graphical change to our screen.
     Cls
     
   Loop Until Len(Inkey)

     '' unlock our page.
   ScreenUnlock

Platform Differences
   * In Linux, varexpression  must be permanent (a literal, a variable 
     declared in the main code or a static variable declared in a 
     procedure), because Linux does not memorize the string but only a 
     pointer to its data characters.

Differences from QB
   * In QB, SetEnviron was called Environ.

See also
   * Environ
   * Shell



---------------------------------------------------------- KeyPgEnviron ----
Environ

Returns the value of a system environment variable

Syntax
   Declare Function Environ ( ByRef varname As Const String ) As String

Usage
   result = Environ[$]( varname )

Parameters
   varname
      The name of an environment variable.

Return Value
   Returns the text value of the environmental variable, or the empty 
   string ("") if the variable does not exist.

Description
   Environ returns the text value of a system environment variable.

Example
   'e.g. to show the system variable "path":

   Print Environ("path")

Differences from QB
   * The QB ENVIRON statement is now called SetEnviron.
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

See also
   * SetEnviron
   * Shell



-------------------------------------------------------------- KeyPgEof ----
EOF

Checks to see if the end of an open file has been reached

Syntax
   Declare Function EOF ( ByVal filenum As Long ) As Long

Usage
   result = EOF( filenum )

Parameters
   filenum
      File number of an open file.

Return Value
   Returns true (-1) if end-of-file has been reached, zero (0) otherwise.

Description
   When reading from files opened for Input (File Mode), it is useful to 
   know when the end of the file has been reached, thus avoiding errors 
   caused by reading past the ends of files. Use EOF to determine this. EOF 
   expects a valid file number from an already opened file. Use FreeFile to 
   retrieve an available file file number.

   For file numbers bound to files opened for Output, EOF always returns 0.

Example
   '' This code finds a free file number to use and attempts to open the file
   '' "file.ext" and if successful, binds our file number to the opened file. It
   '' reads the file line by line, outputting it to the screen. We loop until eof()
   '' returns true, in this case we ignore the loop if file is empty.

   Dim As String file_name
   Dim As Integer file_num

   file_name = "file.ext"
   file_num = FreeFile( )                 '' retrieve an available file number

   '' open our file and bind our file number to it, exit on error
   If( Open( file_name For Input As #file_num ) ) Then
      Print "ERROR: opening file " ; file_name
      End -1
   End If

   Do Until EOF( file_num )               '' loop until we have reached the end of the file
      Dim As String text
      Line Input #file_num, text               '' read a line of text ...
      Print text                             '' ... and output it to the screen
   Loop

   Close #file_num                        '' close file via our file number

   End 0

Differences from QB
   * In QB the comm port signaled an EOF when there were no chars waiting 
     to be read.
   * In QB, for files opened in RANDOM or BINARY mode, EOF returned 
     non-zero only after a read past the end of file has been attempted.  
     In FreeBASIC, EOF returns true after the last item is read.

See also
   * LOF
   * LOC
   * FreeFile



------------------------------------------------------------ KeyPgOpEqv ----
Operator Eqv (Equivalence)

Returns the bitwise-and (equivalence) of two numeric values

Syntax
   Declare Operator Eqv ( ByRef lhs As T1, ByRef rhs As T2 ) As Ret

Usage
   result = lhs Eqv rhs

Parameters
   lhs
      The left-hand side expression.
   T1
      Any numeric or boolean type.
   rhs
      The right-hand side expression.
   T2
      Any numeric or boolean type.
   Ret
      A numeric or boolean type (varies with T1 and T2).

Return Value
   Returns the bitwise-equivalence of the two operands.

Description
   This operator returns the bitwise-equivalence of its operands, a logical 
   operation that results in a value with bits set depending on the bits of 
   the operands (for conversion of a boolean to an integer, false or true 
   boolean value becomes 0 or -1 integer value).

   The truth table below demonstrates all combinations of a 
   boolean-equivalence operation:

      +-------+-------+------+
      |Lhs Bit|Rhs Bit|Result|
      |0      |0      |1     |
      |1      |0      |0     |
      |0      |1      |0     |
      |1      |1      |1     |
      +-------+-------+------+

   No short-circuiting is performed - both expressions are always 
   evaluated.

   The return type depends on the types of values passed. Byte, UByte and 
   floating-point type values are first converted to Integer. If the left 
   and right-hand side types differ only in signedness, then the return 
   type is the same as the left-hand side type (T1), otherwise, the larger 
   of the two types is returned. Only if the left and right-hand side types 
   are both Boolean, the return type is also Boolean.

   This operator can be overloaded for user-defined types.

Example
   Dim As UByte a = &b00110011
   Dim As UByte b = &b01010101, c
   c = a Eqv b '' c = &b10011001

Dialect Differences
   * In the -lang qb dialect, this operator cannot be overloaded.

Differences from QB
   * None

See also
   * Operator Truth Tables



------------------------------------------------------------ KeyPgErase ----
Erase

Statement to erase arrays

Syntax
   Declare Sub Erase ( array As Any [, ... ] )

Usage
   Erase( array0 [, array1 ... arrayN ] )

Parameters
   array
      An array to be erased.

Description
   Using Erase on a fixed-length array resets all elements without freeing 
   the allocated memory.
   In case of objects, there is destruction then re-construction.

   Using Erase on a variable-length array (array already sized) frees the 
   memory allocated for the array elements, but the array remains declared 
   at its same scope level (with the same datatype and number of 
   dimensions), only the high/low bounds values of each dimension are reset 
   (-1/0).
   In case of objects, there is destruction before freeing memory.

Example
   Dim MyArray1(1 To 10) As Integer
   ReDim MyArray2(1 To 10) As Integer 

   Erase MyArray1, MyArray2
      

   Example showing the before and after results of single-dimension arrays:
   Dim MyArray1(1 To 10) As Integer
   ReDim MyArray2(1 To 10) As Integer

   Print "MyArray1", LBound( MyArray1 ), UBound( MyArray1 ) ' prints: MyArray1       1             10
   Print "MyArray2", LBound( MyArray2 ), UBound( MyArray2 ) ' prints: MyArray2       1             10

   Erase MyArray1, MyArray2

   Print "MyArray1", LBound( MyArray1 ), UBound( MyArray1 ) ' prints: MyArray1       1             10
   Print "MyArray2", LBound( MyArray2 ), UBound( MyArray2 ) ' prints: MyArray2       0            -1
         

   Example showing the before and after results of multi-dimension arrays:
   Dim MyArray1(1 To 3, 4 To 9) As Integer
   ReDim MyArray2(1 To 3, 4 To 9) As Integer

   Print , "LOWER", "UPPER"
   Print "MyArray1", _
        LBound( MyArray1, 1 ); ", "; LBound( MyArray1, 2 ), _
        UBound( MyArray1, 1 ); ", "; UBound( MyArray1, 2 )
   Print "MyArray2", _
        LBound( MyArray2, 1 ); ", "; LBound( MyArray2, 2 ), _
        UBound( MyArray2, 1 ); ", "; UBound( MyArray2, 2 )

   Erase MyArray1, MyArray2

   Print
   Print "MyArray1", _
        LBound( MyArray1, 1 ); ", "; LBound( MyArray1, 2 ), _
        UBound( MyArray1, 1 ); ", "; UBound( MyArray1, 2 )
   Print "MyArray2", _
        LBound( MyArray2, 1 ); ", "; LBound( MyArray2, 2 ), _
        UBound( MyArray2, 1 ); ", "; UBound( MyArray2, 2 )
         
The above example will output:
                 LOWER         UPPER
   MyArray1       1,  4         3,  9
   MyArray2       1,  4         3,  9

   MyArray1       1,  4         3,  9
   MyArray2       0,  0        -1, -1
   			

Differences from QB
   * None

See also
   * Common
   * Dim
   * Extern
   * LBound
   * ReDim
   * Static
   * UBound
   * Var



------------------------------------------------------------- KeyPgErfn ----
Erfn

Error reporting function

Syntax
   Declare Function Erfn ( ) As ZString Ptr

Usage
   result = Erfn ( ) 

Return Value
   Returns a pointer to the string identifying the function where the error 
   occurred.

   Returns NULL if the source is not compiled with the -exx compiler 
   option.

Description
   An error reporting function returning a pointer to the name of the 
   function.

Example
   '' test.bas
   '' compile with fbc -exx -lang fblite test.bas

   #lang "fblite"

   Sub Generate_Error
     On Error Goto Handler
     Error 1000
     Exit Sub
   Handler:
     Print "Error Function: "; *Erfn()
     Print "Error Module  : "; *Ermn()
     Resume Next
   End Sub

   Generate_Error

Output:
   Error Function: GENERATE_ERROR
   Error Module  : test.bas

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Erfn.

Differences from QB
   * New to FreeBASIC

See also 
   * Erl
   * Ermn
   * On...Error



-------------------------------------------------------------- KeyPgErl ----
Erl

Error handling function to return the line where the error occurred

Syntax
   Declare Function Erl ( ) As Integer

Usage
   result = Erl

Return Value
   An Integer return value containing the line number where the last error 
   occurred.

Description
   Erl will return the line number where the last error occurred. If no 
   error has occurred, Erl will return 0.

   Erl cannot always be used effectively -- QB-like error handling must be 
   enabled.

   Erl is reset by RESUME and RESUME NEXT

Example

   ' compile with -lang fblite or qb

   #lang "fblite"

   ' note: compilation with '-ex' option is required

   On Error Goto ErrorHandler

   ' Generate an explicit error
   Error 100

   End

   ErrorHandler:
     Dim num As Integer = Err
     Print "Error "; num; " on line "; Erl
     Resume Next

   ' Expected output is
   ' Error  100 on line  6

Differences from QB
   * FreeBASIC returns the source code line number and ignores the values 
     of all explicit line numbers, where as QB returns the last encountered 
     explicit line number, and will return zero (0) when explicit line 
     numbers are not used.

See also
   * Error Handling
   * Err



------------------------------------------------------------- KeyPgErmn ----
Ermn

Error reporting function

Syntax
   Declare Function Ermn ( ) As ZString Ptr

Usage
   result = Ermn ( ) 

Return Value
   Returns a pointer to the string identifying the module where the error 
   occurred.

   Returns NULL if the source is not compiled with the -exx compiler 
   option.

Description
   An error reporting function returning a pointer to the name of the 
   module.

Example
   '' test.bas
   '' compile with fbc -exx -lang fblite test.bas

   #lang "fblite"

   Sub Generate_Error
     On Error Goto Handler
     Error 1000
     Exit Sub
   Handler:
     Print "Error Function: "; *Erfn()
     Print "Error Module  : "; *Ermn()
     Resume Next
   End Sub

   Generate_Error

Output:
   Error Function: GENERATE_ERROR
   Error Module  : test.bas

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Ermn.

Differences from QB
   * New to FreeBASIC

See also 
   * Erfn
   * Erl
   * On...Error



-------------------------------------------------------------- KeyPgErr ----
Err

Get or set the run-time error number

Usage
   result = Err( )
      or
   Err = number

Description
   The Err() function returns the FreeBASIC run-time error number (a 32 bit 
   Long) which can be set by the built-in statements and functions, or by 
   the program through Err = number or Error. Unlike Error, Err = number 
   sets the error number without invoking an error handler.

   See Runtime Error Codes for a listing of the predefined runtime error 
   numbers and their associated meaning. The program may use additional 
   custom error numbers.

   Err can always be used, even if QB-like error handling is not enabled. 
   Err is reset by Resume and Resume Next.

   Note: Care should be taken when calling an internal function (such as 
   Print) after an error occurred, because it will reset the error value 
   with its own error status. To preserve the Err value, it is a good idea 
   to store it in a variable as soon as the error handler is entered.

   Remark: Some procedures used in their function version return directly 
   the error code (a 32 bit Long).
   That is the case for: BLoad, BSave, Close, FileCopy, GetJoystick, 
   GetMouse, ImageInfo, Kill, Open, Open Com, Open Cons, Open Err, Open Lpt
   , Open Pipe, Open Scrn, ScreenRes, ScreenSync, SetDate, SetMouse, SetTime
   .

Example
An example using QBasic style error handling (compile with -ex option)
   '' Compile with -lang fblite or qb

   #lang "fblite"

   On Error Goto Error_Handler
   Error 150
   End

   Error_Handler:
     n = Err()
     Print "Error #"; n
     Resume Next

An example using inline error handling (note: Open can also return its own 
error status when called as a function)
   '' compile without -e switch

   Dim filename As String

   Do
      Line Input "Input filename: ", filename
      If filename = "" Then End
      Open filename For Input As #1
   Loop Until Err() = 0

   Print Using "File '&' opened successfully"; filename
   Close #1

Differences from QB
   * Error numbers are not the same as in QB.

See also
   * On Error
   * Error
   * Error Handling
   * Runtime Error Codes



------------------------------------------------------------ KeyPgError ----
Error

Error handling statement to force an error to be generated

Syntax
   Declare Sub Error ( errno As Integer )

Usage
   Error number

Parameters
   number
      The error number to generate

Description
   Error invokes the error handler specified with On Error or, in case 
   there was none set, aborts the program, printing an error message 
   similar to those generated by the compiler's -exx run-time error 
   checking. It's possible to use the built-in run-time error numbers 
   and/or other custom error numbers for number. This can be used to 
   simulate custom error numbers.

Example
   To send an error alert of error 150 (just some arbitrary error code) one 
   would do the following:
   Error 150

Differences from QB
   * Error numbers are not the same as in QB.

See also
   * Err
   * Error Handling
   * Runtime Error Codes



------------------------------------------------------------ KeyPgEvent ----
Event (Message Data From Screenevent)

Pre-defined structure (UDT) from fbgfx.bi used by ScreenEvent to return 
event data 

Syntax
   #include once "fbgfx.bi"
   using fb
   Dim variable As Event

Description
   Here we report the EVENT structure for clarity:

   Type Event Field = 1
      Type As Long
      Union
         Type
            scancode As Long
            ascii As Long
         End Type
         Type
            x As Long
            y As Long
            dx As Long
            dy As Long
         End Type
         button As Long
         z As Long
         w As Long
      End Union
   End Type

   The Type field will contain the event type ID, while the remaining 4 
   integers will hold sensitive data to the event type. 

   Event types
      The event type is identified by an ID number returned into the first 
      integer of the event buffer (the .type field in the EVENT structure). 
      Known event type IDs - and their values at time of writing - are:

      * EVENT_KEY_PRESS (1) A key was pressed on the keyboard. The 
        .scancode field contains the platform independent scancode value 
        for the key; if the key has an ascii representation, it is held 
        into the .ascii field, which otherwise has a value of 0.
      * EVENT_KEY_RELEASE (2) A key was released on the keyboard. The 
        .scancode and .ascii fields have the same meaning as with the 
        EVENT_KEY_PRESS event.
      * EVENT_KEY_REPEAT (3) A key is being held down repeatedly. The 
        .scancode and .ascii fields have the same meaning as with the 
        EVENT_KEY_PRESS event.
      * EVENT_MOUSE_MOVE (4) The mouse was moved while it was on the 
        program window. The .x and .y fields contain the new mouse position 
        relative to the upper-left corner of the screen, while the .dx and 
        .dy fields contain the motion deltas.
      * EVENT_MOUSE_BUTTON_PRESS (5) One of the mouse buttons was pressed. 
        The .button field has one bit set identifying the button that was 
        pressed; bit 0 identifies the left mouse button, bit 1 the right 
        mouse button and bit 2 the middle mouse button.
      * EVENT_MOUSE_BUTTON_RELEASE (6) One of the mouse buttons was 
        released. The .button field has the same meaning as with the 
        EVENT_MOUSE_BUTTON_PRESS event.
      * EVENT_MOUSE_DOUBLE_CLICK (7)  One of the mouse buttons was double 
        clicked. The .button field has the same meaning as with the 
        EVENT_MOUSE_BUTTON_PRESS event.
      * EVENT_MOUSE_WHEEL (8) The mouse wheel was used; the new wheel 
        position is returned into the .z field.
      * EVENT_MOUSE_ENTER (9) The mouse was moved into the program window.
      * EVENT_MOUSE_EXIT (10) The mouse was moved out of the program 
        window.
      * EVENT_WINDOW_GOT_FOCUS (11) The program window has got focus.
      * EVENT_WINDOW_LOST_FOCUS (12) The program window has lost focus.
      * EVENT_WINDOW_CLOSE (13) The user attempted to close the program 
        window.
      * EVENT_MOUSE_HWHEEL (14) The horizontal mouse wheel was used; the 
        new horizontal wheel position is returned into the .w field.

   The fbgfx.bi header file contains a definition of the EVENT user data 
   type, so it is not necessary to declare it manually.

Example
   See example at ScreenEvent.

Dialect Differences
   * In lang fb, the structure and constants are stored in the FB Namespace
     . This is not the case in other dialects.

Differences from QB
   * New to FreeBASIC

See also
   * ScreenEvent
   * Event Handling



------------------------------------------------------------- KeyPgExec ----
Exec

Temporarily transfers execution to an external program

Syntax
   Declare Function Exec ( ByRef program As Const String, ByRef arguments As
   Const String ) As Long

Usage
   result = Exec( program, arguments )

Parameters
   program
      The file name (including file path) of the program (executable) to 
      transfer control to.
   arguments
      The command-line arguments to be passed to the program.

Return Value
   The exit status of the program, or negative one (-1) if the program 
   could not be executed.

Description
   Transfers control over to an external program. When the program exits, 
   execution resumes immediately after the call to Exec.

Example
   'A Windows based example but the same idea applies to Linux
   Const exename = "NoSuchProgram.exe"
   Const cmdline = "arg1 arg2 arg3"
   Dim result As Integer
   result = Exec( exename, cmdline )
   If result = -1 Then
      Print "Error running "; exename
   Else
      Print "Exit code:"; result
   End If

Platform Differences
   * Linux requires the program case matches the real name of the file. 
     Windows and DOS  are case insensitive. The program being executed may 
     be case sensitive for its command line parameters.
   * Path separators in Linux are forward slashes / . Windows uses 
     backward slashes \ but it allows for forward slashes .  DOS uses 
     backward  \ slashes. 
   * Exit code is limited to 8 bits in DOS.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Exec.

Differences from QB
   * New to FreeBASIC

See also
   * Chain transfer temporarily, without arguments
   * Run one-way transfer
   * Command pick arguments



---------------------------------------------------------- KeyPgExepath ----
ExePath

Returns the path of the running program

Syntax
   Declare Function ExePath ( ) As String

Usage
   result = ExePath

Return Value
   A String variable set to the path of the running program.

Description
   Returns the path (the location) of the calling program. This is not 
   necessarily the same as CurDir.

Example
   Dim pathname As String = ExePath
   Print "This program's initial directory is: " & pathname

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Exepath.

Differences from QB
   * New to FreeBASIC

See also
   * CurDir



------------------------------------------------------------- KeyPgExit ----
Exit

Control flow statement to exit a compound statement block

Syntax
   Exit {Do | For | While | Select }
   Exit {Sub | Function | Operator | Constructor | Destructor | Property }

   Exit {Do [, Do [ , ...] ] |
         For [, For [ , ...] ] | 
         While [, While, [...] ] | 
         Select [, Select [ , ...] ] }

Description
   Leaves a code block such as a Sub, Function, Operator, Constructor, 
   Destructor, Property, Do...Loop, For...Next, While...Wend, or a  
   Select Case block. The execution skips the rest of the block and goes to 
   the line after its end.

   Where there are multiple Do / For / While / Select blocks nested, it 
   will skip to the end of the innermost block of that type.  You can skip 
   to the end of multiple blocks of that type by giving the word multiple 
   times, separated by commas.
   For example: Exit While, While

Example
   'e.g. the print command will not be seen

   Do
      Exit Do ' Exit the Do...Loop and continues to run the code after Loop
      Print "I will never be shown"
   Loop

   Dim As Integer i, j
   For i = 1 To 10
      
      For j = 1 To 10
         
         Exit For, For
         
      Next j
      
      Print "I will never be shown"
      
   Next i

Differences from QB
   * EXIT OPERATOR, EXIT CONSTRUCTOR, EXIT DESTRUCTOR, EXIT PROPERTY, EXIT 
     WHILE and EXIT SELECT are new to FreeBASIC.

See also
   * Sub
   * Function
   * Do...Loop
   * For...Next
   * While...Wend
   * Continue



-------------------------------------------------------------- KeyPgExp ----
Exp

Returns e raised to the power of a given number

Syntax
   Declare Function Exp cdecl ( ByVal number As Double ) As Double

Usage
   result = Exp( number )

Parameters
   number
      The Double number that e is raised to the power of.

Return Value
   Returns the Double value of e raised to power of number.

Description
   The mathematical constant e, also called Euler's constant, is the base 
   of the Exp and Log and is an irrational and transcendental number. The 
   value of e to twenty significant figures is: 2.7182818284590452354. The 
   required number argument can be any valid numeric expression within 
   range of the function. If number is too large, Exp returns infinity.  If 
   number is too small, Exp returns zero (0.0).  If number is zero, 1.0 is 
   returned. The exact limit on number is based on the math processor.

   Exp can be overloaded as operator to accept user-defined types.

Example
   'Compute Continuous Compound Interest
   Dim r As Double
   Dim p As Double
   Dim t As Double
   Dim a As Double

   Input "Please enter the initial investment (principal amount): "; p
   Input "Please enter the annual interest rate (as a decimal): "; r
   Input "Please enter the number of years to invest: "; t

   a = p * Exp ( r * t )
   Print ""
   Print "After";t;" years, at an interest rate of"; r * 100; "%, your initial investment of"; p; " would be worth";a

The output would look like:

   Please enter the initial investment (principal amount): 100
   Please enter the annual interest rate (As a decimal): .08
   Please enter the number of years To invest: 20
   After 20 years, at an interest rate of 8%, your initial investment of 100 would be worth 495.3032424395115

Differences from QB
   * None

See also
   * Log
   * Operator ^ (Exponentiate)



----------------------------------------------------------- KeyPgExport ----
Export

Definition specifier to indicate that a procedure in a DLL should be 
visible from other programs

Syntax
   { Sub | Function } proc_name ( argumentlist ) [ [ ByRef ] As datatype ] 
   Export

Description
   If a function is defined with this clause in a DLL, it is added to the 
   public export table, so external programs can dynamically link to it 
   using DyLibSymbol.
   (specifier to be put at the level of the first line of procedure 
   definition, forbidden at procedure declaration line level)

Example
   See the examples on the Shared Libraries page.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Export.

Platform Differences
   * Dynamic link libraries are not available in DOS, as the OS doesn't 
     support them.

Differences from QB
   * New to Freebasic

See also
   * DyLibLoad
   * DyLibSymbol
   * Alias



---------------------------------------------------------- KeyPgExtends ----
Extends

Specifies a base type from which to derive a new type

Syntax
   Type|Union typename Extends base_typename
      ...
   End Type|Union

Description
   Extends declares typename to be derived from base_typename. The derived 
   user-defined type, typename, inherits fields and methods of the 
   base_typename base type. typename objects may be used in place of 
   base_typename objects. Fields and methods inherited from base_typename 
   will be implicitly accessible like members of typename.
   However, a member will shadow an inherited member if they have the same 
   identifier. The Base (Member Access) keyword can be used to explicitly 
   access members of the base type shadowed by local members.

   User-defined types that extend another type will include the base type 
   structure at their beginning, and their size as reported by Sizeof() is 
   the sum of their base type's size plus the size needed for any regular 
   data fields (non-static data fields). Since the inherited members make 
   sure that the structure is not empty, a derived type is not required to 
   have regular data fields of its own.

   In typename (the derived user-defined type), the fields can share the 
   same memory space than the base_typename only if typename is a Union. 
   Here it does not matter whether base_typename is a Union or not.
   If only base_typename is a Union, then it will not be affected by fields 
   from typename (the derived user-defined type).
   As a Union is not allowed to have complex fields (i.e. user-defined 
   types with constructor/destructor, or dynamic strings), a derived Union 
   cannot be allowed to have (contain) a complex base_typename.

   The Base (Initializer) keyword can be used at the top of constructor of 
   derived user-defined type. It allows to specify an initializer or 
   constructor call for the base type.

   Extending the built-in Object type allows a user-defined type to be used 
   with Operator Is to perform run-time type checks, to support Virtual and 
   Abstract methods, and to use the Override method attribute.

    Note: UDT pointer can only be cast to pointer types of "widened 
   compatibility" (up or even down in the inheritance hierarchy), or to Any 
   Ptr. Otherwise, cast to Any Ptr first (or to Object Ptr first if both 
   types are directly or indirectly derived from Object).

Example
   Type SchoolMember 'Represents any school member'
      Declare Constructor ()
      Declare Sub Init (ByRef _name As String, ByVal _age As Integer)
      As String Name
      As Integer age
   End Type

   Constructor SchoolMember ()
      Print "Initialized SchoolMember"
   End Constructor

   Sub SchoolMember.Init (ByRef _name As String, ByVal _age As Integer)
      This.name = _name
      This.age = _age
      Print "Name: "; This.name; "   Age:"; This.age
   End Sub

   Type Teacher Extends SchoolMember 'Represents a teacher derived from SchoolMember'
      Declare Constructor (ByRef _name As String, ByVal _age As Integer, ByVal _salary As Integer)
      As Integer salary
      Declare Sub Tell ()
   End Type

   Constructor Teacher (ByRef _name As String, ByVal _age As Integer, ByVal _salary As Integer)
      Print "Initialized Teacher"
      This.Init(_name, _age) 'implicit access to base member procedure'
      This.salary = _salary
   End Constructor

   Sub Teacher.Tell ()
      Print "Salary:"; This.salary
   End Sub

   Type Student Extends SchoolMember 'Represents a student derived from SchoolMember'
      Declare Constructor (ByRef _name As String, ByVal _age As Integer, ByVal _marks As Integer)
      As Integer marks
      Declare Sub Tell ()
   End Type

   Constructor Student (ByRef _name As String, ByVal _age As Integer, ByVal _marks As Integer)
      Print "Initialized Student"
      This.Init(_name, _age) 'implicit access to base member procedure'
      This.marks = _marks
   End Constructor
      
   Sub Student.Tell ()
      Print "Marks:"; This.marks
   End Sub

   Dim As Teacher t = Teacher("Mrs. Shrividya", 40, 30000)
   t.Tell()
   Print
   Dim As Student s = Student("Swaroop", 22, 75)
   s.Tell()

   ' Example using all eight keywords of inheritance:
   '   'Extends', 'Base.', 'Base()', 'Object', 'Is' operator, 'Virtual', 'Abstract', 'Override'

   Type root Extends Object ' 'Extends' to activate RTTI by inheritance of predefined Object type
     Declare Function ObjectHierarchy () As String
     Declare Abstract Function ObjectRealType () As String ' 'Abstract' declares function without local body
                                             '    which must be overriden
     Dim Name As String
     Declare Virtual Destructor () ' 'Virtual' declares destructor with body ('Abstract' forbidden)
   Protected:
     Declare Constructor () ' to avoid user construction from root
     Declare Constructor (ByRef rhs As root) '' to avoid user copy-construction from root
   End Type ' derived type may be member data empty

   Constructor root ()
   End Constructor

   Function root.ObjectHierarchy () As String
     Return "Object(forRTTI) <- root"
   End Function

   Virtual Destructor root ()
     Print "root destructor"
   End Destructor

   Type animal Extends root ' 'Extends' to inherit of root
     Declare Constructor (ByRef _name As String = "")
     Declare Function ObjectHierarchy () As String
     Declare Virtual Function ObjectRealType () As String Override ' 'Virtual' declares function with local
                                                   '    body which can be overriden
                                                   ' 'Override' to check if the function is
                                                   '    well an override
     Declare Virtual Destructor () Override ' 'Virtual' declares destructor with local body
                                  ' 'Override' to check if the destructor is well an override
   End Type

   Constructor animal (ByRef _name As String = "")
     This.name = _name
   End Constructor

   Function animal.ObjectHierarchy () As String
     Return Base.ObjectHierarchy & " <- animal" ' 'Base.' allows to access to parent member function
   End Function

   Virtual Function animal.ObjectRealType () As String
     Return "animal"
   End Function

   Virtual Destructor animal ()
     Print "  animal destructor: " & This.name
   End Destructor

   Type dog Extends animal ' 'Extends' to inherit of animal
     Declare Constructor (ByRef _name As String = "")
     Declare Function ObjectHierarchy () As String
     Declare Function ObjectRealType () As String Override ' 'Override' to check if the function is well an
                                             '    override
     Declare Destructor () Override ' 'Override' to check if the destructor is well an override
   End Type ' derived type may be member data empty

   Constructor dog (ByRef _name As String = "")
     Base(_name) ' 'Base()' allows to call parent constructor
   End Constructor

   Function dog.ObjectHierarchy () As String
     Return Base.ObjectHierarchy & " <- dog" ' 'Base.' allows to access to parent member function
   End Function

   Function dog.ObjectRealType () As String
     Return "dog"
   End Function

   Destructor dog ()
     Print "    dog destructor: " & This.name
   End Destructor

   Type cat Extends animal ' 'Extends' to inherit of animal
     Declare Constructor (ByRef _name As String = "")
     Declare Function ObjectHierarchy () As String
     Declare Function ObjectRealType () As String Override ' 'Override' to check if the function is well an
                                             '    override
     Declare Destructor () Override ' 'Override' to check if the destructor is well an override
   End Type ' derived type may be member data empty

   Constructor cat (ByRef _name As String = "")
     Base(_name) ' 'Base()' allows to call parent constructor
   End Constructor

   Function cat.ObjectHierarchy () As String
     Return Base.ObjectHierarchy & " <- cat" ' 'Base.' allows to access to parent member function
   End Function

   Function cat.ObjectRealType () As String
     Return "cat"
   End Function

   Destructor cat ()
     Print "    cat destructor: " & This.name
   End Destructor

   Sub PrintInfo (ByVal p As root Ptr) ' must be put after definition of animal type, dog type and cat type
     Print "  " & p->Name, "  " & p->ObjectRealType, "           ";
     If *p Is dog Then ' 'Is' allows to check compatibility with type symbol
      Print  Cast(dog Ptr, p)->ObjectHierarchy
     ElseIf *p Is cat Then ' 'Is' allows to check compatibility with type symbol
      Print Cast(cat Ptr, p)->ObjectHierarchy
     ElseIf *p Is animal Then ' 'Is' allows to check compatibility with type symbol
      Print Cast(animal Ptr, p)->ObjectHierarchy
     End If
   End Sub

   Print "Name:", "Object (real):         Hierarchy:"
   Dim a As root Ptr = New animal("Mouse")
   PrintInfo(a)
   Dim d As root Ptr = New dog("Buddy")
   PrintInfo(d)
   Dim c As root Ptr = New cat("Tiger")
   Printinfo(c)
   Print
   Delete a
   Delete d
   Delete c

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Extends.

Differences from QB
   * New to FreeBASIC

See also
   * Type
   * Union
   * Base (Initializer)
   * Base (Member Access)
   * Object
   * Operator Is
   * Virtual
   * Abstract
   * Override
   * Extends Zstring
   * Extends Wstring



--------------------------------------------------- KeyPgExtendsWstring ----
Extends Wstring

Specifies a type which inherits a Wstring behavior

Syntax
   Type|Union typename Extends Wstring [, base_typename]
      ...
   End Type|Union

Description
   Extends Wstring declares typename to inherit properties and behaviors of 
   a WString. Purpose is to allow users to create custom string types (with 
   i.e. dynamic memory management) that can integrate well in to existing 
   fbc compiler built ins (good interoperability with fbc's WString type).

   This declaration of such a UDT with a suitable Cast operator will 
   instruct compiler to convert the UDT to a WString (in addition, other 
   suitable operators as Let, [] (Pointer Index), Len, ..., can be also 
   declared).

   WString behaviour can be inherited directly, or indirectly and singly 
   from a base-type.
   WString behaviour can be inherited by a UDT also extending base_typename 
   (a kind of pseudo multiple-inheritance).

   By declaring a type (directly or indirectly) as Extends Wstring (in 
   addition to defining a suitable Cast operator only), this promotes it 
   fully WString type compatible, even with StrPtr/SAdd, LSet/RSet, and 
   Select Case.

Example
   See Extends Zstring for similar examples.

Version
   * Before fbc 1.09.0, this promotion was not yet fully WString type 
     compatible with the built in functions Val/ValInt/ValLng/ValUInt/
     Valunlg and Left/Right.
   * Since fbc 1.07.0

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Extends __Wstring, but unusable because no member procedure is 
     allowed in this dialect.

Differences from QB
   * New to FreeBASIC

See also
   * Type
   * Union
   * Extends
   * WString
   * Extends Zstring



--------------------------------------------------- KeyPgExtendsZstring ----
Extends Zstring

Specifies a type which inherits a Zstring behavior

Syntax
   Type|Union typename Extends Zstring [, base_typename]
      ...
   End Type|Union

Description
   Extends Zstring declares typename to inherit properties and behaviors of 
   a ZString. Purpose is to allow users to create custom string types (with 
   i.e. dynamic memory management) that can integrate well in to existing 
   fbc compiler built ins (good interoperability with fbc's ZString type).

   This declaration of such a UDT with a suitable Cast operator will 
   instruct compiler to convert the UDT to a ZString (in addition, other 
   suitable operators as Let, [] (Pointer Index), Len, ..., can be also 
   declared).

   ZString behaviour can be inherited directly, or indirectly and singly 
   from a base-type.
   ZString behaviour can be inherited by a UDT also extending base_typename 
   (a kind of pseudo multiple-inheritance).

   By declaring a type (directly or indirectly) as Extends Zstring (in 
   addition to defining a suitable Cast operator only), this promotes it 
   fully ZString type compatible, even with StrPtr/SAdd, LSet/RSet, and 
   Select Case.

Example
   Type myZstring Extends ZString
     Public:
      Declare Constructor (ByRef z As Const ZString = "")
      Declare Operator Cast () ByRef As Const ZString
      Declare Operator Let (ByRef z As Const ZString)
     Private:
      Dim As String s
   End Type

   Constructor myZstring (ByRef z As Const ZString = "")
     This.s = z
   End Constructor

   Operator myZstring.Cast () ByRef As Const ZString
     Return *StrPtr(This.s)
   End Operator

   Operator myZstring.Let (ByRef z As Const ZString)
     This.s = z
   End Operator

   Dim As myZstring z = "FreeBASIC"
   Print "'" & z & "'"

   z &= " compiler"
   Print "'" & z & "'"

   Sleep

   Type vZstring Extends ZString
     Public:
      Declare Constructor (ByVal pz As Const ZString Ptr = 0)
      Declare Operator Cast () ByRef As ZString
      Declare Operator Let (ByVal pz As Const ZString Ptr)
      Declare Operator [] (ByVal index As Integer) ByRef As UByte
      Declare Destructor ()
     Private:
      Dim As ZString Ptr p
      Dim As UInteger l
   End Type

   Constructor vZstring (ByVal pz As Const ZString Ptr = 0)
     This.l = Len(*pz)
     This.p = CAllocate(This.l + 1, SizeOf(ZString))
     *This.p = *pz
   End Constructor

   Operator vZstring.Cast () ByRef As ZString
     Return *This.p
   End Operator

   Operator vZstring.Let (ByVal pz As Const ZString Ptr)
     If This.l < Len(*pz) Then
      Deallocate(This.p)
      This.l = Len(*pz)
      This.p = CAllocate(This.l + 1, SizeOf(ZString))
     End If
     *This.p = *pz
   End Operator

   Operator vZstring.[] (ByVal index As Integer) ByRef As UByte
     Return This.p[index]
   End Operator

   Destructor vZstring ()
     Deallocate(This.p)
   End Destructor

   Operator Len (ByRef v As vZstring) As Integer
     Return Len(Type<String>(v))        '' found nothing better than this
   End Operator                         ''     (or: 'Return Len(Str(v))')

   Dim As vZstring v = "FreeBASIC"
   Print "'" & v & "'", Len(v)

   Dim As ZString * 256 z
   z = *StrPtr(v)                       '' 'error 24: Invalid data types' without 'Extends Zstring'
   Print "'" & z & "'", Len(z)

   v &= Space(2)
   Print "'" & v & "'", Len(v)
   RSet v, "FreeBASIC"                  '' 'error 24: Invalid data types' without 'Extends Zstring'
   Print "'" & v & "'", Len(v)          ''     ('Cast' must return a modifiable reference)

   Select Case v                        '' 'error 24: Invalid data types' without 'Extends Zstring'
   Case Type<vZstring>(Trim(v) & "  ")
     Print "Left justified"
   Case Type<vZstring>("  " & Trim(v))
     Print "Right justified"
   End Select

   v[0] = Asc("-")
   Print "'" & v & "'", Len(v)

   Print "'" & Right(v, 5) & "'"        '' since fbc 1.09.0, 'Right' supports types with 'Extends Zstring'
   'Print "'" & Right(Str(v), 5) & "'"  '' before fbc 1.09.0, use this workaround (or: 'Right(Type<String>(v), 5)')

   Sleep

Version
   * Before fbc 1.09.0, this promotion was not yet fully ZString type 
     compatible with the built in functions Val/ValInt/ValLng/ValUInt/
     Valunlg and Left/Right.
   * Since fbc 1.07.0

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Extends __Zstring, but unusable because no member procedure is 
     allowed in this dialect.

Differences from QB
   * New to FreeBASIC

See also
   * Type
   * Union
   * Extends
   * ZString
   * Extends Wstring



----------------------------------------------------------- KeyPgExtern ----
Extern

Declares a variable, array or object having external linkage

Syntax
   Extern [ Import ] symbolname[ (subscripts) ] [ Alias "aliasname" ] As 
   DataType [, ...]

Parameters
   symbolname
      The name of the variable, array or object.
   aliasname
      An alternate external name for the variable, array or object.

Description
   Declares symbolname as an external name, meaning it is global to 
   external modules including those to be compiled as static and dynamic 
   libraries (DLLs).
   Extern only declares variables, arrays and objects, and does not define 
   them (different from Common or Dim). It also has the effect of making 
   symbolname a shared name, meaning it is visible within procedures (see 
   Shared). A symbolname declared as external name can be (re)defined 
   (using Dim or Redim) only in a single external module.

   If Alias is used, aliasname will be used as the external name rather 
   than symbolname, and its case will be preserved.

   Extern was added in order to support the C libraries.

   If Import is used, the name will be added to the dynamic library import 
   list so its address can be fixed at run-time.

Example
   '' extern1.bas

   Extern Foo Alias "foo" As Integer

   Sub SetFoo
      foo = 1234
   End Sub

   '' extern2.bas

   Declare Sub SetFoo

   Extern Foo Alias "foo" As Integer

   Dim foo As Integer = 0

   SetFoo

   Print Foo

Output:

    1234

Platform Differences
   * Windows does not support Extern with a dynamic library (compiled with 
     -dll or -dylib).

Dialect Differences
   * Not available in the -lang qb dialect.

Differences from QB
   * New to FreeBASIC

See also
   * Extern...End Extern
   * Common
   * Dim
   * Shared
   * Alias (Name)
   * Alias (Modifier)



------------------------------------------------------ KeyPgExternBlock ----
Extern...End Extern

Statement block to allow calling of functions compiled for specific 
languages or platforms.

Syntax
   Extern { "C" | "C++" | "Windows" | "Windows-MS" | "rtlib" } [ Lib "
   libname" ]
      declarative statements
   End Extern

Description
   Extern blocks provide default calling conventions for procedures and 
   mandate a certain name decoration.

   Extern "C" blocks provide a default cdecl calling convention to 
   procedures, and also preserve the case of all names declared within 
   them. The same effect can be achieved without the EXTERN block by using 
   cdecl together with an Alias string containing the exact procedure name.

   Extern "C++" blocks are exactly like Extern "C" blocks but they also 
   mangle the names declared within them in a way compatible to that of g++
   -4.x.

   Extern "Windows" blocks provide a default stdcall calling convention to 
   procedures, preserve the case of all names declared within them, and on 
   the Windows platform, append an "@N" suffix to procedure names, where N 
   is the total size in bytes of any procedure parameters. Similar to the 
   Extern "C" block, the same effect can be achieved by using stdcall and 
   Alias.

   Extern "Windows-MS" blocks are exactly like Extern "Windows" blocks but 
   do not append the "@N" suffix to procedure names on Windows.

   Extern "rtlib" blocks combine the name decoration of Extern "c" and the 
   default calling convention of fbc.  When used in a namespace, the symbol 
   respects the scope of the namespace, however, the name decoration (name 
   mangling) links the symbol to a regular C library.  This behaviour may 
   be desired when declaring procedures that exist in the fb run-time 
   library; where calling convention is based on the target, but we would 
   like to have the compile time name respect the namespace.

   Lib "libname" can be used to specify a library which will be linked in 
   as if #Inclib "Libname" or -l libname had been used. Additionally, all 
   procedure declarations inside the Extern block will use the specified Lib
   "libname" as if it was specified as part of their declarations (but it 
   can still be overridden with an explicit Lib "libname").

Example
   '' This procedure uses the default calling convention for the system, which is
   '' STDCALL on Win32 and CDECL on Linux/DOS/*BSD, and is seen externally as
   '' "MYTEST1@4" on Win32 and "MYTEST1" on Linux/DOS/*BSD (following FB's default
   '' ALL-UPPER-CASE name mangling).
   Sub MyTest1 ( ByVal i As Integer )
   End Sub

   Extern "C"
      '' This procedure uses the CDECL convention and is seen externally
      '' as "MyTest2".
      Sub MyTest2 ( ByVal i As Integer )
      End Sub
   End Extern

   Extern "C++"
      '' This procedure uses the CDECL convention and its name is mangled
      '' compatible to g++-4.x, specifically: "_Z7MyTest3i"
      Sub MyTest3 ( ByVal i As Integer )
      End Sub
   End Extern

   Extern "Windows"
      '' This procedure uses the STDCALL convention and is seen externally
      '' as "MyTest4@4" on Windows, and "MyTest4" on Linux, *BSD and DOS.
      Sub MyTest4 ( ByVal i As Integer )
      End Sub
   End Extern

   Extern "Windows-MS"
      '' This procedure uses the STDCALL convention and is seen externally
      '' as "MyTest5".
      Sub MyTest5 ( ByVal i As Integer )
      End Sub
   End Extern

   MyTest1( 0 )
   MyTest2( 0 )
   MyTest3( 0 )
   MyTest4( 0 )

Dialect Differences
   * Extern blocks are only available in the -lang fb dialect.

Differences from QB
   * New to FreeBASIC

Platform Differences
   * On Linux, *BSD and DOS platforms, Extern "Windows" blocks never 
     append a "@N" suffix to procedure names, and thus are equal to Extern 
     "Windows-MS".

See also
   * cdecl
   * stdcall
   * Extern




============================================================================
    F

------------------------------------------------------------ KeyPgFalse ----
False

Intrinsic constant set by the compiler

Syntax
   Const False As Boolean

Description
   Gives the False Boolean value where used.

Example
   Dim b As Boolean = False
   If b Then
      Print "b is True"
   Else
      Print "b is False"
   End If


   b Is False

Version
   * Since fbc 1.04.0

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __False.

Differences from QB
   * New to FreeBASIC

See also
   * True
   * Boolean



-------------------------------------------------------- KeyPgFBMemcopy ----
Fb_Memcopy

Copies a block of memory from a location to another

Syntax
   Declare Function fb_memcopy cdecl ( ByRef dst As Any, ByRef src As Any, 
   ByVal bytes As UInteger ) As Any Ptr

Usage
   [result =] fb_memcopy( dst, src, bytes )

Parameters
   dst
      starting address of destination memory
   src
      starting address of source memory
   bytes
      number of bytes to copy

Return Value
   The starting address of destination memory is returned.

Description
   fb_memcopy copies a given number of bytes from the memory location src 
   to the memory location dst.
   Each starting address is taken from a reference to a variable or array 
   element.
   The memory areas must not overlap (otherwise, the copying is not 
   guaranteed to work properly, especially depending on the platform). Use 
   Fb_Memmove preferably when the memory areas do overlap (safer approach).
   To avoid overflows, the valid memory areas pointed to by both src and 
   dst must be at least equal in size to the number of bytes to be copied.

   The underlying type of the objects pointed to by both the source and 
   destination pointers are irrelevant for this function.
   The function does not check for any terminating null character in the 
   source area. It always copies exactly the given number of bytes.
   The result is a binary copy of the data.

   Note: In order to copy from/to memory referenced by a Pointer, it must 
   be dereferenced first (or else specify in argument term the ByVal 
   keyword in front of the pointer name). Otherwise, fb_memcopy will try to 
   copy the bytes from/to the pointer variable's memory location.

Example
   Type Person
      Dim As ZString * 40 Name
      Dim As Integer age
   End Type

   Dim As ZString Ptr mynameptr = @"Pierre de Fermat"

   Dim As Person person1, person2

   ' using fb_memcopy to copy string
   fb_memcopy(person1.name, *mynameptr, Len(*mynameptr) + 1)
   person1.age = 46

   ' using fb_memcopy to copy structure
   fb_memcopy(person2, person1, SizeOf(Person))

   Print person2.name, person2.age

   Sleep
      
Output:

   Pierre de Fermat             46
   		

Differences from QB
   * The behavior and usage is new to FreeBASIC.

See also
   * fb_MemCopyClear
   * Fb_Memmove



--------------------------------------------------- KeyPgFBMemcopyclear ----
fb_MemCopyClear

Copies the first part of a block of memory from a location to another and 
clears the rest

Syntax
   Declare Sub fb_MemCopyClear ( ByRef dst As Any, ByVal dstlen As UInteger
   , ByRef src As Any, ByVal srclen As UInteger )

Usage
   fb_memcopy( dst, dstlen, src, srclen )

Parameters
   dst
      starting address of destination memory
   dstlen
      number of bytes to write
   src
      starting address of source memory
   srclen
      number of first bytes to copy (other are cleared)

Description
   fb_memcopycopy copies a given number of bytes (dstlen) from the memory 
   location src to the memory location dst, but only the first srclen bytes 
   are really copied and the rest is cleared ((dstlen - srclen) bytes).
   Each starting address is taken from a reference to a variable or array 
   element.
   The memory areas must not overlap (otherwise, the copying is not 
   guaranteed to work properly, especially depending on the platform).
   To avoid overflows, the valid memory areas pointed to by both src and 
   dst must be at least equal in size to the number of bytes to be copied 
   (including the bytes cleared).

   The underlying type of the objects pointed to by both the source and 
   destination pointers are irrelevant for this function.
   The function does not check for any terminating null character in the 
   source area. It always copies exactly the given number of bytes.
   The result is a binary copy of the data for the first srclen bytes and a 
   zeroing for the rest ((dstlen - srclen) bytes).

   Note: In order to copy from/to memory referenced by a Pointer, it must 
   be dereferenced first (or else specify in argument term the ByVal 
   keyword in front of the pointer name). Otherwise, fb_MemCopyClear will 
   try to copy the bytes from/to the pointer variable's memory location.

Example
   Dim src As ZString * 10 = "FreeBASIC"
   Dim dst As ZString * 10 = "012345678"

   Print "before:"
   Print "src = " & src
   Print "dst = " & dst
   Print

   '' copy first 4 bytes and clear the rest
   fb_MemCopyClear(dst, SizeOf(dst), src, 4)

   Print "after:"
   Print "src = " & src
   Print "dst = " & dst

   Sleep
      
Output:

   before:
   src = FreeBASIC
   dst = 012345678

   after:
   src = FreeBASIC
   dst = Free
   		

Differences from QB
   * The behavior and usage is new to FreeBASIC.

See also
   * Fb_Memcopy
   * Fb_Memmove



-------------------------------------------------------- KeyPgFBMemmove ----
Fb_Memmove

Copies a block of memory from a location to another

Syntax
   Declare Function fb_memmove cdecl ( ByRef dst As Any, ByRef src As Any, 
   ByVal bytes As UInteger ) As Any Ptr

Usage
   [result =] fb_memmove( dst, src, bytes )

Parameters
   dst
      starting address of destination memory
   src
      starting address of source memory
   bytes
      number of bytes to copy

Return Value
   The starting address of destination memory is returned.

Description
   fb_memmove copies a given number of bytes from the memory location src 
   to the memory location dst. Each starting address is taken from a 
   reference to a variable or array element.
   Copying takes place as if an intermediate buffer were used, allowing the 
   destination and source areas to overlap in any way (safer approach, and 
   for any platform). Using Fb_Memcopy is sufficient (and may induce 
   greater speed) when the memory areas do not overlap.
   To avoid overflows, the valid memory areas pointed to by both src and 
   dst must be at least equal in size to the number of bytes to be copied.

   The underlying type of the objects pointed to by both the source and 
   destination pointers are irrelevant for this function.
   The function does not check for any terminating null character in the 
   source area. It always copies exactly the given number of bytes.
   The result is a binary copy of the data.

   Note: In order to copy from/to memory referenced by a Pointer, it must 
   be dereferenced first (or else specify in argument term the ByVal 
   keyword in front of the pointer name). Otherwise, fb_memmove will try to 
   copy the bytes from/to the pointer variable's memory location.

Example
   Dim As ZString * 33 z = "memmove can be very useful......"

   Print z

   fb_memmove(z[20], z[15], 11)

   Print z

   Sleep
      
Output:

   memmove can be very useful......
   memmove can be very very useful.
   		

Version
   * Since fbc 1.08.0

Differences from QB
   * The behavior and usage is new to FreeBASIC.

See also
   * Fb_Memcopy
   * fb_MemCopyClear



---------------------------------------------------------- KeyPgFBArray ----
Fbarray (Array Descriptor Structure And Access)

Pre-defined structure (UDT) and procedure declarations from the fbc-int/arra
y.bi include file, usable to access the array descriptor data fields.

Syntax
   From ./inc/fbc-int/array.bi:
   # If __FB_LANG__ = "fb"
   Namespace FBC
   # endif

   Const FB_MAXDIMENSIONS As Integer = 8

   Type FBARRAYDIM
      Dim As UInteger elements     '' number of elements
      Dim As Integer LBound        '' dimension lower bound
      Dim As Integer UBound        '' dimension upper bound
   End Type

   Const FBARRAY_FLAGS_DIMENSIONS = &h0000000f    '' number of entries allocated in dimTb()
   Const FBARRAY_FLAGS_FIXED_DIM  = &h00000010    '' array has fixed number of dimensions
   Const FBARRAY_FLAGS_FIXED_LEN  = &h00000020    '' array points to fixed-length memory
   Const FBARRAY_FLAGS_RESERVED   = &hffffffc0    '' reserved, do not use

   Type FBARRAY
      Dim As Any Ptr index_ptr     '' @array(0, 0, 0, ... )
      Dim As Any Ptr base_ptr      '' start of memory at array lowest bounds
      Dim As UInteger size         '' byte size of allocated contents
      Dim As UInteger element_len  '' byte size of single element
      Dim As UInteger dimensions   '' number of dimensions
      Dim As UInteger flags        '' FBARRAY_FLAGS_*

      '' take care with number of dimensions; fbc may allocate
      '' a smaller descriptor with fewer than FB_MAXDIMENSIONS
      '' in dimTb() if it is known at compile time that they
      '' are never needed.  Always respect number of 
      '' dimensions when accessing dimTb()

      Dim As FBARRAYDIM dimTb(0 To FB_MAXDIMENSIONS-1)
   End Type

   Extern "rtlib"
      Declare Function ArrayDescriptorPtr Alias "fb_ArrayGetDesc" _
         ( array() As Any ) As FBC.FBARRAY Ptr
      Declare Function ArrayConstDescriptorPtr Alias "fb_ArrayGetDesc" _
         ( array() As Const Any ) As Const FBC.FBARRAY Ptr
   End Extern

   # If __FB_LANG__ = "fb"
   End Namespace
   # endif
         

Usage
   #include once "fbc-int/array.bi"
   using FBC

   ' then:
      Dim pd As FBARRAY Ptr
      ...
      pd = ArrayDescriptorPtr ( array() )

   ' or safer:
      Dim pd As Const FBARRAY Ptr
      ...
      pd = ArrayConstDescriptorPtr ( array() )

Parameters
   pd 
      The name of a pointer to the array descriptor
   array 
      The name of the array for which one want to access its descriptor

Description
   At compile time, fbc allocates an array descriptor to store and track 
   information about the array.

   If the number of dimensions is unknown at compile time, then the full 
   FB_MAXDIMENSIONS is allocated in the dimTb() field.  Otherwise, if the 
   number dimensions is known at compile time, then only the number of 
   dimensions needed are allocated.  Therefore the allocated FBARRAY data 
   may be smaller than the declared FBARRAY structure.

   If an array is passed as argument to a procedure, an array descriptor is 
   allocated.  However, if the array is static, fixed length, and never 
   passed as an argument, then all information about the array is known at 
   compile time, including memory locations, and the allocation of a 
   descriptor is optimized out, since all expressions involving the array 
   are compile time constant.

   The array descriptor may also be allocated at run time, as would be in 
   the case of allocating a new UDT containing a variable-length array 
   field member.

   WARNING: It is inadvisable (especially for a non advanced user) to 
   change the data values of the array descriptor (internal structure 
   of the compiler).
   For that, it is safer to use rather the function 
   ArrayConstDescriptorPtr() initializing a pointer declared As Const 
   FBARRAY Ptr (or implicitly declared in this way by Var).

   FBARRAY.index_ptr
      Pointer to the array data @array(0, 0, ...).  This pointer may be 
      outside of the actual array data as a kind of virtual pointer to use 
      when calculating offsets using indexes in to the array.

   FBARRAY.base_ptr
      Pointer to the array's memory at the array's lowest bound.  For 
      variable-length arrays allocated at run time, this points to the 
      allocated memory region (i.e. malloc)

   FBARRAY.size
      Total size in bytes of the array data.  Size is equal to total number 
      of elements in the array (all dimensions) multiplied by element 
      length.  i.e. size = dimTb(0).elements * element_len + 
      dimTb(1).elements * element_len + ...

   FBARRAY.element_len
      Size in bytes of an individual element.  Must be set to non-zero 
      value.

   FBARRAY.dimensions
      Number of valid dimensions in the dimTb() table.  A value of zero (0) 
      indicates that dimTb() has FB_MAXDIMENSIONS avaiable, but the array 
      does not yet have number of dimensions defined.  On first REDIM, the 
      number of dimensions will be set.

   FBARRAY.flags
      The flags field contains information about the array descriptor that 
      needs to be known at run time.

         FBARRAY_FLAGS_DIMENSIONS : a 4 bit field to indicate the number of 
         elements allocated in dimTb().  If fbc can determine at compile 
         time that less than FB_MAXDIMENSIONS are needed to represent the 
         array, then only the number of dimensions needed are allocated in 
         dimTb().
         The real size allocated for the array descriptor can be calculated 
         by:
            Sizeof(FBC.FBARRAY) - (FBC.FB_MAXDIMENSIONS - (FBC.
            ArrayDescriptorPtr(array())->flags And 
            FBC.FBARRAY_FLAGS_DIMENSIONS)) * Sizeof(FBC.FBARRAYDIM)

         FBARRAY_FLAGS_FIXED_DIM : if this bit is set, indicates that the 
         number of dimensions are set and are given in dimTb() and must not 
         be changed.

         FBARRAY_FLAGS_FIXED_LEN : if this bit is set, indicates that the 
         array data is fixed length and must not be resized or reallocated

         FBARRAY_FLAGS_RESERVED : all other bits are reserved for future 
         use

   FBARRAY.dimTb()
      dimTb() is an array of FBARRAYDIM to indicate the bounds of each 
      dimension.

      If the number of dimensions is unknown at compile time, then the full 
      FB_MAXDIMENSIONS is allocated in the dimTb() field. Otherwise, if the 
      number dimensions is known at compile time, then only the number of 
      dimensions needed are allocated. Therefore the allocated FBARRAY data 
      may be smaller than the declared FBARRAY structure.

   FBARRAYDIM.elements
      Number of elements in the dimension.  i.e. (ubound-lbound+1)

   FBARRAYDIM.lbound
      Lower bound is the lowest valid index in this dimension.

   FBARRAYDIM.ubound
      Upper bound is the highest valid index in this dimension.

   ArrayDescriptorPtr( array() as any ) as FBC.FBARRAY ptr
      Retrieves a pointer to the array descriptor, returning a pointer to 
      FBC.ARRAY that can be modified.

   ArrayConstDescriptorPtr( array() as const any ) as const FBC.FBARRAY ptr
      Retrieves a pointer to the array descriptor, returning a pointer to 
      FBC.ARRAY that is read only.

Example
   Very simple syntaxic example highlighting the access capabilities to the 
   data fields of an array descriptor:
   #include "fbc-int/array.bi"

   Sub printArrayDescriptor (ByVal p As Any Ptr, ByVal tabulation As Integer = 0, ByRef title As String = "")
      Dim As FBC.FBARRAY Ptr pd = p
      Dim As Integer t = 0
      If title <> "" Then
         Print title
         t = 1
      End If
      Print Space((t    ) * tabulation) & "[@array descriptor: @&h"; Hex(pd, 2 * SizeOf(Any Ptr)) & " / "; _
                                                      SizeOf(FBC.FBARRAY) - (8 - pd->dimensions) * 3 * SizeOf(Integer) & " bytes]"'
      Print Space((t + 1) * tabulation) & "@array(all_null_indexes)      =&h"; Hex(pd->index_ptr, 2 * SizeOf(Any Ptr))
      Print Space((t + 1) * tabulation) & "@array(all_min_indexes)       =&h"; Hex(pd->base_ptr, 2 * SizeOf(Any Ptr))
      Print Space((t + 1) * tabulation) & "array_total_size_in_bytes     ="; pd->size
      Print Space((t + 1) * tabulation) & "array_element_size_in_bytes   ="; pd->element_len
      Print Space((t + 1) * tabulation) & "number_of_array_dimensions    ="; pd->dimensions
      Print Space((t + 1) * tabulation) & "fixed_len/fixed_dim/dimensions="; (pd->flags And FBC.FBARRAY_FLAGS_FIXED_LEN) Shr 5 & "/"; _
                                                            (pd->flags And FBC.FBARRAY_FLAGS_FIXED_DIM) Shr 4 & "/"; _
                                                            (pd->flags And FBC.FBARRAY_FLAGS_DIMENSIONS)
      For i As Integer = 0 To pd->dimensions - 1
         Print Space((t + 1) * tabulation) & "[dimension number:"; i + 1; "]"
         Print Space((t + 2) * tabulation) & "number_of_elements="; pd->dimTb(i).elements
         Print Space((t + 2) * tabulation) & "min_index         ="; pd->dimTb(i).LBound
         Print Space((t + 2) * tabulation) & "max_index         ="; pd->dimTb(i).UBound
      Next i
   End Sub

   Screen 0
   Width , 35

   Dim As LongInt test1(0 To 9, 1 To 100)
   printArrayDescriptor(FBC.ArrayDescriptorPtr(test1()), 4, "'Dim As Longint test1(0 to 9, 1 to 100)':")
   Sleep
   Cls
   Dim As LongInt test2()
   printArrayDescriptor(FBC.ArrayDescriptorPtr(test2()), 4, "'Dim As Longint test2()':")
   Print
   ReDim test2(0 To 9, 1 To 100)
   printArrayDescriptor(FBC.ArrayDescriptorPtr(test2()), 4, "'Redim test2(0 to 9, 1 to 100)':")
   Sleep
   Cls
   Dim As LongInt test3(Any, Any)
   printArrayDescriptor(FBC.ArrayDescriptorPtr(test3()), 4, "'Dim As Longint test3(Any, Any)':")
   Print
   ReDim test3(0 To 9, 1 To 100)
   printArrayDescriptor(FBC.ArrayDescriptorPtr(test3()), 4, "'Redim test3(0 to 9, 1 to 100)':")

   Sleep
         
Output example (32-bit):

   'Dim As Longint test1(0 to 9, 1 to 100)':
   	[@array descriptor: @&h0019DE70 / 48 bytes]
   		@array(all_null_indexes)      =&h0019DE98
   		@array(all_min_indexes)       =&h0019DEA0
   		array_total_size_in_bytes     =8000
   		array_element_size_in_bytes   =8
   		number_of_array_dimensions    =2
   		fixed_len/fixed_dim/dimensions=1/1/2
   		[dimension number: 1]
   			number_of_elements=10
   			min_index         = 0
   			max_index         = 9
   		[dimension number: 2]
   			number_of_elements=100
   			min_index         = 1
   			max_index         = 100
   			


   'Dim As Longint test2()':
   	[@array descriptor: @&h0019DDF8 / 24 bytes]
   		@array(all_null_indexes)      =&h00000000
   		@array(all_min_indexes)       =&h00000000
   		array_total_size_in_bytes     =0
   		array_element_size_in_bytes   =8
   		number_of_array_dimensions    =0
   		fixed_len/fixed_dim/dimensions=0/0/8

   'Redim test2(0 to 9, 1 to 100)':
   	[@array descriptor: @&h0019DDF8 / 48 bytes]
   		@array(all_null_indexes)      =&h01FD2AB8
   		@array(all_min_indexes)       =&h01FD2AC0
   		array_total_size_in_bytes     =8000
   		array_element_size_in_bytes   =8
   		number_of_array_dimensions    =2
   		fixed_len/fixed_dim/dimensions=0/0/8
   		[dimension number: 1]
   			number_of_elements=10
   			min_index         = 0
   			max_index         = 9
   		[dimension number: 2]
   			number_of_elements=100
   			min_index         = 1
   			max_index         = 100
   			


   'Dim As Longint test3(Any, Any)':
   	[@array descriptor: @&h0019DDC8 / 48 bytes]
   		@array(all_null_indexes)      =&h00000000
   		@array(all_min_indexes)       =&h00000000
   		array_total_size_in_bytes     =0
   		array_element_size_in_bytes   =8
   		number_of_array_dimensions    =2
   		fixed_len/fixed_dim/dimensions=0/1/2
   		[dimension number: 1]
   			number_of_elements=0
   			min_index         = 0
   			max_index         = 0
   		[dimension number: 2]
   			number_of_elements=0
   			min_index         = 0
   			max_index         = 0

   'Redim test3(0 to 9, 1 to 100)':
   	[@array descriptor: @&h0019DDC8 / 48 bytes]
   		@array(all_null_indexes)      =&h01FD4C20
   		@array(all_min_indexes)       =&h01FD4C28
   		array_total_size_in_bytes     =8000
   		array_element_size_in_bytes   =8
   		number_of_array_dimensions    =2
   		fixed_len/fixed_dim/dimensions=0/1/2
   		[dimension number: 1]
   			number_of_elements=10
   			min_index         = 0
   			max_index         = 9
   		[dimension number: 2]
   			number_of_elements=100
   			min_index         = 1
   			max_index         = 100
   			

Version
   * Since fbc 1.08.0

Dialect Differences
   * Only available in the -lang fb dialect.

Differences from QB
   * New to FreeBASIC.

See also
   * Arrays
    


------------------------------------------------------------ KeyPgField ----
Field

Specifies field alignment.

Syntax
   Type|Union typename Field = { 1 | 2 | 4 }
      ...
   End Type|Union

Description
   Field can be used to pack Types or Unions more tightly than 
   the default layout. The most commonly used value is Field = 1, which 
   causes the Type or Union to be packed as tightly as possible, without 
   any padding bytes being added between the fields or at the end of the 
   Type. Field can only be used to decrease field alignment, but it cannot 
   be used to increase it. In order to add padding bytes, a Union with 
   appropriate members could be used instead.

Example
   Type bitmap_header Field = 1
      bfType          As UShort
      bfsize          As ULong
      bfReserved1     As UShort
      bfReserved2     As UShort
      bfOffBits       As ULong
      biSize          As ULong
      biWidth         As ULong
      biHeight        As ULong
      biPlanes        As UShort
      biBitCount      As UShort
      biCompression   As ULong
      biSizeImage     As ULong
      biXPelsPerMeter As ULong
      biYPelsPerMeter As ULong
      biClrUsed       As ULong
      biClrImportant  As ULong
   End Type

   Dim bmp_header As bitmap_header

   'Open up bmp.bmp and get its header data:
   'Note: Will not work without a bmp.bmp to load . . .
   Open "bmp.bmp" For Binary As #1

      Get #1, , bmp_header
      
   Close #1

   Print bmp_header.biWidth, bmp_header.biHeight

   Sleep

Dialect Differences
   *In the -lang qb dialect, the compiler assumes Field = 1 by default, if 
     no other Field was specified, causing all structures to be tightly 
     packed, without added padding, as in QB.

Differences from QB
   * In QB Field was used to define fields in a file buffer at run time. 
     This feature is not implemented in FB, so the keyword has been 
     redefined. To define fields in a file buffer, Types must be used.

See also
   * Type
   * Union
   * Structure packing/field alignment



--------------------------------------------------------- KeyPgFileattr ----
FileAttr

Returns information about an open file number

Syntax
   Declare Function FileAttr ( ByVal filenum As Long, ByVal returntype As 
   Long = 1 ) As Integer

Usage
   #include "file.bi"
   result = FileAttr( filenum, [ returntype ] )

or

   #include "vbcompat.bi"
   result = FileAttr( filenum, [ returntype ] )

Parameters
   filenum
      The file number of a file or device opened with Open
   returntype
      An integer value indicating the type of information to return.

Return Value
   A value associated with the return type, otherwise 0 on error.

Description
   Information about the file number is returned based on the supplied 
   returntype
         +-----+-----------+------------------+
         |Value|Description|constant          |
         |1    |File Mode  |fbFileAttrMode    |
         |2    |File Handle|fbFileAttrHandle  |
         |3    |Encoding   |fbFileAttrEncoding|
         +-----+-----------+------------------+

   For File Mode, returntype = 1 (fbFileAttrMode) the return value is the 
   sum of one or more of the following values: 
         +-----+---------+----------------+
         |Value|File Mode|Constant        |
         |1    |Input    |fbFileModeInput |
         |2    |Output   |fbFileModeOutput|
         |4    |Random   |fbFileModeRandom|
         |8    |Append   |fbFileModeAppend|
         |32   |Binary   |fbFileModeBinary|
         +-----+---------+----------------+

   For File Handle, returntype = 2 (fbFileAttrHandle), the return value is 
   the file handle as supplied by the C Runtime for file-type devices.  

   On Windows only: For File Handle, returntype = 2 (fbFileAttrHandle), the 
   value returned for COM devices is the handle returned by CreateFile() 
   when the device was first opened.  The value returned for LPT devices is 
   the handle returned by OpenPrinter() when the device was first opened.  
   This handle value can be passed to other Windows API functions.

   On Linux only: For File Handle, returntype = 2 (fbFileAttrHandle), the 
   value returned for COM devices is the file descriptor returned by open() 
   when the device was first opened.

   For Encoding, returntype = 3 (fbFileAttrEncoding), the return value is 
   one of the following values:
         +-----+--------+----------------+
         |Value|Encoding|Constant        |
         |0    |Ascii   |fbFileEncodASCII|
         |1    |UTF-8   |fbFileEncodUTF8 |
         |2    |UTF-16  |fbFileEncodUTF16|
         |3    |UTF-32  |fbFileEncodUTF32|
         +-----+--------+----------------+

Example
   #include "vbcompat.bi"
   #include "crt.bi"

   Dim f As FILE Ptr, i As Integer

   '' Open a file and write some text to it

   Open "test.txt" For Output As #1
   f = Cast( FILE Ptr, FileAttr( 1, fbFileAttrHandle ))
   For i = 1 To 10
     fprintf( f, !"Line %i\n", i )
   Next i
   Close #1

   '' re-open the file and read the text back

   Open "test.txt" For Input As #1
   f = Cast( FILE Ptr, FileAttr( 1, fbFileAttrHandle ))
   While feof(f) = 0
     i = fgetc(f)
     Print Chr(i);
   Wend
   Close #1

Differences from QB
   * None for returntype = 1
   * QBasic and 16-bit Visual Basic returned DOS file handle for 
     returntype = 2
   * returntype = 3 is new to FreeBASIC

See also
   * Open



--------------------------------------------------------- KeyPgFilecopy ----
FileCopy

Copies a file

Syntax
   Declare Function FileCopy ( ByVal source As ZString Ptr, ByVal 
   destination As ZString Ptr ) As Long

Usage
   #include "file.bi"
   FileCopy source, destination

or

   #include "file.bi"
   result = FileCopy( source, destination )

Parameters
   source
      A String argument specifying the filename of the file to copy from.  
      This file must exist.
   destination
      A String argument specifying the filename of the file to copy to.  
      This file will be overwritten if it exists.  This file should not be 
      currently referenced by any open file handles.

Return Value
   Returns 0 on success, or 1 if an error occurred.

Description
   Copies the contents of the source file into the destination file, 
   overwriting the destination file if it already exists.
   It is necessary to #include either "file.bi" or "vbcompat.bi" in order 
   to gain access to this function.

   The error code returned by FileCopy can be checked using Err in the next 
   line. The function version of  FileCopy returns directly the error code 
   as a 32 bit Long.

Example
   #include "file.bi"
   FileCopy "source.txt", "destination.txt"

Platform Differences
   * Linux requires the filename case matches the real name of the file. 
     Windows and DOS are case insensitive. 
   * Path separators in Linux are forward slashes /. Windows uses backward 
     slashes \ but it allows forward slashes.  DOS uses backward  slashes \
     . 

Differences from QB
   * New to FreeBASIC.  Existed in Visual Basic.

See also



----------------------------------------------------- KeyPgFiledatetime ----
FileDateTime

Returns the last modified date and time of a file as Date Serial 

Syntax
   Declare Function FileDateTime ( ByVal filename As ZString Ptr ) As Double

Usage
   #include "file.bi"
   result = FileDateTime( filename )

or

   #include "vbcompat.bi"
   result = FileDateTime( filename )

Parameters
   filename
      Filename to retrieve date and time for.

Return Value
   Returns a Date Serial.

Description
   Returns the file's last modified date and time as Date Serial.

Example
   #include "vbcompat.bi"

   Dim filename As String, d As Double

   Print "Enter a filename: "
   Line Input filename

   If FileExists( filename ) Then

     Print "File last modified: ";

     d = FileDateTime( filename )

     Print Format( d, "yyyy-mm-dd hh:mm AM/PM" )

   Else

     Print "File not found"

   End If

Platform Differences
   * Linux requires the filename case matches the real name of the file. 
     Windows and DOS are case insensitive. 
   * Path separators in Linux are forward slashes / . Windows uses 
     backward slashes \ but it allows forward slashes.  DOS uses backward 
     slashes \.

Differences from QB
   * New to FreeBASIC

See also
   * Date Serials



------------------------------------------------------- KeyPgFileexists ----
FileExists

Tests the existence of a file

Syntax
   Declare Function FileExists ( ByVal filename As ZString Ptr ) As Long

Usage
   #include "file.bi"
   result = FileExists( filename )

or

   #include "vbcompat.bi"
   result = FileExists( filename )

Parameters
   filename
      Filename to test for existence.

Return Value
   Returns non-zero (-1) if the file exists, otherwise returns zero (0).

Description
   FileExists tests for the existence of a file.
   Internally, it may issue an Open() and a Close() function, which may 
   have consequences - eg, any existing Lock(s) on the file may be 
   released.
   Depending on the exact requirements, alternative methods of checking for 
   file existence may be to use the Dir() function (being careful of 
   attributes and ensuring the path doesn't contain wildcards), or to try 
   Opening the file and checking the return value for success.

Example
   #include "vbcompat.bi"

   Dim filename As String

   Print "Enter a filename: "
   Line Input filename

   If FileExists( filename ) Then
     Print "File found: " & filename
   Else
     Print "File not found: " & filename
   End If

Platform Differences
   * Linux requires the filename case matches the real name of the file. 
     Windows and DOS are case insensitive. 
   * Path separators in Linux are forward slashes /. Windows uses backward 
     slashes \ but it allows for forward slashes.  DOS uses backward \ 
     slashes. 

Differences from QB
   * New to FreeBASIC

See also
   * Dir



-------------------------------------------------------- KeyPgFileflush ----
FileFlush

Flush application stream buffers to system, or system buffers to file

Syntax
   Declare Function FileFlush ( ByVal filenum As Long = -1, ByVal 
   systembuffers As Long = 0 ) As Long

Usage
   #include "file.bi"
   result = FileFlush()
   result = FileFlush( filenum )
   result = FileFlush( filenum, systembuffers )

Parameters
   filenum
      File number of bound file or device.  If not given, or -1, then flush 
      all open files.
   systembuffers
      If non-zero, flush system buffers to physical device.  Default is 
      zero (0).

Return Value
   Returns zero (0) for success or an error code if file buffers could not 
   be flushed.

Description
   FileFlush writes application buffered output to the underlying stream, 
   and if systembuffers is non-zero, to the underlying physical device as 
   well.

   In the form FileFlush(filenum), the application output buffer for a 
   specific file are written.  And in the form FileFlush, all application 
   buffers are written to the system.  Typically, when a file is opened, 
   the stream will be block buffered for binary and random files, and line 
   buffered for append and output files.  The FileFlush function overrides 
   the normal buffering of the application and immediately writes buffered 
   output to the system.  The system may have it's own buffers as well.

   In the form FileFlush(filenum,1), both the application buffer is flushed 
   and the underlying system buffer is flushed to physical device.  In the 
   form FileFlush(,1), all application buffers are flushed and all 
   underlying system buffers are flushed to physical device.

Example
   #include "file.bi"

   Dim As Long f1, f2
   Dim As String s

   Print "File length", "File string"

   f1 = FreeFile
   Open "fileflushtest.txt" For Output As #f1
   Print #f1, "successful file flush"

   f2 = FreeFile
   Open "fileflushtest.txt" For Input As #f2
   Line Input #f2, s
   Print FileLen("fileflushtest.txt"), "'" & s & "'"  '' the string is not yet physically written to the file

   FileFlush(f1)
   Line Input #f2, s
   Print FileLen("fileflushtest.txt"), "'" & s & "'"  '' the string is now physically written to the file

   Close #f2
   Close #f1

   Sleep
      
Output (Windows):

   File length   File String
    0            ''
    23           'successful file flush'
   		

Version
   * Since fbc 1.08.0

Differences from QB
   * New to FreeBASIC.

See also
   * Close



---------------------------------------------------------- KeyPgFilelen ----
FileLen

Finds the length of a file given its filename

Syntax
   Declare Function FileLen ( filename As String ) As LongInt

Usage
   #include "file.bi"
   result = FileLen(filename)

or

   #include "vbcompat.bi"
   result = FileLen(filename)

Parameters
   filename
      A String argument specifying the filename of the file whose length to 
      return.

Description
   Returns the size in bytes of the file specified by filename.

Example
   #include "file.bi"
   Dim length As Integer
   length = FileLen("file.txt")

Platform Differences
   * Linux requires the filename case matches the real name of the file. 
     Windows and DOS are case insensitive. 
   * Path separators in Linux are forward slashes / . Windows uses 
     backward slashes \ but it allows for forward slashes .  DOS uses 
     backward  \ slashes. 

Differences from QB
   * New to FreeBASIC.  Existed in Visual Basic.

See also
   * LOF



------------------------------------------------------- KeyPgFileseteof ----
FileSetEof

Sets the length of a open file bound to a file number

Syntax
   Declare Function FileSetEof ( ByVal filenum As Long ) As Long

Usage
   #include "file.bi"
   result = FileSetEof(fnum)

Parameters
   filenum
      File number of bound file or device.

Return Value
   Returns zero (0) for success or an error code if the end of file (file 
   size) could not be set.

Description
   FileSetEof Sets the end of file based on the current file position.  
   File position as in Seek is one based.

   When the current file position is before the end of the file, the file 
   is truncated.  File contents before the the current file position are 
   kept, and file contents on or after the current file position are 
   deleted.  When the current position is beyond the end of file, the file 
   is extended with zero value bytes.  After FileSetEof completes, the 
   current file position is at the end of the file.

   To set a file having a length of N-bytes where the file is opened for 
   binary, output, or append, it is necessary to Seek to position N-bytes + 
   1.  To set a file having a length of N-records where the file is opened 
   for random, it is necessary to Seek to position N-records + 1.

Example
   #include "file.bi"

   '' create a zero length file
   Open "file.dat" For Binary As #1
   FileSetEof 1
   Close #1

   '' open same file and extend to 10000 bytes size
   Open "file.dat" For Binary As #1
   Seek #1, (10000 + 1)
   FileSetEof 1
   Close #1

   '' open same file and truncate to 5000 bytes size
   Open "file.dat" For Binary As #1
   Seek #1, (5000 + 1)
   FileSetEof 1
   Close #1

   '' clean-up
   Kill "file.dat"

Version
   * Since fbc 1.08.0

Differences from QB
   * New to FreeBASIC.

See also
   * EOF
   * LOF
   * Seek



-------------------------------------------------------------- KeyPgFix ----
Fix

Returns the integer part of a number, rounding towards zero

Syntax
   Declare Function Fix ( ByVal number As Single ) As Single
   Declare Function Fix ( ByVal number As Double ) As Double
   Declare Function Fix ( ByVal number As Integer ) As Integer
   Declare Function Fix ( ByVal number As UInteger ) As UInteger

Usage
   result = Fix( number )

Parameters
   number
      the floating-point number to truncate

Return Value
   Returns the integer part of number, rounding towards zero.

Description
   Equivalent to: Sgn(number) * Int(Abs(number)).  For example, Fix(1.3) 
   will return 1.0, and Fix(-4.9) will return -4.0.  For integer types, the 
   number is returned unchanged.

   Note: this function is also equivalent to number - Frac(number).

   The Fix unary Operator can be overloaded with user defined types.

Example
   Print Fix(1.9)  '' will print  1
   Print Fix(-1.9) '' will print -1 

Dialect Differences
   * In the -lang qb dialect, this operator cannot be overloaded.

Differences from QB
   * None

See also
   * Int
   * Frac
   * CInt
   * Operator



------------------------------------------------------------- KeyPgFlip ----
Flip

Changes the current video display page

Syntax
   Declare Function Flip ( ByVal frompage As Long = -1, ByVal topage As Long
   = -1 ) As Long

Usage
   Flip [ frompage ] [, topage ]

Parameters
   frompage
      previous page
   topage
      new page to display

Return Value
   Returns zero (0) if successful, or a non-zero error code to indicate a 
   failure.

Description
   In normal graphics mode, Flip is an alias for PCopy and ScreenCopy. See 
   ScreenCopy for details.

   In OpenGL mode, Flip does a hardware page flip and displays the contents 
   of the backbuffer. It is recommended that you call Flip regularly while 
   in OpenGL mode, otherwise your app may also become unresponsive.

   The error code returned by Flip can be checked using Err in the next 
   line. The function version of  Flip returns directly the error code as a 
   32 bit Long.

Example
   ScreenRes 320, 240, 32, 2    'Sets up the screen to be 320x240 in 32-bit color with 2 video pages.
   ScreenSet 1,0                'Sets the working page to 1 and the displayed page to 0

   For n As Integer = 50 To 270

      Cls
      Circle (n, 50),50 ,RGB(255,255,0) 'Draws a circle with a 50 pixel radius in yellow on page 1
      Flip 1,0    'Copies our circle from page 1 to page 0

      Sleep 25
   Next

   Print "Now wasn't that neat!"
   Print "Push any key."
   Flip 1,0    'Copies our text from page 1 to page 0
   Sleep

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Flip.

Differences from QB
   * New to FreeBASIC



-------------------------------------------------------------- KeyPgFor ----
For

Control flow statement, open statement clause, or operator depending on 
context.

Syntax
   For iterator = startvalue To endvalue [ Step increment ]
or
   Open [ device ] "filename" For filemode As #handle
or
   declare operator For ( byref stp as datatype )

Example
   See example at For...Next.

See also
   * For...Next
   * Open
   * Operator

   


---------------------------------------------------------- KeyPgFornext ----
For...Next

Control flow statement for looping

Syntax
   For iterator [ As datatype ] = startvalue To endvalue [ Step stepvalue ]
      [ statement block ]
   Next [ iterator ]

Parameters
   iterator
      a variable identifier that is used to iterate from an initial value 
      to an end value
   datatype
      If specified, the variable iterator will automatically be declared 
      with the type datatype
   startvalue
      an expression that denotes the starting value of the iterator
   endvalue
      an expression used to compare with the value of the iterator
   stepvalue
      an expression that is added to the iterator after every iteration

Description
   A For...Next loop initializes iterator to startvalue, then executes the 
   statement block, incrementing iterator by stepvalue until it exceeds 
   endvalue. If stepvalue is not explicitly given it will set to 1.

   The values of stepvalue and endvalue are stored internally immediately 
   following execution of the For statement and thus neither can be changed 
   inside the For loop.  Comparison operators such as < and > will not be 
   effective as stepvalue or endvalue because the expressions will not be 
   re-evaluated while the loop is running. (The results of the expressions 
   used to define them may be changed, but these changes will not affect 
   the execution of the For loop.) See examples.

   Note: In some dialects, the temporary variables holding stepvalue and 
   endvalue go out of scope at the end of the loop, and their values are 
   not guaranteed to remain unchanged once any code following the loop has 
   been executed.  For this reason, it is recommended never to branch out 
   of a For...Next loop (using Goto or similar), and then jump back into 
   the middle of it later when in the -lang fb or -lang deprecated dialect.

   The iterator must be an intrinsic scalar: only Static/Shared variables 
   and local variables can be used; no other kind can be used, including 
   array elements, UDT members, ByRef parameters or any kind of 
   dereferenced address.

   The iterator may be defined having the same scope as the For statement 
   by using the As datatype syntax.  With this syntax, iterator is created 
   and destroyed within the For...Next scope. See dialect differences 
   below.

   If endvalue is less than startvalue then a negative stepvalue must be 
   specified or the statement block will not execute at all, since 
   startvalue compares greater than endvalue.

   The For statement causes the execution of the statements in the 
   statement block until iterator compares greater than endvalue (or less 
   than endvalue if stepvalue < 0). iterator will be incremented the amount 
   of stepvalue following each execution of the statement block. If an 
   increment is not given, iterator will be implicitly incremented by 1.

   If an Exit For statement is encountered inside the statement block, the 
   loop is terminated, and execution resumes immediately following the 
   enclosing Next statement. If a Continue For statement is encountered, 
   the rest of the statement block is skipped until the block's 
   corresponding Next statement.  The counter's value is incremented and 
   the loop restarted if it is still within the bounds given by endvalue.

   Note: for integer data types, it is not possible to loop up to the 
   highest possible value (or down to the lowest possible value) that can 
   be stored in the variable type, because the loop only breaks when the 
   incremented variable exceeds endvalue, which can never happen.  For 
   example, if you try to iterate an variable from 0 to 255, the loop will 
   only break once the variable reaches 256 or more.  Using a UByte 
   variable for the counter wouldn't work, because although it can hold the 
   numbers 0 to 255, it cannot hold 256.  See Standard Data Type Limits to 
   find the upper and lower limits for the standard data types.

   Like all control flow statements, the For statement can be nested, that 
   is, it can be used in a statement block of another For statement.

   For, Next, and Step are operators that can be overloaded inside user 
   defined types. See Operator For, Operator Next, Operator Step

Example
   Print "counting from 3 to 0, with a step of -0.5"
   For i As Single = 3 To 0 Step -0.5
      Print "i is " & i
   Next i

   Dim As Integer i, j, k, toTemp, stepTemp
   j = 9: k = 1

   For i = 0 To j Step k
      
      j = 0: k = 0 '' Changing j and k has no effect on the current loop.
      Print i;
      
   Next i
   Print

   ' Internally, this is what the above example does:
   j = 9: k = 1

   i = 0: toTemp = j: stepTemp = k
   Do While IIf(stepTemp >= 0, i <= toTemp, i >= toTemp)
      
      j = 0: k = 0 '' Changing j and k has no effect on the current loop.
      Print i;
      
      i += stepTemp
   Loop
   Print

Example of infinite For...Next loop in case of loop up to the highest value 
of an Ubyte iterator (255):
   For ub As UByte = 240 To 255 '' Infinite loop because the end criterion value (255+1=256) can never be reached by the UByte iterator
      Print ub
      If Inkey <> "" Then Exit For
      Sleep 10
   Next ub
The same applies to lowest value of an UByte iterator (0) in case of loop 
down (negative stepvalue).

Dialect Differences
   * In the -lang fb and -lang deprecated dialects, variables declared 
     inside a For..Next block are visible only inside the block, and cannot 
     be accessed outside it. To access duplicated symbols defined as global 
     outside this block, add one or preferably two dot(s) as prefix: .
     SomeSymbol or preferably ..SomeSymbol (or only ..SomeSymbol if inside 
     a With..End With block).
   * In the -lang qb and -lang fblite dialects, variables declared inside 
     a For..Next block (including the counter if declared, and any 
     temporary variables used to hold endvalue or stepvalue), have a 
     procedure-wide scope  as in QB

Differences from QB
   * ByRef arguments cannot be used as counters.

See also
   * Continue
   * Do...Loop
   * Exit



----------------------------------------------------------- KeyPgFormat ----
Format

Formats a number in a specified format

Syntax
   Declare Function Format ( ByVal numerical_expression As Double, ByRef 
   formatting_expression As Const String = "" ) As String

Usage
   #include "string.bi"
   result = Format[$]( numerical_expression, formatting_expression )

Parameters
   numerical_expression
      number to format
   formatting_expression
      formatting pattern

Return Value
   Format returns a string with the result of the numerical expression 
   formatted as indicated in the formatting expression.
   The formatting expression is a string that can yield numeric or 
   date-time values.

Description
   To recover meaningful date-time values the numerical expression must be 
   a date serial obtained from the appropriate functions.
   This function is part of FreeBASIC, however it is not recognized by the 
   compiler unless vbcompat.bi is included.

   "Numeric Formats"
         +--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
         |Symbol                    | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
         | Null string              | General format (no formatting)                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
         |0                         | Digit placeholder: If the number has fewer digits than there are           zeros (on either side of the decimal) in the format expression, leading or trailing zeros are displayed. If there are more digits to the right of the decimal than zeros in the format, the number is rounded. If there are more digits to the left of the decimal than zeros in the format the digits are all displayed                                                                                      |
         | #                        | Digit placeholder: Follows the same rules as for the 0 digit except the leading or trailing zeros are not displayed                                                                                                                                                                                                                                                                                                                                                                      |
         |.                         | Placeholder for decimal point.If the format contains only #'s to the left of . then numbers smaller than 1  are begun with a decimal point.                                                                                                                                                                                                                                                                                                                                              |
         | %                        | Percentage :The expression is multiplied by 100 and the % character is inserted.                                                                                                                                                                                                                                                                                                                                                                                                         |
         |,                         | Thousands separator. Two adjacent commas, or a comma immediately to the left of the decimal point location (whether there is a decimal specified or not) means 'Omit the three digits that fall between these  commas, or between the comma and the decimal point, rounding as needed.'                                                                                                                                                                                                  |
         | E- E+ e- e+              |Scientific format: If a format contains one digit placeholder (0 or #) to the right of an E-, E+, e-, or e+, the number is displayed in scientific  format and an E or e is inserted between the number and its exponent.The number of 0's or #'s to the right determines the number of digits in the exponent. Use E- or e- to place a minus sign next to negative exponents. Use a E+ or e+ to place a minus sign next to negative exponents and a plus sign next to positive exponents.|
         | : ? + $ () space         |   Display literal character  To display a character other than one of these, precede the character with a backslash (\) or enclose the character(s) in double quotation marks                                                                                                                                                                                                                                                                                                            |
         |\                         | Display next character in format string as it is                                                                                                                                                                                                                                                                                                                                                                                                                                         |
         |text between double quotes|  Displays the text inside the double quotes.                                                                                                                                                                                                                                                                                                                                                                                                                                             |
         | :                        | Time separator is used to separate hours, minutes, and seconds when time values are formatted.                                                                                                                                                                                                                                                                                                                                                                                           |
         | /                        | The date separator is used to separate day,month, and year when date values are formatted.                                                                                                                                                                                                                                                                                                                                                                                               |
         +--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

   "Date-Time formats:"
         +----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+
         |Symbol                | Description                                                                                                                                          |
         |d, dd                 | Display the day as a one-digit/two-digit number (1-31/01-31)                                                                                         |
         |ddd                   | Display the day as an abbreviation (Sun-Sat)                                                                                                         |
         |dddd                  | Display the day as a full name (Sunday-Saturday)                                                                                                     |
         |ddddd                 |  Display a serial date number as a complete date (including day, month and year)                                                                     |
         |m, mm                 | Display the month as a one-digit/two-digit number (1-12/01-12).  If immediately following h or hh, the minute rather than the month is displayed     |
         |M, MM                 | Display the month as a one-digit/two-digit number (1-12/01-12), even if immediately following h or hh                                                |
         |mmm                   | Display the month as an abbreviation (Jan-Dec)                                                                                                       |
         |mmmm                  | Display the month as a full name (January-December)                                                                                                  |
         |y, yy                 | Display the year as a two-digit number (00-99)                                                                                                       |
         |yyyy                  | Display the year as a four-digit number (1900-2040)                                                                                                  |
         |h, hh                 | Display the hour as a one-digit/two-digit number (0-23/00-23)                                                                                        |
         |m, mm                 | Display the minute as a one-digit/two-digit number (0-59/00-59).  If not immediately following h or hh, the month rather than the minute is displayed|
         |n, nn                 | Display the minute as a one-digit/two-digit number (0-59/00-59), even if not immediately following h or hh                                           |
         |s, ss                 | Display the second as a one-digit/two-digit number (0-59/00-59)                                                                                      |
         |ttttt                 | Display a time serial number as a complete time, including hour, minute and second                                                                   |
         |AM/PM (Default), am/pm| Use the 12-hour clock displaying AM or am with any hour before noon, PM or pm with any hour between noon and 11:59                                   |
         |A/P, a/p              |  Use the 12-hour clock displaying A or a with any hour before noon, P or p with any hour between noon and 11:59                                      |
         +----------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+

Example
Numeric formats
   #include "string.bi"

   Dim As Double numberVal(...) = {5, -5, .5}
   Dim As String formatStr(...) = {"","0","0.00","#,##0","#,##0.00","0%", "0.00%", "0.00E+00", "0.00E-00"}

   ? "Format string",, Str(numberVal(0)), Str(numberVal(1)), Str(numberVal(2))
   ?
   For iFormat As Integer = 0 To UBound(formatStr)
      ? formatStr(iFormat),,
      For iNumber As Integer = 0 To UBound(numberVal)
         ? Format(numberVal(iNumber), formatStr(iFormat)),
      Next
      ?
   Next

Output:

   Format String               5             -5            0.5

   '                           5             -5            .5            
   0                           5             -5            0             
   0.00                        5.00          -5.00         0.50          
   #,##0                       5             -5            0             
   #,##0.00                    5.00          -5.00         0.50          
   0%                          500%          -500%         50%           
   0.00%                       500.00%       -500.00%      50.00%        
   0.00E+00                    5.00E+00      -5.00E+00     5.00E-01      
   0.00E-00                    5.00E00       -5.00E00      5.00E-01      

Example
Date and time formats
   #include "vbcompat.bi"

   Dim As Double dateTimeVal = DateValue("12/05/1958") + TimeValue("20:50:35")
   Dim As String formatStr(...) = {"yyyy-mm-dd","d-mmmm-yy","d-mmm","mmmm-yyyy","h:mm AM/PM","h:mm:ss AM/PM","h:mm","h:mm:ss","m/d/yy h:mm"}

   ? "Format",, "Display"
   ?
   For iFormat As Integer = 0 To UBound(formatStr)
      ? formatStr(iFormat),, Format(dateTimeVal, formatStr(iFormat))
   Next

Output:

   Format                      Display

   yyyy-mm-dd                  1958-12-05
   d-mmmm-yy                   5-December-58
   d-mmm                       5-Dec
   mmmm-yyyy                   December-1958
   h:mm AM/PM                  8:50 PM
   h:mm:ss AM/PM               8:50:35 PM
   h:mm                        20:50
   h:mm:ss                     20:50:35
   m/d/yy h:mm                 12/5/58 20:50

Dialect Differences
   None

Differences from QB
   * Does not exist in QB 4.5. This function appeared first in PDS 7.1

See also
   * Print Using
   * ? Using
   * Str



------------------------------------------------------------- KeyPgFrac ----
Frac

Returns the decimal part of a number

Syntax
   Declare Function Frac ( ByVal number As Double ) As Double
   Declare Function Frac ( ByVal number As Integer ) As Integer
   Declare Function Frac ( ByVal number As UInteger ) As UInteger

Usage
   result = Frac( number )

Parameters
   number
      the number or expression to get the fraction part of.

Return Value
   Returns the fractional part of a number or expression.

Description
   Equivalent to: (number - Fix(number)).
   For example, Frac(4.25) will return 0.25, and Frac(-1.75) will return 
   -0.75.  For integer types, the value 0 is always returned.

   The Frac unary Operator can be overloaded with user defined types.

Example
   Print Frac(10.625)  '' will print  0.625
   Print Frac(-10.625) '' will print -0.625 

Dialect Differences
   * In the -lang qb dialect, this operator cannot be overloaded.

Differences from QB
   * New to FreeBASIC

See also
   * Fix
   * Operator



-------------------------------------------------------------- KeyPgFre ----
Fre

Returns the amount of free memory available

Syntax
   Declare Function Fre ( ByVal value As Long = 0 ) As UInteger

Usage
   result = Fre( [ value ] )

Parameters
   value
      Unused dummy parameter kept for backward compatibility; can be 
      ignored.

Return Value
   Returns the amount of free memory, in bytes.

Description
   Returns the free memory (ram) available, in bytes.

Example
   Dim mem As Integer = Fre

   Print "Free memory:"
   Print
   Print mem; " bytes"
   Print mem  \ 1024; " kilobytes"
   Print mem  \ (1024 * 1024); " megabytes"

Differences from QB
   * The "value" argument is not checked, Fre will always return the free 
     physical memory available

See also
   * Dim
   * ReDim
   * Allocate



--------------------------------------------------------- KeyPgFreefile ----
FreeFile

Returns a free file number

Syntax
   Declare Function FreeFile ( ) As Long

Usage
   result = FreeFile

Return Value
   The next available file number, if any, otherwise zero (0).

Description
   Returns the number of the next free file number with valid values 1 to 
   255, or 0 if there are already 255 files opened. This value is a 
   required argument to Open a file. FreeFile is useful when opening files 
   in complex programs where the programmer can't keep track of the used 
   file numbers.

   Make sure to always close files when no longer needed, otherwise you 
   will get a file number leak, and won't be able to open any files anymore 
   after 255 filenumbers are exhausted while your program is running.

   FreeFile will always return the smallest free file number. The file 
   number returned by FreeFile will not change until that file number is 
   Opened, or until a smaller file number is Closed:
      - For this reason, it is wise to use FreeFile immediately before its 
      corresponding Open, to ensure that the same file number is not 
      returned and opened elsewhere first.
      - In case of potential conflict with other threads, this non-breaking 
      'FreeFile...Open' sequence must additionally be considered as a 
      critical section of code and therefore must be protected, for example 
      by mutual exclusion (using a mutex locking).

Example
   ' Create a string and fill it.
   Dim buffer As String, f As Long
   buffer = "Hello World within a file."

   ' Find the first free file number.
   f = FreeFile

   ' Open the file "file.ext" for binary usage, using the file number "f".
   Open "file.ext" For Binary As #f

   ' Place our string inside the file, using file number "f".
   Put #f, , buffer

   ' Close the file.
   Close #f

   ' End the program. (Check the file "file.ext" upon running to see the output.)
   End

   When using multiple FreeFile statements, FreeFile should be used 
   immediately before the Open statement:
   Dim As Long fr, fs
   ' The CORRECT way:
   fr = FreeFile
   Open "File1" For Input As #fr

   fs = FreeFile
   Open "File2" For Input As #fs

   As opposed to:
   Dim As Long fr, fs
   ' The WRONG way:
   fr = FreeFile
   fs = FreeFile '' fs has taken the same file number as fr

   Open "file1" For Input As #fr
   Open "file2" For Input As #fs '' error: file number already opened

Platform Differences
   * On Windows, a file number used in a dynamic link library is not the 
     same as an identical file number used in the main program.  File 
     numbers can not be passed or returned and then used between a DLL and 
     an executable.
   * Besides FreeBASIC's limit of 255 files per program opened at same 
     time, there is an OS limit of total amount of opened files, but 
     usually you won't touch it except in DOS, where the limit may be as 
     low as 15 files total.

Differences from QB
   * None

See also
   * Open
   * Put (File I/O)
   * Get (File I/O)
   * FileAttr



--------------------------------------------------------- KeyPgFunction ----
Function

Defines a procedure returning a value

Syntax
   [Public|Private] Function identifier [cdecl|pascal|stdcall] [Overload] [
   Alias external_identifier] [([parameter_list])] [ ByRef ] As return_type 
   [Static] [Export]
      statements
      ...
      { {Return [return_value]}|{Function = return_value}|{identifier = 
      return_value} }
      ...
   End Function

Parameters
   identifier: the name of the function
   external_identifier: externally visible (to the linker) name enclosed in 
   quotes
   parameter_list: parameter[, parameter[, ...]]
   parameter: [ByRef|ByVal] identifier [As type] [= default_value]
      identifier: the name of the variable referenced in the function.  If 
      the argument is an array then the identifier must be followed by an 
      empty parenthesis. 
      type: the type of variable
      default_value: the value of the argument if none is specified in the 
      call
   return_type: the type of variable returned by the function
   statements: one or more statements that make up the function body
   return_value: the value returned from the function

Description
   A function defines a block of code which can be executed with a single 
   statement (a function call), and provide a value back to the caller when 
   finished (a return value). 	There are several reasons to use functions:
   * Reduces redundancy in your program
   * Enables reuse of code in many programs
   * Improves readability of the program
   * Improves maintainability of the program
   * Makes it easy to extend your program

   Access Rights : The Public and Private keywords specify public or 
   private intra module-level access rights, respectively. If neither is 
   given, the function defaults to public access (Public).

   Calling Convention : Calling convention, or the order in which arguments 
   are pushed and popped from the stack during function calls, is specified 
   with the cdecl, pascal and stdcall keywords. If none is given, the 
   function uses the standard convention by default (stdcall).

   Passing Arguments : Functions may receive one or more variables, or 
   arguments, when called. These arguments are listed as parameters in the 
   parameter_list. The ByRef and ByVal keywords specify whether the 
   argument will be passed by reference or by value, respectively. The 
   argument's type is given by "As type" following the parameter. If a 
   parameter in the declaration is given a default value, the parameter is 
   optional.  Array parameters are specified by following an identifier 
   with an empty parenthesis.  Note that array parameters are always ByRef 
   and the ByRef keyword is neither required nor allowed for array 
   parameters.  When calling a function with an array argument the 
   parenthesis must be supplied there too; see the examples.

   Overloaded Functions : An overloaded function may share the same name (
   identifier) as another with a different signature. The Overload keyword 
   specifies that a function may be overloaded. A function must be defined 
   - or declared - using the Overload keyword prior to any functions that 
   overload them.

   Returning values : return_type specifies the data type returned by a 
   function upon exit. If no data type is specified, then the function will 
   return the default data type, which will be Integer unless set to 
   another data type using DefSng, DefDbl, DefStr, etc. Functions can 
   return values using three methods: the Return keyword followed by a 
   value exits the function immediately, and returns that value to the 
   caller. Functions can also return values by assigning the Function 
   keyword or the function's identifier to the desired return value (but 
   Function keyword or function's identifier does not allow to evaluate the 
   current assigned value). The latter two methods do not cause the 
   function to exit, however. Return keyword mixed with Function= keyword 
   or function's identifier= or Exit Function keyword in a same function is 
   unsupported when returning objects with constructors. Since functions 
   return values, function calls evaluate to expressions. Thus, function 
   calls can be made wherever an expression is expected, like in Assignments
   or If statements. Functions can also return references by specifying 
   Byref As return_type.
   Warning: Whatever the output branch used, the return value must be 
   always defined, otherwise an unexpected behavior may occur.

   Local Variable Preservation : The Static keyword specifies that a 
   function's locally declared variables are preserved between function 
   calls. Upon entering a function defined with Static, local variables 
   have the same value as when the function was last called.

   Global Variable Access: To access duplicated symbols defined as global 
   outside the function body, add one or preferably two dot(s) as prefix: .
   SomeSymbol or preferably ..SomeSymbol (or only ..SomeSymbol if inside a 
   With..End With block).

   When calling a function, parentheses surrounding the argument list (if 
   any) are required only for function calls in expressions. If there is no 
   argument to pass, the parentheses become optional, but it is a common 
   convention to place empty parentheses '()' after the function name, to 
   signify a function call.

   Warning for 64-bit compiler only: See the Identifier Rules page for the 
   choice of user procedure identifier names (and specially the 'Platform 
   Differences' paragraph).

Example

   '' This program demonstrates the declaration of a function 
   '' and returning a value using Return command

   Declare Function ReturnTen () As Integer

   Print ReturnTen () '' ReturnTen returns an integer by default.

   Function ReturnTen() As Integer
      Return 10
   End Function

   '' This program demonstrates the declaration of a function 
   '' and returning a value using assignment to function name

   Declare Function ReturnTen () As Integer

   Print ReturnTen () '' ReturnTen returns an integer by default.

   Function ReturnTen() As Integer
      ReturnTen = 10
   End Function

   '' This program demonstrates function overloading.

   '' The overloaded functions must be FIRST.
   Declare Function ReturnTen Overload (a As Single) As Integer
   Declare Function ReturnTen Overload (a As String) As Integer
   Declare Function ReturnTen (a As Integer) As Integer

   Print ReturnTen (10.000!) '' ReturnTen will take a single and return an integer
   Print ReturnTen (10)      '' ReturnTen will take an integer and return an integer
   Print ReturnTen ("10")    '' ReturnTen will take a string and return an integer

   Function ReturnTen Overload (a As Single) As Integer
      Return Int(a)
   End Function

   Function ReturnTen Overload (a As String) As Integer
      Return Val(a)
   End Function

   Function ReturnTen (a As Integer) As Integer
      Return a
   End Function

   '' The following example demonstrates optional parameters.

   Function TestFunc(P As String = "Default") As String
      Return P
   End Function

   Print TestFunc("Testing:")
   Print TestFunc

   '' This example shows how to declare and call 
   '' functions taking array arguments.

   Function x(b() As Double) As Integer
     x = UBound(b)-LBound(b)+1
   End Function

   Dim a(1 To 10) As Double
   Print x(a())
   Dim c(10 To 20) As Double 
   Print x(c())

Dialect Differences
   * In the -lang fb dialect, ByVal is the default parameter passing 
     convention for all built-in types except String; String and 
     user-defined Types are passed ByRef by default.
   * In the -lang qb and -lang fblite dialects, ByRef is the default 
     parameter passing convention.
   * In the -lang qb dialect, the name of the function must be used in an 
     assignment to specify the return value.  Using Function = ..." to 
     specify the return value may not be used.
   * In the -lang qb and -lang fblite dialects, Return may only be used to 
     return a value when Option Gosub is off.  In -lang qb, this must be 
     done explicitly using the Option Nogosub statement.

Differences from QB
   * Parameters can be optional in FreeBASIC.
   * In QBASIC, the return type could only specified with a suffix, not 
     with AS TYPE, and only allowed functions to return a built-in type.
   * Return value can now be specified by a Return statement.
   * Function Overloading is supported in FreeBASIC.
   * The return value of functions can be ignored in the calling code.

See also
   * Sub
   * Exit
   * Return (From Procedure)
   * Declare
   * Public
   * Private



--------------------------------------------------- KeyPgMemberFunction ----
Function (Member)

Declares or defines a member procedure returning a value

Syntax
   { Type | Class | Union } typename
      Declare [ Static | Const ] Function fieldname [calling convention 
      specifier] [ Alias external_name ] ( [ parameters ] ) [ ByRef ] As 
      datatype [ Static ]
   End { Type | Class | Union }

   Function typename.fieldname ( [ parameters ] ) [ ByRef ] As datatype [ 
   Export ]
      statements
   End Function

Parameters
   typename 
      name of the Type, Class, or Union
   fieldname 
      name of the procedure
   external_name
      name of field as seen when externally linked
   parameters 
      the parameters to be passed to the procedure
   calling convention specifier	
      can be one of: cdecl, stdcall or pascal

Description
   Function members are accessed with Operator . (Member Access) or 
   Operator -> (Pointer To Member Access) to call a member procedure that 
   returns a value (a reference can also be returned by specifying Byref As 
   return_type).  The procedure may optionally accept parameters either 
   ByVal or ByRef.  typename be overloaded  without explicit use of the 
   Overload keyword.

   typename is the name of the type for which the Function method is 
   declared and defined.  Name resolution for typename follows the same 
   rules as procedures when used in a Namespace.

   A hidden This parameter having the same type as typename is passed to 
   non-static member procedures.  This is used to access the fields of the 
   Type, Class, or Union.
   To access duplicated symbols defined as global outside the Type, add one 
   or preferably two dot(s) as prefix: .SomeSymbol or preferably ..
   SomeSymbol (or only ..SomeSymbol if inside a With..End With block).

   A Static (Member) may be declared using the Static specifier.  A 
   Const (Member) may be declared using the Const specifier.

   As for a normal Function, the return value of a Function member can be 
   ignored in the calling code.

Example
   #include "vbcompat.bi"

   Type Date

     value As Double

     Declare Static Function Today() As Date

     Declare Function Year() As Integer
     Declare Function Month() As Integer
     Declare Function Day() As Integer

   End Type

   Function Date.Today() As Date
     Return Type(Now())
   End Function

   Function Date.Year() As Integer
     Return ..Year(value)
   End Function

   Function Date.Month() As Integer
     Return ..Month(value)
   End Function

   Function Date.Day() As Integer
     Return ..Day(value)
   End Function

   Dim d As Date = Date.Today

   Print "Year  = "; d.Year
   Print "Month = "; d.Month
   Print "Day   = "; d.Day

Dialect Differences
   * Only available in the -lang fb dialect.

See also
   * Class
   * Function
   * Sub (Member)
   * Type



------------------------------------------------------ KeyPgFunctionPtr ----
Function Pointer

Data type that stores a pointer to a Function procedure returning a value

Syntax
   Dim variable As Function [cdecl|pascal|stdcall] [( [parameter_list] )] [ 
   ByRef ] [As return_type] [= initializer]

Parameters
   parameter_list: parameter[, parameter[, ...]]
   parameter: [ByRef|ByVal] identifier [As type] [= default_value]
      identifier: the name of the variable referenced in the function
      type: the type of variable
      default_value: the value of the argument if none is specified in the 
      call
   return_value: the value returned from the function
   intializer: address of a function to set as the initial value

Description
   A Function pointer is a procedure pointer that stores the memory 
   location of compiled code that returns a value.  If no intializer is 
   given the default initial value is zero (0).

   The memory address for the Function procedure can be assigned to the 
   variable by taking the address of a function with ProcPtr or 
   Operator @ (Address Of).

   The procedure must match the same Function declaration as the declared 
   Function pointer.

   To call the function assigned, use the variable name as if it were a 
   normal declared Function, always with parentheses around the parameter 
   list even empty (without parentheses, only the pointer value, ie the 
   address of the function, would be accessed).

   One of the primary uses for Function pointers is to create callback 
   procedures:
      - A callback Function is a Function that is passed through an 
      argument (a Function pointer) to another procedure which is expected 
      to call back (execute) the "argument" at a convenient time.
      - If the callback Function is completely executed before the 
      invocation returns to the caller code, then the callback process is 
      said to be "synchronous".
      - If the invocation immediately returns to the caller code, and the 
      callback Function and the caller's next code are running in parallel, 
      then the callback process is said to be "asynchronous".

Example
   Function ConcatSelf( x As String ) As String
      Return x & x
   End Function

   Dim x As Function( x As String ) As String = ProcPtr( ConcatSelf )

   Print x( "Hello" )

   Function x2 (ByVal i As Integer) As Integer
     Return i * 2
   End Function

   Function x3 (ByVal i As Integer) As Integer
     Return i * 3
   End Function

   Function operation (ByVal i As Integer, ByVal op As Function (ByVal As Integer) As Integer) As Integer
     Return op(i)
   End Function

   Print operation(4, @x2)
   Print operation(4, @x3)

   ' Example of basic callback Function mechanism (asynchronous) to implement a key pressed event:
   ' (the user callback Function address cannot be modified while the event thread is running)
   '   - An asynchronous thread tests the keyboard in a loop, and calls a user callback Function each time a key is pressed.
   '   - The callback Function address is passed to the thread.
   '   - The callback Function prints the character of the key pressed,
   '       but if the key pressed is <escape> it orders the thread to finish by using the function return value.
   '   - As the user callback address is passed to the thread as argument, it cannot be modified while the thread is running.

   '' thread Sub definition
     Sub threadInkey (ByVal p As Any Ptr)
      If p > 0 Then                                                '' test condition callback Function defined
        Dim As Function (ByRef As String) As Integer callback = p  '' convert the any ptr to a callback Function pointer
        Do
         Dim As String s = Inkey
         If s <> "" Then                                          '' test condition key pressed
           If callback(s) Then                                    '' test condition to finish thread
            Exit Do
           End If
         End If
         Sleep 50, 1
        Loop
      End If
     End Sub

   '' user callback Function definition
     Function printInkey (ByRef s As String) As Integer
      If Asc(s) = 27 Then                                        '' test condition key pressed = <escape>
        Print
        Return -1                                                '' order thread to finish
      Else
        Print s;
        Return 0                                                 '' order thread to continue
      End If
     End Function

   '' user main code
     Dim As Any Ptr p = ThreadCreate(@threadInkey, @printInkey)   '' launch the thread, passing the callback Function address
     ThreadWait(p)                                                '' wait for the thread finish

Differences from QB
   * New to FreeBASIC

See also
   * Function
   * ProcPtr
   * Operator @ (Address Of)




============================================================================
    G

------------------------------------------------------ KeyPgGetgraphics ----
Get (Graphics)

Gets a copy of a portion of the current work page or an image buffer

Syntax
   Get [source,] [STEP](x1, y1) - [STEP](x2, y2), dest

Parameters
   source
      the address of an image buffer. If it's omitted, the current work 
      page is copied.
   STEP
      indicates that the following co-ordinates are not absolute 
      co-ordinates.
   [STEP](x1, y1)
      co-ordinates of the upper-left corner of the sub-image to copy.  STEP 
      indicates that (x1, y1) offsets are relative to the current graphics 
      cursor position.
   [STEP](x2, y2)
      co-ordinates of the lower-right corner of the sub-image to copy.  
      STEP indicates that x2 and y2 are relative to x1 and y1, 
      respectively.
   dest
      the address of a previously allocated buffer to store the image data.

Description
   Get copies a rectangular portion of the current work page specified by 
   the co-ordinates (x1,  y1) and (x2,  y2), which represent the upper-left 
   and lower-right corners of the rectangle, respectively. STEP specifies 
   that the upper-left co-ordinates are relative to the current graphics 
   pen location, and/or that the lower-right co-ordinates are relative to 
   the upper-left co-ordinates. The new image buffer is formatted to match 
   the current screen mode pixel format.

   dest can be an address, an array (name not followed by empty 
   parentheses), or a reference to the first element in an array that will 
   receive the new image buffer. This memory must be sufficiently allocated 
   to hold the image buffer (the number of bytes required varies with the 
   -lang dialect used to compile the program). Valid image buffers can be 
   created simply by using preferably the ImageCreate statement.

   source can be an address, an array (name not followed by empty 
   parentheses), or a reference to the first element in an array that holds 
   an image buffer to retrieve a portion of. x1,  y1, x2,  y2, Step and 
   dest have the same meaning in this case.

   The co-ordinates of the rectangle are affected by the most recent Window 
   and View (Graphics) statements, and must both be within the current 
   clipping region set by View (Graphics) (or within the default viewport), 
   otherwise an illegal function call runtime error will be triggered, and 
   the function will have no effect.

Runtime errors:
   Get throws one of the following runtime errors:

   (1) Illegal function call
      * dest is an array, but is not big enough to hold the image buffer.
      * The upper-left or lower-right co-ordinates of the rectangle are 
        outside the current clipping region (set or default). See 
        View (Graphics).

Dialect Differences
   There are 2 types of buffers (details see GfxInternalFormats) depending 
   from FB dialect used:

   * In the -lang fb dialect, dest receives a new-style image buffer, 
     which consists of a 32-byte image header followed by pixel data which 
     is row-padded to the next paragraph boundary (16 bytes). Use the 
     following formula to calculate the total size, in bytes, required to 
     store the image buffer, where w and h are the respective width and 
     height of the rectangular portion of the current work page or source 
     image buffer, and bpp is the number of bytes per pixel of the current 
     screen mode:
      size = 32 + (((w * bpp + &hF) and not &hF) * h)

   * In the -lang qb and -lang fblite dialects, dest receives a QB-style 
     image buffer, which consists of a 4-byte image header followed by 
     pixel data which is not row-padded. Use the following formula to 
     calculate the total size, in bytes, required to store the image 
     buffer, where w and h are the respective width and height of the 
     rectangular portion of the current work page or source image buffer, 
     and bpp is the number of bytes per pixel of the current screen mode:
      size = 4 + (w * h * bpp)

Example
   #include Once "fbgfx.bi"

   '' Setup a 400x300 32bit screen
   ScreenRes 400, 300, 32

   '' First draw funny stuff...
   Line (10,10)-(140,30), RGB(255,255,0), bf
   Draw String (30, 20), "Hello there!", RGB(255,0,0)

   '' Now capture a 150x50 block from the top-left of the screen into an image
   '' buffer with GET...
   Dim As fb.Image Ptr image = ImageCreate(150, 50)
   Get (0,0)-(150-1,50-1), image

   '' And duplicate it all over the place!
   Put (0,50), image
   Put (0,100), image
   Put (0,150), image
   Put (0,200), image
   Put (0,250), image
   Put (150,0), image
   Put (150,50), image
   Put (150,100), image
   Put (150,150), image
   Put (150,200), image
   Put (150,250), image

   ImageDestroy(image)

   '' And a frame around a whole screen..
   Line (0,0)-(400-1,300-1), RGB(255,255,0), b

   '' Now get the whole screen...
   Dim As fb.Image Ptr big = ImageCreate(400, 300)
   Get (0,0)-(400-1,300-1), big

   '' And display that "screenshot" as if it was scrolling by...
   Dim As Integer x = -350
   While ((Inkey() = "") And (x < 350))
      ScreenLock
         Cls
         Put (x,0), big
      ScreenUnlock

      Sleep 100, 1

      x += 10
   Wend

   ImageDestroy(big)

See also
   * Put (Graphics)
   * ImageCreate
   * Get (File I/O)
   * Screen (Graphics)
   * Window
   * View (Graphics)
   * Internal graphics formats



-------------------------------------------------------- KeyPgGetfileio ----
Get (File I/O)

Reads data from a file to a buffer

Syntax
   Get #filenum As Long, [position As LongInt], ByRef data As Any [, [
   amount As UInteger] [, ByRef bytesread As UInteger] ]
   Get #filenum As Long, [position As LongInt], data As String [, , ByRef 
   bytesread As UInteger ]
   Get #filenum As Long, [position As LongInt], data() As Any [, , ByRef 
   bytesread As UInteger ]

Usage
   Get #filenum, position, data [, [amount] [, bytesread ] ]
   varres = Get (#filenum, position, data [, [amount] [, bytesread ] ] )

Parameters
   filenum
      The value passed to Open when the file was opened.
   position
      The position where the read must start. If the file was opened 
      For Random, the position is in records; otherwise, it is in bytes. If 
      omitted, reading starts at the present file pointer position.  The 
      position is 1-based: i.e. first record or byte of a file is at 
      position 1.
      If position is omitted or zero (0), file reading will start from the 
      current file position.
   data
      The buffer where data is written. It can be a numeric variable, a 
      string, an array, a user defined type or a dereferenced pointer. The 
      read operation will try to fill completely the variable, unless the 
      EOF is reached.
      When getting arrays, data should be followed by an empty pair of 
      brackets: "()".  Get will read data for all of the values in the 
      array.  amount is not allowed.
      When getting Strings, the number of bytes read is the same as the 
      number of bytes in the string data. amount is not allowed.
      Note: If you want to read values into a buffer, you should NOT pass a 
      pointer to the buffer; instead you should pass the first variable in 
      the buffer (this can be done by dereferencing the pointer with 
      Operator * (Value Of)). If you pass a pointer directly, then Get will 
      overwrite the pointer variable, not the memory it points to.
   amount
      Makes Get read amount consecutive variables from file to memory, i.e. 
      it reads (amount * SizeOf(data) ) bytes of data from file into the 
      memory starting at data's memory location.  If amount is omitted it 
      defaults to 1, meaning that Get just reads a single variable.
   bytesread
      An unsigned integer variable to accept the result of the number of 
      bytes read successfully from the file.

Return Value
   Get() returns a 32 bit Long: a zero (0) on success; non-zero on error.
   Note: if EOF (end of file) is reached while reading, Get will return 
   success.  The amount of bytes actually read can be checked by passing a 
   bytesread variable.

Description
   Reads binary data from a file to a buffer variable

   Get can be used as a function, and will return 0 on success or an error 
   code on failure.	

   For files opened in Random mode, the size in bytes of the data to read 
   must match the specified record size.

   Note:
      - If a real [w/z]string variable is passed to Get, the amount 
      parameter should be forbidden as it is when passing a string. Do not 
      use. Otherwise, it is ignored (except for the '0' value).
      - If a dereferenced [w/z]string pointer is passed to Get, the amount 
      parameter is not taken into account as it is when passing a 
      dereferenced numeric pointer. Do not use. But instead of respecting 
      the amount parameter, the pointed buffer must begin with at least as 
      many non-zero elements as the number of elements to read.
      - For finer granularity, any [w/z]string variable can be safely 
      passed to Get as a numeric buffer by providing the first numeric 
      element (an indexed [w/z]string variable, or a dereferenced 
      [w/z]string pointer then indexed) and the number of numeric elements 
      to be processed.

Example
   Dim Shared f As Integer

   Sub get_long()

      Dim buffer As Long ' Long variable

      ' Read a Long (4 bytes) from the file into buffer, using file number "f".
      Get #f, , buffer

      ' print out result
      Print buffer
      Print

   End Sub

   Sub get_array()

      Dim an_array(0 To 10-1) As Long ' array of Longs

      ' Read 10 Longs (10 * 4 = 40 bytes) from the file into an_array, using file number "f".
      Get #f, , an_array()

      ' print out result
      For i As Integer = 0 To 10-1
         Print an_array(i)
      Next
      Print

   End Sub

   Sub get_mem

      Dim pmem As Long Ptr

      ' allocate memory for 5 Longs
      pmem = Allocate(5 * SizeOf(Long))

      ' Read 5 Longs (5 * 4 = 20 bytes) from the file into allocated memory
      Get #f, , *pmem, 5 ' Note pmem must be dereferenced (*pmem, or pmem[0])

      ' print out result using [] Pointer Indexing
      For i As Integer = 0 To 5-1
         Print pmem[i]
      Next
      Print

      ' free pointer memory to prevent memory leak
      Deallocate pmem

   End Sub

   ' Find the first free file file number.
   f = FreeFile

   ' Open the file "file.ext" for binary usage, using the file number "f".
   Open "file.ext" For Binary As #f

     get_long()

     get_array()

     get_mem()

   ' Close the file.  
   Close #f

   ' Load a small text file to a string

   Function LoadFile(ByRef filename As String) As String
      
      Dim h As Integer
      Dim txt As String
      
      h = FreeFile
      
      If Open( filename For Binary Access Read As #h ) <> 0 Then Return ""
      
      If LOF(h) > 0 Then
         
         txt = String(LOF(h), 0)
         If Get( #h, ,txt ) <> 0 Then txt = ""
         
      End If
      
      Close #h
      
      Return txt
      
   End Function

   Dim ExampleStr As String
   ExampleStr = LoadFile("smallfile.txt")
   Print ExampleStr

Differences from QB
   * Get in FB can read full arrays as in VB or, alternatively, read a 
     multiple of the data size into the memory.
   * Get can be used as a function in FB, to find the success/error code 
     returned without having to use error handling procedures.
   * FB allows the bytesread parameter, to check how many bytes have been 
     successfully read in.

See also
   * Get (Graphics) different usage of same keyword 
   * Put (File I/O)
   * Open
   * Close
   * Binary
   * Random
   * FreeFile
   * File I/O methods comparison



------------------------------------------------------ KeyPgGetjoystick ----
GetJoystick

Reads buttons and axis information from attached gaming devices

Syntax
   Declare Function GetJoystick ( ByVal id As Long, ByRef buttons As Integer
   = 0, ByRef a1 As Single = 0, ByRef a2 As Single = 0, ByRef a3 As Single 
   = 0, ByRef a4 As Single = 0, ByRef a5 As Single = 0, ByRef a6 As Single 
   = 0, ByRef a7 As Single = 0, ByRef a8 As Single = 0 ) As Integer

Usage
   result = GetJoystick( id[, buttons[, a1[, a2[, a3[, a4[, a5[, a6[, a7[, 
   a8]]]]]]]]] )

Parameters
   id
      the device id number (0 - 15)
   buttons
      the button status
   a1
      first axis value
   a2
      second axis value
   a3
      third axis value
   a4
      fourth axis value
   a5
      fifth axis value
   a6
      sixth axis value
   a7
      seventh axis value
   a8
      eighth axis value

Return Value
   0 on success or 1 on failure.  All of the axis positions are returned in 
   floating point format.

Description
   GetJoystick will retrieves the button state, and the axis positions for 
   up to 8 axes, for the joystick determined by id, a number between 0 and 
   15. Buttons are stored in a similar manner to GetMouse, with each bit in 
   buttons representing a button.

   A single precision value between -1.0 and 1.0 is returned for each valid 
   axis.  If the axis does not exist for the controller, a value of 
   -1000.00 is returned.

   GetJoystick will return 0 upon successful completion; It will return 1 
   upon failure. Failure can be caused by specifying an illegal joystick 
   number, specifying a joystick which doesn't exist, or a failure in the 
   joystick API.

   The error code returned by GetJoystick can be checked using Err in the 
   next line. The function version of  Getjoystick returns directly the 
   error code as a 32 bit Long.

Example
   Screen 12

   Dim x As Single
   Dim y As Single
   Dim buttons As Integer
   Dim result As Integer
   Dim a As Integer

   Const JoystickID = 0

   'This line checks to see if the joystick is ok.

   If GetJoystick(JoystickID,buttons,x,y) Then 
      Print "Joystick doesn't exist or joystick error."
      Print
      Print "Press any key to continue."
      Sleep
      End
   End If

   Do
      result = GetJoystick(JoystickID,buttons,x,y)

      Locate 1,1
      Print ;"result:";result;" x:" ;x;" y:";y;" Buttons:";buttons,"","",""
      
      'This tests to see which buttons from 1 to 27 are pressed. 
      For a = 0 To 26 
         If (buttons And (1 Shl a)) Then 
            Print "Button ";a;" pressed.    "
         Else 
            Print "Button ";a;" not pressed."
         End If
      Next a
   Loop

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Getjoystick.

Differences from QB
   * New to FreeBASIC

See also
   * Screen (Graphics)
   * SetMouse
   * GetMouse
   * MultiKey
   * Event
   * ScreenEvent



----------------------------------------------------------- KeyPgGetkey ----
GetKey

Returns the ascii code of the first key in the keyboard buffer

Syntax
   Declare Function GetKey ( ) As Long

Usage
   result = GetKey

Return Value
   The value of the ascii code returned.

Description
   It returns the ascii code of the first key in the keyboard buffer. The 
   key is removed from the buffer. If no key is present, GetKey waits for 
   it.
   For extended keys (returning two characters), the extended code is 
   returned in the first byte, and the regular code is returned in the 
   second byte (the third and fourth bytes always being null at least in 
   console mode).
   WARNING: In graphics mode and depending on the key pressed,   Getkey   
   may not always return the exact same value as in console mode (for a 
   non-extended key, the most significant bit of the ascii code byte may be 
   propagated to the higher 3 bytes of the return value, such as a sign 
   bit).
   For a compatible code of the 2 screen modes, see the example below.

   The key read is not echoed to the screen.

   For a keyword not stopping the program if no key is at the buffer see 
   Inkey or MultiKey.

Example
   Dim As Long foo
   Do
      foo = GetKey
      Print "total return: " & foo
      
      If( foo > 255 ) Then
         Print "extended code: " & (foo And &hff)
         Print "regular code: " & (foo Shr 8)
      Else
         Print "regular code: " & (foo And &hff)
      End If
      Print 
   Loop Until foo = 27

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Getkey.

Differences from QB
   * New to FreeBASIC

See also
   * GetMouse
   * Inkey
   * Input()
   * MultiKey



--------------------------------------------------------- KeyPgGetmouse ----
GetMouse

Retrieves the status of the mouse pointing device

Syntax
   Declare Function GetMouse ( ByRef x As Long, ByRef y As Long, ByRef 
   wheel As Long = 0, ByRef buttons As Long = 0, ByRef clip As Long = 0 ) As
   Long
   Declare Function GetMouse ( ByRef x As LongInt, ByRef y As LongInt, ByRef
   wheel As LongInt = 0, ByRef buttons As LongInt = 0, ByRef clip As LongInt
   = 0 ) As Long

Usage
   result = GetMouse (x, y [, [ wheel ] [, [ buttons ] [, [ clip ]]]])

Parameters
   x
      x coordinate value
   y
      y coordinate value
   wheel
      scroll wheel value
   buttons
      button status
   clip
      clip status

Return Value
   0 on success, or 1 on error (for example because the mouse is outside 
   the graphic window) or on failure. (sets a runtime error)

Description
   GetMouse retrieves the mouse position and buttons status; information is 
   returned in the variables passed to this function by reference. If a 
   mouse is not available, all variables will contain the -1 value. 

   If in console mode, the x and y coordinates are the character cell 
   coordinates the mouse is currently on; the upper left corner of the 
   screen is at coordinates 0, 0. If the mouse moves out of the console 
   window, GetMouse returns the last coordinate on the window that the 
   mouse was on. If in console mode and fullscreen, the scroll wheel value 
   is not returned. 

   If in graphics mode, x and y will always be returned in pixel 
   coordinates still relative to the upper left corner of the screen, which 
   is at 0,0 in this case; custom coordinates system set via View or Window 
   do not affect the coordinates returned by GetMouse.
   If the mouse runs off the graphic window, all values are set to -1 and 
   the return value of the function is set to 1. This may result in 
   misinterpretation for the buttons and wheel if the return value of the 
   function is not also tested.

   Wheel is the mouse wheel counter; rotating the wheel away from you makes 
   the count to increase, rotating the wheel toward you makes it to 
   decrease. At program startup or when a new graphics mode is set via 
   Screen, wheel position is reset to 0. FreeBASIC may not always support 
   mouse wheels for a given platform, in which case 0 is always returned.

   Buttons stores the buttons status as a bitmask: bit 0 is set if left 
   mouse button is down; bit 1 is set if right mouse button is down; bit 2 
   is set if middle mouse button / wheel is down.

   Clip stores the mouse clipping status; if 1, the mouse is currently 
   clipped to the graphics window; if 0, the mouse is not clipped.

   The error code returned by GetMouse can be checked using Err in the next 
   line. The function version of  GetMouse returns directly the error code 
   as a 32 bit Long.

   Warning: When the flag GFX_SHAPED_WINDOW is set (see ScreenRes), 
   GetMouse is only active in any colored area, ie there where color <> 
   RGBA(255, 0, 255, alpha).

Example
   Dim As Integer x, y, buttons, res 
   ' Set video mode and enter loop
   ScreenRes 640, 480, 8
   Do
      ' Get mouse x, y and buttons. Discard wheel position.
      res = GetMouse (x, y, , buttons)
      Locate 1, 1
      If res <> 0 Then '' Failure

   #ifdef __FB_DOS__
         Print "Mouse or mouse driver not available"
   #else
         Print "Mouse not available or not on window"
   #endif

      Else
         Print Using "Mouse position: ###:###  Buttons: "; x; y;
         If buttons And 1 Then Print "L";
         If buttons And 2 Then Print "R";
         If buttons And 4 Then Print "M";
         Print "   "
      End If
   Loop While Inkey = ""
   End

   'Example 2: type-union-type structure
   Type mouse
      As Integer res
      As Integer x, y, wheel, clip
      Union
         buttons As Integer
         Type
            Left:1 As Integer
            Right:1 As Integer
            middle:1 As Integer
         End Type
      End Union
   End Type
    
   Screen 11
   Dim As mouse m

   Do
      m.res = GetMouse( m.x, m.y, m.wheel, m.buttons, m.clip )
      ScreenLock
      Cls
      Print Using "res = #"; m.res
      Print Using "x = ###; y = ###; wheel = +###; clip = ##"; m.x; m.y; m.wheel; m.clip
      Print Using "buttons = ##; left = #; middle = #; right = #"; m.buttons; m.left; m.middle; m.right
      ScreenUnlock
      Sleep 10, 1
   Loop While Inkey = ""

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Getmouse.  The variables passed must also be of type Long 
     instead of Integer.

Platform Differences
   * On Win32, scroll wheel changes are not guaranteed to be detected in 
     full-screen console mode.  Confirmed on WinXP: In windowed mode, mouse 
     wheel changes are seen, but in full-screen console mode they are not.
   * In DOS, the "clip" value has no relevance.  Additionally the wheel 
     and middle button will not work unless supported and enabled by the 
     mouse driver. See also FaqDOS.

Differences from QB
   * New to FreeBASIC

See also
   * ScreenRes setting graph mode by resolution
   * Screen (Graphics) setting mode the QB-like way
   * SetMouse
   * MultiKey
   * GetJoystick
   * Event
   * ScreenEvent



------------------------------------------------------------ KeyPgGosub ----
GoSub

Control flow statement to use a section of code and return.

Syntax
   GoSub label

Description
   Execution jumps to a subroutine marked by a line label. Always use Return
   to exit a GoSub,  execution will continue  on next statement after GoSub
   . 

   The line label where GoSub jumps must be in the same main/function/sub 
   block as GoSub. All the variables in the subroutine are shared with the 
   block, no arguments can be used. For this reason Gosub is considered bad 
   programming practice as it can generate unreadable and untraceable code. 
   It is better to use Sub or Function instead.

Example
   '' Compile with -lang qb

   '$lang: "qb"

   GoSub message
   End

   message:
   Print "Welcome!"
   Return

Dialect Differences
   * Only available in the -lang qb and -lang fblite dialects.
   * GoSub support is disabled by default in the -lang fblite unless the 
     Option Gosub statement is used.

Differences from QB
   * None when using the -lang qb dialect.

See also
   * Goto
   * Return (From Gosub)
   * Sub
   * Function
   * Option Gosub
   * Labels



------------------------------------------------------------- KeyPgGoto ----
Goto

Control flow statement to jump to another part of the program

Syntax
   Goto label

Description
   Jumps code execution to a line label.

   When using Goto label to exit a scope, any local variables defined in 
   that scope are destroyed (destructors are called).

   Usage of Goto label may be disallowed when it skips a variable 
   definition but not the end of the variable's scope. If the variable 
   requires construction, a compiler error is shown. For other variables, a 
   compiler warning is shown. This is intended to prevent potential 
   accesses to uninitialized variables, and ensures that automatic 
   destruction never happens to an uninitialized variable.

   For better source code readability, overuse of Goto should be avoided in 
   favor of more modern structures such as Do...Loop, For...Next, Sub, and 
   Function.

Example
      Goto there

   backagain:
      End

   there:
      Print "Welcome!"
      Goto backagain

   '' Compile with -lang qb or fblite

   '$lang: "qb"

   1 Goto 3
   2 End
   3 Print "Welcome!"
   4 Goto 2

Dialect Differences
   * Line numbers are allowed only in the -lang qb and -lang deprecated 
     dialects.
   * In the -lang qb and -lang fblite dialects, Goto label is allowed to 
     skip any variable definitions, because nested scopes are not supported 
     and all variable definitions are moved to the top of their procedure.

Differences from QB
   * None

See also
   * GoSub
   * Sub
   * Function
   * Labels




============================================================================
    H

-------------------------------------------------------------- KeyPgHex ----
Hex

Returns the hexadecimal of the given number

Syntax
   Declare Function Hex ( ByVal number As UByte ) As String
   Declare Function Hex ( ByVal number As UShort ) As String
   Declare Function Hex ( ByVal number As ULong ) As String
   Declare Function Hex ( ByVal number As ULongInt ) As String
   Declare Function Hex ( ByVal number As Const Any Ptr ) As String

   Declare Function Hex ( ByVal number As UByte, ByVal digits As Long ) As 
   String
   Declare Function Hex ( ByVal number As UShort, ByVal digits As Long ) As 
   String
   Declare Function Hex ( ByVal number As ULong, ByVal digits As Long ) As 
   String
   Declare Function Hex ( ByVal number As ULongInt, ByVal digits As Long ) 
   As String
   Declare Function Hex ( ByVal number As Const Any Ptr, ByVal digits As 
   Long ) As String

Usage
   result = Hex[$]( number [, digits ] )

Parameters
   number
      A number or expression evaluating to a number.  A floating-point 
      number will be converted to a LongInt.
   digits
      Optional number of digits to return.

Return Value
   A String containing the unsigned hexadecimal representation of number.

Description
   Returns the unsigned hexadecimal string representation of the integer 
   number. Hexadecimal digits range from 0-9, or A-F.

   If you specify digits > 0, the result string will be exactly that 
   length.  It will be truncated or padded with zeros on the left, if 
   necessary.

   The length of the string will not go longer than the maximum number of 
   digits required for the type of number (8 for a Long, 16 for a LongInt).

   If you want to do the opposite, i.e. convert a hexadecimal string back 
   into a number, the easiest way to do it is to prepend the string with 
   "&H", and convert it to an integer type, using a function like CInt, 
   similarly to a normal numeric string.  E.g. CInt("&HFF")

Example
   '54321 is D431 in hex
   Print Hex(54321)
   Print Hex(54321, 2)
   Print Hex(54321, 5)

   will produce the output:

   D431
   31
   0D431

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * In QBASIC, there was no way to specify the number of digits returned.
   * The size of the string returned was limited to 32 bits, or 8 
     hexadecimal digits.

See also
   * Bin
   * Oct
   * ValInt
   * ValLng



----------------------------------------------------------- KeyPgHibyte ----
HiByte

Gets the second byte of the operand.

Syntax
   #define HiByte( expr ) ((Cast(UInteger, expr) And &h0000FF00) Shr 8)

Usage
   result = HiByte( expr )

Parameters
   expr
      A numeric expression, converted to an UInteger value.

Return Value
   Returns the value of the high byte of the low 16bit word of expr.

Description
   This macro converts the numeric expression expr to an UInteger value, 
   then expands to an UInteger representing the value of its second byte - 
   that is the most-significant (high) byte of the least-significant (low) 
   16bit word of expr.

Example
   Dim N As UInteger

   'Note there are 16 bits
   N = &b1010101110000001
   Print "N is                                       "; N
   Print "The binary representation of N is          "; Bin(N)
   Print "The most significant byte (MSB) of N is    "; HiByte(N)
   Print "The least significant byte (LSB) of N is   "; LoByte(N)
   Print "The binary representation of the MSB is    "; Bin(HiByte(N))
   Print "The binary representation of the LSB is    "; Bin(LoByte(N))
   Sleep

The output would look like:

   N Is                                       43905
   The Binary representation of N Is          1010101110000001
   The most significant Byte (MSB) of N Is    171
   The least significant Byte (LSB) of N Is   129
   The Binary representation of the MSB Is    10101011
   The Binary representation of the LSB Is    10000001

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __HIBYTE.

Differences from QB
   * New to FreeBASIC

See also
   * LoByte
   * LoWord
   * HiWord



----------------------------------------------------------- KeyPgHiword ----
HiWord

Gets the second 16bit word of the operand.

Syntax
   #define HiWord( expr ) ((Cast(UInteger, expr) and &hFFFF0000) Shr 16)

Usage
   result = HiWord( expr )

Parameters
   expr
      A numeric expression, converted to an UInteger value.

Return Value
   Returns the value of the high 16bit word of the low 32bit dword of expr.

Description
   This macro converts the numeric expression expr to an UInteger value, 
   then expands to an UInteger representing the value of its second 16bit 
   word - that is the most-significant (high) 16bit word of the 
   least-significant (low) 32bit dword of expr.

Example
   Dim N As UInteger

   'Note there are 32 bits
   N = &b10000000000000011111111111111111

   Print "N is                                       "; N
   Print "The binary representation of N is          "; Bin(N)
   Print "The most significant word (MSW) of N is    "; HiWord(N)
   Print "The least significant word (LSW) of N is   "; LoWord(N)
   Print "The binary representation of the MSW is    "; Bin(HiWord(N))
   Print "The binary representation of the LSW is    "; Bin(LoWord(N))

   Sleep

The output would look like:

   N Is                                       2147614719
   The Binary representation of N Is          10000000000000011111111111111111
   The most significant word (MSW) of N Is    32769
   The least significant word (LSW) of N Is   65535
   The Binary representation of the MSW Is    1000000000000001
   The Binary representation of the LSW Is    1111111111111111

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __HIWORD.

Differences from QB
   * New to FreeBASIC

See also
   * LoByte
   * HiByte
   * LoWord



------------------------------------------------------------- KeyPgHour ----
Hour

Gets the hour of day from a Date Serial 

Syntax
   Declare Function Hour ( ByVal date_serial As Double ) As Long

Usage
   #include "vbcompat.bi"
   result = Hour( dateserial )

Parameters
   date_serial
      the date serial

Return Value
   Returns the hour from a variable containing a date in Date Serial 
   format.

Description
   The compiler will not recognize this function unless vbcompat.bi is 
   included.

Example
   #include "vbcompat.bi"

   Dim ds As Double = DateSerial(2005, 11, 28) + TimeSerial(7, 30, 50)

   Print Format(ds, "yyyy/mm/dd hh:mm:ss "); Hour(ds)

Differences from QB
   * Did not exist in QB. This function appeared in PDS and VBDOS

See also
   * Date Serials




============================================================================
    I

----------------------------------------------------------- KeyPgIfthen ----
If...Then

Control flow statement for conditional branching

Syntax
      If expression Then [statement(s)] [Else [statement(s)]] [End If]
   or
      If expression Then : [statement(s)] [Else [statement(s)]] : End If
   or
      If expression Then
         [statement(s)]
      [ ElseIf expression Then ]
         [statement(s)]
      [ Else ]
         [statement(s)]
      End If

      Remark: EndIf (without blank) is also supported like in QB for 
      backward compatibility.

Description
   If...Then is a way to make decisions.
   It is a mechanism to execute code only if a condition is true, and can 
   provide alternative code to execute based on more conditions:
      * Execute code (just behind Then) if a condition is true.
      * Execute certain code (just behind Then) if a condition is true and 
        execute other (just behind Else) if it's false.
      * Test other conditions (with ElseIf) if the first condition is 
        false.

   expression can be one of several forms:
      * a conditional expression, for example:
         x = 5
      * multiple conditions separated by logical bit-wise operators, for 
        example:
         x >= 5 And x <= 10
      * multiple conditions separated by logical short-circuit operators, 
        for example:
         y <> 0 AndAlso x \ y = 1
         (in this case, "x \ y = 1" will only be evaluated if "y <> 0" is 
         True)
      * any numerical expression, in which case a value of zero (0) 
        represents False, and a non-zero value represents True

   Both multi-line and single-line Ifs can be nested.  In the latter case, 
   the optional End Ifs can be useful to control where nested Ifs begin and 
   end.

   The multi-line syntax allows several Elseifs (but none after a Else) and 
   tests can be nested (there must be in this case as many End Ifs as Ifs).
   If the condition of the If is not true, those of Elseifs blocks are 
   tested in succession:
      * If either of these is true, the corresponding code is executed, 
        then the program skips the following blocks to continue after the 
        End If.
      * If none are true, the code following the Else (if exists) is 
        executed alone.

   In the -lang fb and -lang fblite dialects, colons (:) can be used 
   instead of newlines to construct multi-line If blocks on a single line.

   Note: The single-line syntax If...Goto, as shortcut for If...Then Goto, 
   is deprecated and it only exists for compatibility with QB.

Example
   '' Here is a simple "compute the square root" code using a single-line if...then for the decision,
   '' but with multiple statements extended with colons (:)

   Dim As Double d , r
   r = -1
   d = 2
   'd = -3

   If d > 0 Then r = Sqr(d) : Print "square root computed:" Else r = 0 : Print "square root not computed:"
   Print r

   Sleep
      

   '' Here is a simple "guess the number" game using a multi-line if...then for a decision.

   Dim As Integer num, guess

   Randomize
   num = Int(Rnd * 10) + 1 'Create a random number between 1 and 10...
               
   Print "guess the number between 1 and 10 (or CTRL-C to abort)"

   Do 'Start a loop

      Input "Guess"; guess 'Input a number from the user

      If guess > 10 OrElse guess < 1 Then  'The user's guess is out of range
         Print "The number can't be greater then 10 or less than 1!"
      ElseIf guess > num Then  'The user's guess is too high
         Print "Too high"
      ElseIf guess < num Then  'The user's guess is too low
         Print "Too low"
      Else                     'The user guessed the right number!
         Print "Correct!"
         Exit Do   'Exit the loop
      End If

   Loop 'Go back to the start of the loop

   Sleep
      

Dialect Differences
   * In the -lang qb and -lang fblite dialects, variables declared inside 
     an If..Then block have a procedure-wide scope  as in QB 
   * In the -lang fb and -lang deprecated dialects, variables declared 
     inside an If..Then block are visible only inside the block, and cannot 
     be accessed outside it. To access duplicated symbols defined as global 
     outside this block, add one or preferably two dot(s) as prefix: .
     SomeSymbol or preferably ..SomeSymbol (or only ..SomeSymbol if inside 
     a With..End With block).
   * In the -lang qb dialect, if there is a new line or a single-line 
     comment (') directly after THEN, then the IF will be multi-line.  A 
     colon, a Rem or any other statement will result in a single-line IF.
   * In the -lang fb and -lang fblite dialects, if there is a new line, a 
     single-line comment ('), a colon (:), or a Rem statement directly 
     after THEN, then the IF will be multi-line.  Any other statement will 
     result in a single-line IF.

Differences from QB
   * END IF was not supported in single-line IFs in QBASIC.

See also
   * ElseIf
   * Do...Loop
   * #if
   * Select Case



-------------------------------------------------------------- KeyPgIif ----
IIf

Conditional function that returns one of two values.

Syntax
   IIf ( condition, expr_if_true, expr_if_false )

Parameters
   condition
      The condition to test.
      A non-zero value evaluates as true, while a value of zero evaluates 
      as false.
   expr_if_true
      An expression to evaluate and return if condition is true.
      It must return:
         * a numeric value, which can be an integer, floating point number 
           or a pointer, including Boolean,
         * or a string value,
         * or an UDT value.
   expr_if_false
      An expression to evaluate and return if condition is false.
      It must be same type as expr_if_true (either numeric, either string 
      or UDT).

Return Value
   if condition is non-zero, expr_if_true, otherwise expr_if_false

Description
   IIf returns a different numeric or string or UDT value (not a reference) 
   depending of the result of a conditional expression evaluated at 
   run-time. Its typical use is in the middle of an expression; it avoids 
   splitting it to put a conditional in the middle.

   IIf only evaluates the expression that it needs to return.  This saves 
   time, and can also be useful to prevent evaluating expressions that 
   might be invalid depending on the condition.

   When IIf treats expressions of mixed numeric types (conditional 
   expression evaluated at run-time):
      * if at least one expression is of floating-point type, the result 
        type is the floating-point type (the bigger in case of two 
        floating-point types),
      * if the two expressions are of integer types, the result type is 
        the bigger type of both (see Coercion and Conversion for the 
        precise ranking of integer types).

Example
   Dim As Integer a, b, x, y, z
   a = (x + y + IIf(b > 0, 4, 7)) \ z

is equivalent to:
   Dim As Integer a, b, x, y, z, temp
   If b > 0 Then temp = 4 Else temp = 7
   a = (x + y + temp) \ z

   Dim As Integer I
   I = -10
   Print I, IIf(I>0, "positive", IIf(I=0, "null", "negative"))
   I = 0
   Print I, IIf(I>0, "positive", IIf(I=0, "null", "negative"))
   I = 10
   Print I, IIf(I>0, "positive", IIf(I=0, "null", "negative"))
   Sleep

   Type UDT1
     Dim As Integer I1
   End Type

   Type UDT2 Extends UDT1
     Dim As Integer I2
   End Type

   Dim As UDT1 u1, u10 = (1)
   Dim As UDT2 u2, u20 = (2, 3)

   u1 = IIf(0, u10, u20)
   Print u1.I1
   u1 = IIf(1, u10, u20)
   Print u1.I1

   u2 = IIf(0 , u10, u20)
   Print u2.I1; u2.I2
   'u2 = Iif(1, u10, u20) ''Invalid assignment/conversion
   Sleep

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Iif.

Differences from QB
   * New to FreeBASIC

See also
   * If...Then



-------------------------------------------------- KeyPgImageConvertRow ----
ImageConvertRow

Converts a row of image data into another color depth

Syntax
   Declare Sub ImageConvertRow ( ByVal src As Any  Ptr, ByVal src_bpp As 
   Long, ByVal dst As Any  Ptr, ByVal dst_bpp As Long, ByVal width As Long, 
   ByVal isrgb As Long = 1 )

Usage
   ImageConvertRow( src, src_bpp, dst, dst_bpp, width [, isrgb ] )

Parameters
   src
      The address of the start of the source row.  The source can either be 
      a full-color image with a bit depth of 24 or 32 bits per pixel, or a 
      paletted image with a bit depth of 1-8 bits per pixel.  Converting a 
      paletted image will only work properly if you are in a screen mode 
      that is using the correct palette for the image when you do the 
      conversion.
   src_bpp
      The number of bits per pixel in the source row.  1-8, 24 and 32.
   dst
      The address of the start of the destination row.  The image can be a 
      full-color image of 16 or 32 bits per pixel.  If the source is a 
      paletted image, the destination can also be a paletted image of 1 to 
      8 bits per pixel.
   dst_bpp
      The number of bits per pixel in the destination row.  Valid values 
      for this are 1-8, 16 and 32.
   width
      The length of the row in pixels.
   isrgb
      A value of zero indicates that the Red and Blue channels are the 
      other way round in the source image.  Use this switch if you want the 
      Red and Blue channels to be swapped in the conversion.

Description
   Copies the row of an image from one memory location to another, 
   converting the color information in each pixel to match the destination 
   image.

Example
   #include "fbgfx.bi"
   #if __FB_LANG__ = "fb"
   Using FB
   #endif

   Const As Integer w = 64, h = 64
   Dim As IMAGE Ptr img8, img32
   Dim As Integer x, y

   '' create a 32-bit image, size w*h:
   ScreenRes 1, 1, 32, , GFX_NULL
   img32 = ImageCreate(w, h)

   If img32 = 0 Then Print "Imagecreate failed on img32!": Sleep: End

   '' create an 8-bit image, size w*h:
   ScreenRes 1, 1, 8, , GFX_NULL
   img8 = ImageCreate(w, h)

   If img8 = 0 Then Print "Imagecreate failed on img8!": Sleep: End

   '' fill 8-bit image with a pattern
   For y = 0 To h - 1
      For x = 0 To w - 1
         PSet img8, (x, y), 56 + (x + y) Mod 24
      Next x
   Next y

   '' open a graphics window in 8-bit mode, and PUT the image into it:
   ScreenRes 320, 200, 8
   WindowTitle "8-bit color mode"
   Put (10, 10), img8

   Sleep

   '' copy the image data into a 32-bit image
   Dim As Byte Ptr p8, p32
   Dim As Long pitch8, pitch32

   #ifndef ImageInfo '' older versions of FB don't have the ImageInfo feature
   #define GETPITCH(img_) IIf(img_->Type=PUT_HEADER_NEW,img_->pitch,img_->old.width*img_->old.bpp)
   #define GETP(img_) CPtr(Byte Ptr,img_)+IIf(img_->Type=PUT_HEADER_NEW,SizeOf(PUT_HEADER),SizeOf(_OLD_HEADER))
   pitch8 = GETPITCH(img8): p8 = GETP(img8)
   pitch32 = GETPITCH(img32): p32 = GETP(img32)
   #else
   ImageInfo( img8,  , , , pitch8,  p8  )
   ImageInfo( img32, , , , pitch32, p32 )
   #endif

   For y = 0 To h - 1
      ImageConvertRow(@p8 [ y * pitch8 ],  8, _
                  @p32[ y * pitch32], 32, _
                  w)
   Next y

   '' open a graphics window in 32-bit mode and PUT the image into it:
   ScreenRes 320, 200, 32
   WindowTitle "32-bit color mode"
   Put (10, 10), img32

   Sleep

   '' free the images from memory:
   ImageDestroy img8
   ImageDestroy img32

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __ImageConvertRow.

Differences from QB
   * New to FreeBASIC

See also
   * ScreenRes
   * Get (Graphics)
   * Put (Graphics)
   * ImageCreate
   * ImageDestroy
   * ImageInfo



------------------------------------------------------ KeyPgImagecreate ----
ImageCreate

Allocates and initializes storage for an image

Syntax
   Declare Function ImageCreate ( ByVal width As Long, ByVal height As Long
   , ByVal color As ULong = transparent_color ) As Any Ptr
   Declare Function ImageCreate ( ByVal width As Long, ByVal height As Long
   , ByVal color As ULong = transparent_color, ByVal depth As Long ) As Any 
   Ptr

Usage
   result = ImageCreate( width, height [, [ color ][, depth ]] )

Parameters
   width
      The desired width, in number of pixels.
   height
      The desired height, in number of pixels.
   color
      The pixel value to fill the area of the image.
   depth
      The desired color depth, in bits per pixel.

Return Value
   If the image could not be created, NULL (0) is returned, otherwise, the 
   address of the image is returned. ImageCreate must be called after 
   graphic mode initialization, else it returns 0.

   Consequently, in case of Shared variable declaration, ImageCreate cannot 
   be used as integrated initializer, even inside an Udt (in member field 
   or constructor), because the initialization value (of shared variable) 
   is set at the start of the program before any user code is run. The 
   image allocation call must be in a separated executable instruction, and 
   after the graphic mode initialization.

Description
   Both procedures attempt to allocate memory for an image of the specified 
   width and height. If not successful, NULL (0) is returned. Otherwise, an 
   image of that size is created and initialized by filling the entire area 
   of pixels with the value color. If not specified, color assumes the 
   value of the transparent color for the current graphics screen, which 
   can be found by calling ScreenControl. In any case, the address of the 
   image is returned, which is then controlled by the user, and must be 
   destroyed using ImageDestroy.

   The first procedure creates an image with a color depth matching that of 
   the current graphics screen, which can be found by calling ScreenControl
   . The second procedure creates an image with a color depth of depth, in 
   bits per pixel. For both procedures, the resulting image can be used in 
   drawing procedures while in any screen mode -- and across mode changes 
   -- as long as the color depth of the image matches that of the graphics 
   screen.

   ImageCreate is the recommended way to allocate memory for new images. 
   The memory layout -- size, structure, etc. -- while documented, may 
   change from version to version, making manual calculation of the sizes 
   involved error-prone. However, ImageInfo can be used to retrieve, among 
   other things, the size, in bytes, of an existing image, allowing memory 
   to be manually allocated for a copy of an image, or to be read from or 
   written to a file or device.

   Get (Graphics) can be used to initialize an image using pre-allocated 
   memory.

Example
   '' Create a graphics screen.
   ScreenRes 320, 200, 32

   '' Create a 64x64 pixel image with a darkish green background.
   Dim image As Any Ptr = ImageCreate( 64, 64, RGB(0, 128, 0) )

   If image = 0 Then
      Print "Failed to create image."
      Sleep
      End -1
   End If

   '' Draw a semi-transparent, red circle in the center of the image.
   Circle image, (32, 32), 28, RGBA(255, 0, 0, 128),,, 1.0, f

   '' Draw the image onto the screen using various blitting methods.
   Put (120, 60), image, PSet
   Put (140, 80), image, Alpha

   '' Destroy the image.
   ImageDestroy image

   Sleep

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Imagecreate.

Differences from QB
   * New to FreeBASIC

See also
   * ImageDestroy
   * ImageInfo
   * Get (Graphics)
   * Internal pixel formats



----------------------------------------------------- KeyPgImageDestroy ----
ImageDestroy

Destroys and deallocates storage for an image

Syntax
   Declare Sub ImageDestroy ( ByVal image As Any Ptr )

Usage
   ImageDestroy( image )

Parameters
   image
      The address of the image to destroy.

Description
   Destroys the image pointed to by image, which must be an address 
   returned from a call to ImageCreate.

   Calling ImageDestroy on a null pointer induces no action.

Example
   See ImageCreate for an example on using ImageDestroy.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Imagedestroy.

Differences from QB
   * New to FreeBASIC

See also
   * ImageCreate



-------------------------------------------------------- KeyPgImageInfo ----
ImageInfo

Retrieves information about an image

Syntax
   Declare Function ImageInfo ( ByVal image As Const Any Ptr, ByRef width As
   Long = 0, ByRef height As Long = 0, ByRef bypp As Long = 0, ByRef pitch 
   As Long = 0, ByRef pixdata As Any Ptr = 0, ByRef size As LongInt = 0 ) As
   Long
   Declare Function ImageInfo ( ByVal image As Const Any Ptr, ByRef width As
   LongInt, ByRef height As LongInt, ByRef bypp As LongInt = 0, ByRef pitch 
   As LongInt = 0, ByRef pixdata As Any Ptr = 0, ByRef size As LongInt = 0 
   ) As Long

Usage
   in the LONG (or INTEGER<32>) version of the function:
      result = ImageInfo( image [, [ width ] [, [ height ] [, [ bypp ] [, [ 
      pitch ] [ , [ pixdata ] [, size ]]]]]] )
   in the LONGINT (or INTEGER<64>) version of the function:
      result = ImageInfo( image , width , height [, [ bypp ] [, [ pitch ] [ 
      , [ pixdata ] [, size ]]]] )

Parameters
   image
      The address of the image.
   width
      Stores the width of the image, in pixels.
   height
      Stores the height of the image, in pixels.
   bypp
      Stores the bytes per pixel of the image - i.e. the size of a single 
      pixel, in bytes.
   pitch
      Stores the pitch of the image - i.e. the size of each scanline (row), 
      in bytes.  Note that this may be more than just width * bypp, because 
      the scanlines may be padded to allow them to be aligned better in 
      memory.
   pixdata
      Stores the address of the start of the first scanline of the image.
   size
      Stores the size of the image in memory, in bytes.

Return Value
   If image doesn't point to a valid image, one (1) is returned. Otherwise, 
   width, height, bypp, pitch, pixdata and size are assigned appropriate 
   values, and zero (0) is returned.

Description
   ImageInfo provides various information about an image, such as its 
   dimensions and color depth, but also provides you with the information 
   you need to directly access all the pixel data in the pixel buffer.

   It can also provide the size of the image in memory, which is useful for 
   allocating memory to copy the existing image, or to write the image to a 
   file.

   ImageInfo is an alternative way to access the main characteristics of an 
   image, rather than directly accessing the internal FB.IMAGE structure 
   (defined in fbgfx.bi) through a typed pointer to member data.

   The error code returned by ImageInfo can be checked using Err in the 
   next line. The function version of  ImageInfo returns directly the error 
   code as a 32 bit Long.

Example
   '' pixelptr(): use imageinfo() to find the pointer to a pixel in the image
   '' returns null on error or x,y out of bounds
   Function pixelptr(ByVal img As Any Ptr, ByVal x As Integer, ByVal y As Integer) As Any Ptr

      Dim As Integer w, h, bypp, pitch
      Dim As Any Ptr pixdata
      Dim As Integer success
      
      success = (ImageInfo(img, w, h, bypp, pitch, pixdata) = 0)
      
      If success Then
         If x < 0 Or x >= w Then Return 0
         If y < 0 Or y >= h Then Return 0
         Return pixdata + y * pitch + x * bypp
      Else
         Return 0
      End If
      
   End Function

   '' usage example:

   '' 320*200 graphics screen, 8 bits per pixel
   ScreenRes 320, 200, 8

   Dim As Any Ptr ip '' image pointer

   Dim As Byte Ptr pp '' pixel pointer (use byte for 8 bits per pixel)

   ip = ImageCreate(32, 32) '' create an image (32*32, 8 bits per pixel)

   If ip <> 0 Then

      '' draw a pattern on the image
      For y As Integer = 0 To 31

         For x As Integer = y - 5 To y + 5 Step 5

            '' find the pointer to pixel at x,y position
            '' note: this is inefficient to do for every pixel!
            pp = pixelptr(ip, x, y)

            '' if success, plot a value at the pixel
            If (pp <> 0) Then *pp = 15

         Next x

      Next y

      '' put the image and draw a border around it
      Put (10, 10), ip, PSet
      Line (9, 9)-Step(33, 33), 4, b

      '' destroy the image to reclaim memory
      ImageDestroy ip

   Else
      Print "Error creating image!"
   End If

   Sleep
      

   '' Create 32-bit graphics screen and image.
   ScreenRes 320, 200, 32
   Dim image As Any Ptr = ImageCreate( 64, 64 )

   Dim pitch As Long
   Dim pixels As Any Ptr

   '' Get enough information to iterate through the pixel data.
   If 0 <> ImageInfo( image, ,,, pitch, pixels ) Then
      Print "unable to retrieve image information."
      Sleep
      End
   End If

   '' Draw a pattern on the image by directly manipulating pixel memory.
   For y As Integer = 0 To 63
      Dim row As ULong Ptr = pixels + y * pitch
      
      For x As Integer = 0 To 63
         row[x] = RGB(x * 4, y * 4, (x Xor y) * 4)
      Next x
   Next y

   '' Draw the image onto the screen.
   Put (10, 10), image

   ImageDestroy( image )

   Sleep
      

Version
   * Before fbc 1.08.0:
         Syntax:
            Declare Function ImageInfo ( ByVal image As Any Ptr, ByRef 
            width As Integer = 0, ByRef height As Integer = 0, ByRef bypp As
            Integer = 0, ByRef pitch As Integer = 0, ByRef pixdata As Any 
            Ptr = 0, ByRef size As Integer = 0 ) As Long
         Usage:
            result = ImageInfo( image [, [ width ] [, [ height ] [, [ bypp 
            ] [, [ pitch ] [, [ pixdata ] [, size ]]]]]] )

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Imageinfo.

Differences from QB
   * New to FreeBASIC

See also
   * ImageCreate
   * ImageDestroy
   * ImageConvertRow
   * Get (Graphics)
   * Put (Graphics)
   * Internal pixel formats



------------------------------------------------------------ KeyPgOpImp ----
Operator Imp (Implication)

Returns the bitwise-and (implication) of two numeric values

Syntax
   Declare Operator Imp ( ByRef lhs As T1, ByRef rhs As T2 ) As Ret

Usage
   result = lhs Imp rhs

Parameters
   lhs
      The left-hand side expression.
   T1
      Any numeric or boolean type.
   rhs
      The right-hand side expression.
   T2
      Any numeric or boolean type.
   Ret
      A numeric or boolean type (varies with T1 and T2).

Return Value
   Returns the bitwise-implication of the two operands.

Description
   This operator returns the bitwise-implication of its operands, a logical 
   operation that results in a value with bits set depending on the bits of 
   the operands (for conversion of a boolean to an integer, false or true 
   boolean value becomes 0 or -1 integer value).

   The truth table below demonstrates all combinations of a 
   boolean-implication operation:

      +-------+-------+------+
      |Lhs Bit|Rhs Bit|Result|
      |0      |0      |1     |
      |1      |0      |0     |
      |0      |1      |1     |
      |1      |1      |1     |
      +-------+-------+------+

   No short-circuiting is performed - both expressions are always 
   evaluated.

   The return type depends on the types of values passed. Byte, UByte and 
   floating-point type values are first converted to Integer. If the left 
   and right-hand side types differ only in signedness, then the return 
   type is the same as the left-hand side type (T1), otherwise, the larger 
   of the two types is returned. Only if the left and right-hand side types 
   are both Boolean, the return type is also Boolean.

   This operator can be overloaded for user-defined types.

Example
   Dim As UByte a, b, c
   a = &b00001111
   b = &b01010101
   c = a Imp b '' c = &b11110101

Dialect Differences
   * In the -lang qb dialect, this operator cannot be overloaded.

Differences from QB
   * None

See also
   * Operator Truth Tables



------------------------------------------------------- KeyPgImplements ----
Implements

Specifies an interface to be implemented by a user-defined type
   Note: Stub page. Even though this keyword is reserved already, 
   interfaces are not implemented yet.

Syntax
   Type typename Implements interface
      ...
   End Type

Description

Example

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Implements.

Differences from QB
   * New to FreeBASIC

See also
   * Type
   * Extends
   * Extends Zstring
   * Extends Wstring



----------------------------------------------------------- KeyPgImport ----
Import

External linkage attribute for public data located in DLL's

Syntax
   Extern Import symbolname[( subscripts)] [ Alias "aliasname"] [ As 
   DataType] [, ...]

Description
   Is used only (with the Extern keyword) in external modules to access 
   global variables from Win32 DLLs: the variable names will be added to 
   the dynamic library import list so that their addresses can be fixed at 
   run-time.
   This is due to the level of indirection on any such access: an implicit 
   pointer dereference.

Example

   /* mydll.c :
   	compile With
   	  gcc -Shared -Wl,--strip-all -o mydll.dll mydll.c
   */
   __declspec( dllexport ) Int MyDll_Data = 0x1234;

   /'  import.bas :
   	Compile with
   	  fbc import.bas
   '/
   #inclib "mydll"

   Extern Import MyDll_Data Alias "MyDll_Data" As Integer

   Print "&h" + Hex( MyDll_Data )

   ' Output:
   ' &h1234

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Import.

Differences from QB
   * New to FreeBASIC

See also
   * Extern



------------------------------------------------------------ KeyPgInkey ----
Inkey

Returns a string representing the first key waiting in the keyboard buffer

Syntax
   Declare Function Inkey ( ) As String

Usage
   result = Inkey[$]

Return Value
   The first character found in the keyboard buffer, or an empty string (""
   ) if none found.

Description
   Peeks into the keyboard buffer and returns a String representation of 
   the first character, if any, found. The key is then removed from the 
   buffer, and is not echoed to the screen. If the keyboard buffer is 
   empty, an empty string ("") is immediately returned without waiting for 
   keys.

   If the key is in the ASCII character set, a one-character String 
   consisting of that character is returned. If the key is an "extended" 
   one (numeric pad, cursors, functions) a two-character String is 
   returned, the first of which is the extended character  (See dialect 
   differences below)

   The Shift, Ctrl, Alt, and AltGr keys can't be read independently by this 
   function as they never enter the keyboard buffer (although, perhaps 
   obviously, Shift-A will be reported by Inkey differently than Control-A 
   et cetera; Alt-A is an extended key a la the above).

   See also Input() or GetKey, or Sleep to wait for a key press if the 
   keyboard buffer is empty.

Example
   Print "press q to quit"
   Do
      Sleep 1, 1
   Loop Until Inkey = "q"

   '' Compile with -lang fblite or qb

   #lang "fblite"

   #if __FB_LANG__ = "qb"
   #define EXTCHAR Chr$(0)
   #else
   #define EXTCHAR Chr(255)
   #endif

   Dim k As String

   Print "Press a key, or Escape to end"
   Do

      k = Inkey$

      Select Case k

         Case "A" To "Z", "a" To "z": Print "Letter: " & k
         Case "1" To "9":             Print "Number: " & k

         Case Chr$(32): Print "Space"

         Case Chr$(27): Print "Escape"

         Case Chr$(9): Print "Tab"

         Case Chr$(8): Print "Backspace"

         Case Chr$(32) To Chr$(127)
            Print "Printable character: " & k

         Case EXTCHAR & "G": Print "Up Left / Home"
         Case EXTCHAR & "H": Print "Up"
         Case EXTCHAR & "I": Print "Up Right / PgUp"

         Case EXTCHAR & "K": Print "Left"
         Case EXTCHAR & "L": Print "Center"
         Case EXTCHAR & "M": Print "Right"

         Case EXTCHAR & "O": Print "Down Left / End"
         Case EXTCHAR & "P": Print "Down"
         Case EXTCHAR & "Q": Print "Down Right / PgDn"

         Case EXTCHAR & "R": Print "Insert"
         Case EXTCHAR & "S": Print "Delete"

         Case EXTCHAR & "k": Print "Close window / Alt-F4"

         Case EXTCHAR & Chr$(59) To EXTCHAR & Chr$(68)
            Print "Function key: F" & Asc(k, 2) - 58

         Case EXTCHAR & Chr$(133) To EXTCHAR & Chr$(134)
            Print "Function key: F" & Asc(k, 2) - 122

         Case Else
            If Len(k) = 2 Then
               Print Using "Extended character: chr$(###, ###)"; Asc(k, 1); Asc(k, 2)
            ElseIf Len(k) = 1 Then
               Print Using "Character chr$(###)"; Asc(k)
            End If

      End Select

      If k = Chr$(27) Then Exit Do

      Sleep 1, 1

   Loop

Dialect Differences
   * The extended character is Chr(255) in the -lang fb and -lang fblite 
     dialects.
      * In the -lang qb dialect, the extended character depends on how the 
        keyword is written. If the QB form Inkey$ is used, the extended 
        character is Chr(0).  If it is referenced as __Inkey, the extended 
        char is Chr(255).
      * In all other dialects, the extended char is always Chr(255).
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * None in the -lang qb dialect.
   * QBasic returned a Chr(0) as the first character for an extended key, 
     but FreeBASIC returns Chr(255) as the first character in the -lang fb 
     and -lang fblite dialects.

See also
   * Sleep
   * GetKey
   * Input()
   * MultiKey



-------------------------------------------------------------- KeyPgInp ----
Inp

Returns a value at a hardware port.

Syntax
   Declare Function Inp ( ByVal port As UShort ) As Integer

Usage
   value = Inp(port)

Parameters
   port
      Port number to read.

Return Value
   The value at the specified port.

Description
   This function retrieves the value at 'port' and returns immediately.

Example
   '' Turn off PC speaker
   Out &h61,Inp(&h61) And &hfc

	

Platform Differences
   * In the Windows and Linux versions three port numbers (&H3C7, &H3C8, 
     &H3C9) are hooked by the graphics library when a graphics mode is in 
     use to emulate QB's VGA palette handling. This use is deprecated; use 
     Palette to retrieve and set palette colors.

   * Using true port access in the Windows version requires the program to 
     install a device driver for the present session. For that reason, 
     Windows executables using hardware port access should be run with 
     administrator permits each time the computer is restarted. Further 
     runs don't require admin rights as they just use the already installed 
     driver. The driver is only 3K in size and is embedded in the 
     executable.

See also
   * Out
   * Wait
   * Palette

   


------------------------------------------------------------ KeyPgInput ----
Input

Reads a list of values from the keyboard

Syntax
   Input [;] ["prompt" ,|; ] variable_list

Parameters
   prompt
      an optional string literal that is written to the screen as a prompt. 
      If it is followed by a semicolon (;), a question mark ("? ") will be 
      appended to the prompt.  If it is followed by a comma, nothing will 
      be appended.
   variable_list
      a list of comma-separated variables used to hold the values read from 
      the user.

Description
   Reads a list values from the keyboard up until the first carriage 
   return. Numerical values are converted from their string representation 
   into the corresponding types in the variable list. Characters are echoed 
   to the screen as they are typed.

   If there is more than one value in the input list, then the input line 
   will be split up by scanning for delimiters - commas (,) after strings, 
   or commas and whitespace after numbers.  Surrounding whitespace will be 
   trimmed from string values. If an input string has a comma in it, it 
   must be wrapped in quotes ("...") to prevent it being split up.
   For inputting to a single string without delimiting, Line Input should 
   be used instead.

   The prompt - if any - is written to the screen at the current cursor 
   location, and characters read are echoed to the screen immediately 
   following the prompt. If no prompt is specified, characters are echoed 
   at the current cursor location.

   The optional leading semicolon (;) after Input is similar to the 
   optional trailing semicolon in a Print statement: the cursor will remain 
   on the same line after all of the characters have been echoed, 
   otherwise, the cursor will move to the beginning of the next line.

   If more values are read than are listed in the variable list, extra 
   values will be ignored; if fewer values are read (i.e. the user presses 
   enter before inputting all values), the remaining variables will be 
   initialized (numeric variables to zero (0), and string variables to the 
   empty string ("")).

   Numeric values are converted using methods similar to the procedures Val 
   and ValLng, using the most appropriate function for the number format, 
   converting as many numeric characters as possible.

   Input has a limited edit capacity: it allows to use the left and right 
   cursor keys to navigate the text, and to erase or insert characters.  If 
   a better user interface is needed, a custom input routine should be 
   used.

Example

   Example #1
   Dim user_name As String, user_age As Integer

   Input "Enter your name and age, separated by a comma: ", user_name, user_age

   Print "Your name is " & user_name & ", and you are " & user_age & " years old."

   Example #2
   Dim As Double a, b
   Dim As String yn

   Do
      
      Input   "Please enter a number: ", a
      Input ; "And another: ", b
      Print , "Thank you"
      Sleep 500
      Print
      Print "The total is "; a + b
      Print
      
      Do
         Input "Would you like to enter some more numbers"; yn
         yn = LCase(yn)
      Loop Until yn = "y" Or yn = "n"
      
   Loop While LCase(yn) = "y"

Differences from QB
   * If the user inputs the wrong number of values, or if it expects a 
     number for a value and gets a string that is not a valid number, then 
     QBASIC issues the message "Redo from start", and does not continue 
     further until it receives a valid input.
   * QB does not treat space as a delimiter when inputting a number from 
     the console.

See also
   * Input #
   * Input()
   * Line Input



---------------------------------------------------- KeyPgInputfilemode ----
Input (File Mode)

Specifies text file to be opened for input mode

Syntax
   Open filename for Input [Encoding encoding_type] [Lock lock_type] as [#]
   filenum 

Parameters
   filename
      file name to open for input
   encoding_type
      indicates encoding type for the file
   lock_type
      locking to be used while the file is open
   filenum
      unused file number to associate with the open file

Description
   A file mode used with Open to open a text file for reading.

   This mode allows to read sequentially lines of text with Line Input #, 
   or to read comma separated values with Input #. 

   Text files can't be simultaneously read and written in FreeBASIC, so if 
   both functions are required on the same file, it must be opened twice.

   filename must be a string expression resulting in a legal file name in 
   the target OS, without wildcards. The file will be sought for in the 
   present directory, unless the filename contains a path . If the file 
   does not exist, an error is issued. The pointer is set at the first 
   character of the file.

   Encoding_type indicates the Unicode Encoding of the file, so characters 
   are correctly read. If omitted, "ascii" encoding is defaulted. Only 
   little endian character encodings are supported at the moment. 
      *"utf8", 
      *"utf16" 
      *"utf32" 
      *"ascii" (the default)

   Lock_type indicates the way the file is locked  for other processes, it 
   is one of:
      * Read - the file can be opened simultaneously by other processes, 
        but not for reading
      * Write - the file can be opened simultaneously by other processes, 
        but not for writing
      * Read Write - the file cannot be opened simultaneously by other 
        processes (the default)

   filenum is a valid FreeBASIC file number (in the range 1..255) not being 
   used for any other file presently open. The file number identifies the 
   file for the rest of file operations. A free file number can be found 
   using the FreeFile function.

Example
   Dim ff As UByte
   Dim randomvar As Integer
   Dim name_str As String
   Dim age As Integer

   '' collect the test data and output to file with Write #
   Input "What is your name? ", name_str
   Input "What is your age? ", age
   Randomize
   Print

   ff = FreeFile
   Open "testfile" For Output As #ff
   Write #ff, Int(Rnd*42), name_str, age
   Close #ff

   '' clear variables
   randomvar = 0
   name_str = ""
   age = 0

   '' input the variables, using Input #
   ff = FreeFile
   Open "testfile" For Input As #ff
   Input #ff, randomvar, name_str, age
   Close #ff

   Print "Random Number was: " & randomvar
   Print "Your name is: " & name_str
   Print "Your age is: " & age

   'File outputted by this sample will look something like this
   '(not including the leading comment marker):
   '23,"Your Name",19

Differences from QB

See also
   * Input (Console I/O)
   * Input #
   * Input()
   * Append
   * Open
   * Output



---------------------------------------------------------- KeyPgInputPp ----
Input #

Reads a list of values from a text file

Syntax
   Input # filenum, variable_list

Parameters
   filenum
      a file number of a file or device opened for Input
   variable_list
      a list of variables used to hold the values read

Description
   Reads from a text file through a bound file number a delimiter-separated 
   set of values and writes them in reading order into the variables in 
   variable_list. If a variable is numeric the read value is converted from 
   its string representation into the corresponding type.

   Numeric values are converted in a similar way to the procedures Val and 
   ValLng, using the most appropriate function for the number format.

   Delimiters may be commas or line breaks. Whitespace is also treated as a 
   separator after numbers. A string including a comma or a whitespace must 
   be surrounded by double quotes. 

   To read an entire line into a string, use Line Input instead.

   Write # can be used to create a file readable with Input #.

Example
   Dim a As Integer
   Dim b As String
   Dim c As Single

   Open "myfile.txt" For Output As #1
   Write #1, 1, "Hello, World", 34.5
   Close #1

   Open "myfile.txt" For Input As #1
   Input #1, a, b, c
   Close #1
   Print a, b, c

Differences from QB
   * QB has a bug in INPUT # that causes it to read past the end of the 
     line if it does not find a matching end-quote when reading a string. 
     If you are porting QB code that relies upon this bug, you may need to 
     edit your data files to remove newlines from inside quoted strings, or 
     to use a custom function to piece back together the multiline string.

See also
   * Input
   * Input()
   * Line Input #
   * Write #
   * Open
   * Input (File Mode)



--------------------------------------------------------- KeyPgInputnum ----
Input()

Reads a number of characters from console or file

Syntax
   Declare Function Input ( n As Integer ) As String
   Declare Function Input ( n As Integer, filenum As Integer ) As String

Usage
   result = Input[$]( n [, [#]filenum ] )

Parameters
   n
      Number of bytes to read.
   filenum
      File number of a bound file or device.

Return Value
   Returns a String of the characters read.

Description
   Reads a number of characters from the console, or a bound file/device 
   specified by filenum.

   The first version waits for and reads n characters from the keyboard 
   buffer. Extended keys are not read. The characters are not echoed to the 
   screen.

   The second version waits for and reads n characters from a file or 
   device. The file position is updated.

Example
   Print "Select a color by number" 
   Print "1. blue"
   Print "2. red"
   Print "3. green"
   Dim choice As String
   Do
      choice = Input(1)
   Loop Until choice >= "1" And choice <= "3"

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * None in the -lang qb dialect.

See also
   * Winput()
   * GetKey
   * Inkey



------------------------------------------------------------ KeyPgInstr ----
InStr

Locates the first occurrence of a substring or character within a string

Syntax
   Declare Function InStr ( ByRef str As Const String,  [ Any ] ByRef 
   substring As Const String ) As Integer
   Declare Function InStr ( ByRef str As Const WString, [ Any ] ByRef 
   substring As Const WString ) As Integer
   Declare Function InStr ( ByVal start As Integer, ByRef str As Const 
   String, [ Any ] ByRef substring As Const String ) As Integer
   Declare Function InStr ( ByVal start As Integer, ByRef str As Const 
   WString, [ Any ] ByRef substring As Const WString ) As Integer

Usage
   first = InStr( [ start, ] str, [ Any ] substring )

Parameters
   str
      The string to be searched.
   substring
      The substring to find.
   start
      The position in str at which the search will begin. The first 
      character starts at position 1.

Return Value
   The position of the first occurrence of substring in str.

Description
   Locates the position of the first occurrence of a substring or character 
   within a string. In the first form of InStr (without start parameter), 
   the search begins at the first character.

   Zero (0) is returned if: either substring is not found, either str or 
   substring are empty strings, or start < 1.

   If the Any keyword is specified, InStr returns the first occurrence of 
   any character in substring.

Example
   ' It will return 4
   Print InStr("abcdefg", "de")

   ' It will return 0
   Print InStr("abcdefg", "h")

   ' It will search for any of the characters "f", "b", "c", and return 2 as "b" is encountered first
   Print InStr("abcdefg", Any "fbc")

   Dim test As String
   Dim idx As Integer

   test = "abababab"
   idx = InStr(test, "b")

   Do While idx > 0 'if not found loop will be skipped
      Print """b"" at " & idx
      idx = InStr(idx + 1, Test, "b")
   Loop

'A Unicode example:
dim text as wstring*20
text = "&#1055;&#1088;&#1080;&#1074;&#1077;&#1090;, &#1084;&#1080;&#1088;!"
print instr(text,"&#1077;&#1090;") ' displays 5

Platform Differences
   * The wide-character string version of InStr is not supported for DOS 
     target.

Differences from QB
   * QB returns start if search is a zero length string.
   * QB does not support Unicode.

See also
   * InStrRev
   * Mid (Function)



--------------------------------------------------------- KeyPgInstrrev ----
InStrRev

Locates the last occurrence of a substring or character within a string

Syntax
   Declare Function InStrRev ( ByRef str As Const String, [ Any ] ByRef 
   substring As Const String, ByVal start As Integer = -1 ) As Integer
   Declare Function InStrRev ( ByRef str As Const WString, [ Any ] ByRef 
   substring As Const WString, ByVal start As Integer = -1 ) As Integer

Usage
   last = InStrRev( str, [ Any ] substring [, start ]  )

Parameters
   str
      The string to be searched.
   substring
      The substring to find.
   start
      The position in str at which the search will begin. The first 
      character starts at position 1.

Return Value
   The position of the last occurrence of substring in str.

Description
   Locates the position of the last occurrence of a substring or character 
   within a string.  If start parameter is not given or is less than zero, 
   the search begins at the last character.

   Zero (0) is returned if:
      * substring is not found, or
      * either str or substring is an empty strings, or 
      * start is zero, or 
      * start is greater than the length of str.

   If the Any keyword is specified, InStrRev returns the last occurrence of 
   any character in substring.

Example
   ' It will return 4
   Print InStrRev("abcdefg", "de")

   ' It will return 0
   Print InStrRev("abcdefg", "h")

   Dim test As String
   Dim idx As Integer

   test = "abababab"
   idx = InStrRev(test, "b")

   Do While idx > 0 'if not found loop will be skipped
      Print """b"" at " & idx
      idx = InStrRev(Test, "b", idx - 1)
   Loop

'A Unicode example:
dim text as wstring*20
text = "&#1055;&#1088;&#1080;&#1074;&#1077;&#1090;, &#1084;&#1080;&#1088;!"
print instrrev(text,"&#1077;&#1090;") ' displays 5

Platform Differences
   * The wide-character string version of InStrRev is not supported for 
     DOS target.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Instrrev.

Differences from QB
   * New to FreeBASIC

See also
   * InStr
   * Mid (Function)



-------------------------------------------------------------- KeyPgInt ----
Int

Returns the floor of a number

Syntax
   Declare Function Int ( ByVal number As Single ) As Single
   Declare Function Int ( ByVal number As Double ) As Double
   Declare Function Int ( ByVal number As Integer ) As Integer
   Declare Function Int ( ByVal number As UInteger ) As UInteger

Usage
   result = Int( number )

Parameters
   number
      the floating-point number to round

Return Value
   Returns the floor of number, i.e. the largest integer that is less than 
   or equal to it.

Description
    Int returns the floor of number.  For example, Int(4.9) will return 4.0
   , and Int(-1.3) will return -2.0.  For integer types, the number is 
   returned unchanged.

   The Int unary Operator can be overloaded with user defined types.

Example
   Print Int(1.9)  '' will print  1
   Print Int(-1.9) '' will print -2 

Dialect Differences
   * In the -lang qb dialect, this operator cannot be overloaded.

Differences from QB
   * None

See also
   * Fix
   * CInt
   * Operator



---------------------------------------------------------- KeyPgInteger ----
Integer

Standard data type: 32-bit or 64-bit signed, same size as SizeOf(Any Ptr)

Syntax
   Dim variable As Integer
   Dim variable As Integer<bits>

Parameters
   bits
      A numeric constant expression indicating the size in bits of integer 
      desired.  The values allowed are 8, 16, 32 or 64.

Description
   Integer is the main data type FreeBASIC uses for integer math and 
   bitwise operations. It is the default type for number literals.

   In the first form Integer is a 32-bit or 64-bit signed whole-number data 
   type, depending on the target platform.

   If an explicit bit size is given (the second form), a data type is 
   provided that can hold values from -1LL Shl (bits-1) up to (1LL Shl (
   bits-1)) - 1. The selected data type is Byte for Integer<8>, Short for 
   Integer<16>, Long for Integer<32> and LongInt for Integer<64>.

Example
   #ifdef __FB_64BIT__
      Dim x As Integer = &H8000000000000000
      Dim y As Integer = &H7FFFFFFFFFFFFFFF
      Print "Integer Range = "; x; " to "; y
   #else
      Dim x As Integer = &H80000000
      Dim y As Integer = &H7FFFFFFF
      Print "Integer Range = "; x; " to "; y
   #endif

Dialect Differences
   * In the -lang fb and -lang fblite dialects, the Integer data type is 
     32-bit or 64-bit depending on target platform
   * In the -lang qb dialect, the Integer data type is 16-bit, regardless 
     of platform.

Differences from QB
   * The ability to select a bit size is new to FreeBASIC
   * The INTEGER type is always 16 bits wide in QB.

See also
   * Long
   * LongInt
   * UInteger
   * CInt
   * Table with variable types overview, limits and suffixes



--------------------------------------------------------------- KeyPgIs ----
Is

Clause in the Select Case statement block.

Syntax
   Case Is expression

Description
   Is specifies that a particular case inside a Select Case block will be 
   evaluated based on an expression including the greater than (>) or less 
   than (<) operator and a value. 

Example
   See example at Select Case.

See also
   * Select Case
   * Operator Is



------------------------------------------------------------- KeyPgOpIs ----
Operator Is (Run-Time Type Information)

Check if an object is compatible to a type derived from its compile-time 
type
(in the context of inheritance)

Syntax
   result = expression Is  typename

Parameters
   expression
      The expression to check, an object of a type that is directly or 
      indirectly derived from Object using Extends.
   typename
      The child type to check for. This type must be directly or indirectly 
      derived from the type of expression (the compile-time type of the 
      object).

Return Value
   Returns negative one (-1) if the expression is an object of real-type 
   typename or one of its base-types derived from the expression type, or 
   zero (0) if it's an object of an incompatible type.

Description
   The Is operator must be used in conjunction with inheritance in order to 
   check compatibility between objects and types from an inheritance 
   structure extending the built-in Object type.

   The Is operator is a binary operator that checks whether an object is 
   compatible to its derived types at run-time. Because Is relies on 
   Run-Time Type Information (RTTI), it can only be used with types that 
   are derived from the built-in Object type using Extends. The compiler 
   disallows using Is for checks that can be solved at compile-time.

   The Is operator is successful not only for the real-type (the "lowest"), 
   but also for its base-types, as long as they are still below the type of 
   expression (the compile-time type). In order to determine the real-type, 
   all possibilities from lowest to highest must be checked.

   Extending the built-in Object type allows to add an extra hidden vtable 
   pointer field at the top of the Type. The vtable is used to access 
   information for run-time type identification used by the Is operator.

   This operator cannot be overloaded.

Example
   Type Vehicle Extends Object
      As String Name
   End Type

   Type Car Extends Vehicle
   End Type

   Type Cabriolet Extends Car
   End Type

   Type Bike Extends Vehicle
   End Type

   Sub identify(ByVal p As Object Ptr)
      Print "Identifying:"

      '' Not a Vehicle object?
      If Not (*p Is Vehicle) Then
         Print , "unknown object"
         Return
      End If

      '' The cast is safe, because we know it's a Vehicle object
      Print , "name: " & CPtr(Vehicle Ptr, p)->Name

      If *p Is Car Then
         Print , "It's a car"
      End If

      If *p Is Cabriolet Then
         Print , "It's a cabriolet"
      End If

      If *p Is Bike Then
         Print , "It's a bike"
      End If
   End Sub

   Dim As Car ford
   ford.name = "Ford"
   identify(@ford)

   Dim As Cabriolet porsche
   porsche.name = "Porsche"
   identify(@porsche)

   Dim As Bike mountainbike
   mountainbike.name = "Mountain Bike"
   identify(@mountainbike)

   Dim As Vehicle v
   v.name = "some unknown vehicle"
   identify(@v)

   Dim As Object o
   identify(@o)

Differences from QB
   * New to FreeBASIC

See also
   * Extends
   * Extends Zstring
   * Extends Wstring
   * Object
   * Is (Select Case)
   * TypeOf
 


----------------------------------------------------------- KeyPgIsDate ----
IsDate

Tests if a string can be converted to a Date Serial

Syntax
   Declare Function IsDate ( ByRef stringdate As Const String ) As Long

Usage
   #include "vbcompat.bi"
   result = IsDate( stringdate )

Parameters
   stringdate
      the string to test

Return Value
   Returns non-zero (-1) if the date string can be converted to a 
   Date Serial, otherwise returns zero (0).

Description
   Date strings must be in the format set in the regional settings of the 
   OS to be considered valid dates.

   IsDate(Date) will return non-zero (-1) only if the regional settings 
   specify the same date format that QB used.

   The compiler will not recognize this function unless vbcompat.bi or 
   datetime.bi is included.

Example
   #include "vbcompat.bi"

   Dim s As String, d As Integer

   Do
     Print
     Print "Enter a date: "

     Line Input s

     If s = "" Then Exit Do

     If IsDate( s ) = 0 Then
      Print "'"; s; "' is not a valid date"
     Else
      d = DateValue( s )
      Print "year  = "; Year( d )
      Print "month = "; Month( d )
      Print "day   = "; Day( d )
     End If

   Loop

Differences from QB
   * New to FreeBASIC

See also
   * Date Serials
   * DateSerial
   * TimeValue
   * DateValue



----------------------------------------------------- KeyPgIsredirected ----
IsRedirected

Checks whether stdin or stdout is redirected to a file

Syntax
   Declare Function IsRedirected ( ByVal is_input As Long = 0 ) As Long

Usage
   #include "fbio.bi"
   result = IsRedirected( is_input )

Parameters
   is_input
      A Long indicating the type of information to return.

Return Value
   Returns non-zero (-1) if stdin or stdout is redirected, otherwise 
   returns zero (0).

Description
   IsRedirected checks whether stdin or stdout is redirected to a file, 
   instead of being connected to the console/terminal as usual.

   If is_input is equal to non-zero (-1), IsRedirected checks stdin.
   If is_input is equal to zero (0), IsRedirected checks stdout.

Example
   '' A Windows based example, just for the use principle
   '' Self-sufficient example, using his own .exe file as dummy input file for stdin redirection

   #include "fbio.bi"

   '' Quotation marks wrapping for compatibility with spaces in path name
   Dim As String pathExe = """" & ExePath & """"
   Dim As String fileExe = Mid(Command(0), InStrRev(Command(0), "\") + 1)
   Dim As String redirection = " < """ & Command(0)
   If LCase(Right(Command(0), 4)) = ".exe" Then
     redirection &= """"
   Else
     redirection &= ".exe"""
   End If

   If Command() = "" Then  '' First process without stdin redirection
     '' Check stdin redirection
     Print "First process without stdin redirection: IsRedirected(-1) = "; IsRedirected(-1)
     '' Creation of asynchronous second process with stdin redirected from file.exe
     Shell("start /d " & pathExe & " /b " & fileExe & redirection & " secondprocess")
     '' Waiting for termination of asynchronous second process
     Sleep
   ElseIf Command() = "secondprocess" Then  '' Second process with stdin redirection
     '' Check stdin redirection
     Print "Second process with stdin redirection  : IsRedirected(-1) = "; IsRedirected(-1)
   End If

Differences from QB
   * New to FreeBASIC.

See also
   * Reset(Streamno)




============================================================================
    K

------------------------------------------------------------- KeyPgKill ----
Kill

Deletes a file from disk / storage media.

Syntax
   Declare Function Kill ( ByRef filename As Const String ) As Long

Usage
   result = Kill( filename )

Parameters
   filename
      The filename is the name of the disk file to delete. If the file is 
      not in the current directory, the path must also be given as 
      path/file.

Return Value
   Returns zero (0) on success, or non-zero on error.

Description
   Kill deletes a file from disk / storage media.

   The error code returned by Kill can be checked using Err in the next 
   line. The function version of  Kill returns directly the error code as a 
   32 bit Long.
 
Example
   Dim filename As String = "file.ext"
   Dim result As Integer = Kill( filename )

   If result <> 0 Then Print "error trying to kill " ; filename ; " !"

Platform Differences
   On some platforms, Kill may be able to remove folders and read-only 
   files.  Whether it succeeds or fails here is not currently defined.  It 
   may be necessary to check the attributes of the file you are deleting, 
   and decide accordingly whether you want to try Killing it.

Differences from QB
   * KILL can optionally be used as function in FreeBASIC.

See also
   * Shell
   * RmDir




============================================================================
    L

----------------------------------------------------------- KeyPgLbound ----
LBound

Returns the lower bound of an array's dimension

Syntax
   Declare Function LBound ( array() As Any, ByVal dimension As Integer = 1 
   ) As Integer

Usage
   result = LBound( array [, dimension ] )

Parameters
   array
      an array of any type
   dimension
      the dimension to get lower bound of

Return Value
   Returns the lower bound of an array's dimension.
 
Description
   LBound returns the lowest value that can be used as an index into a 
   particular dimension of an array.

   Array dimensions are numbered from one (1) to n, where n is the total 
   number of dimensions. If dimension is not specified, LBound will return 
   the lower bound of the first dimension.

   If dimension is zero (0), LBound returns 1, corresponding to the lower 
   bound of the array dimensions 1..n. UBound returns n, the number of 
   dimensions, in this case. This can be used to detect the array's number 
   of dimensions.

   For any other (non-zero) dimension values outside of the valid range 1..
   n, LBound returns 0. UBound returns -1 in this case. This can be used to 
   detect whether a certain dimension exists in the array, and also works 
   when used on an empty array which does not have any valid dimensions.

   Thus, for empty dynamic arrays, we get:
      * Lbound(array) = 0 and Ubound(array) = -1 (dimension 1 does not 
        exist)
      * Lbound(array, 0) = 1 and Ubound(array, 0) = 0 (zero dimensions)
      * @array(Lbound(array)) = 0 (no data buffer allocated)

Example
   Dim array(-10 To 10, 5 To 15, 1 To 2) As Integer

   Print LBound(array) 'returns -10
   Print LBound(array, 2) 'returns 5
   Print LBound(array, 3) 'returns 1

See also
   * UBound
   * Static
   * Dim
   * ReDim



------------------------------------------------------------ KeyPgLcase ----
LCase

Returns a lower case copy of a string

Syntax
   Declare Function LCase ( ByRef str As Const String, ByVal mode As Long = 
   0 ) As String
   Declare Function LCase ( ByRef str As Const WString, ByVal mode As Long 
   = 0 ) As WString

Usage
   result = LCase[$]( str [ , mode ] )

Parameters
   str
      String to convert to lowercase.
   mode
      The conversion mode: 0 = current locale, 1 = ASCII only

Return Value
   Lowercase copy of str.

Description
   Returns a copy of str with all of the letters converted to lower case.

   If str is empty, the null string ("") is returned.

Example
   Print LCase("AbCdEfG")

Output:

   abcdefg

Platform Differences
   * The wide-character string version of LCase is not supported for DOS 
     target.

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * QB does not support Unicode.

See also
   * UCase



------------------------------------------------------------- KeyPgLeft ----
Left

Returns the leftmost substring of a string

Syntax
   Declare Function Left ( ByRef str As Const String, ByVal n As Integer ) 
   As String
   Declare Function Left ( ByRef str As Const WString, ByVal n As Integer ) 
   As WString

Usage
   result = Left[$]( str, n )

Parameters
   str
      The source string.
   n
      The number of characters to return from the source string.

Return Value
   Returns the leftmost substring from str.

Description
   Returns the leftmost n characters starting from the left (beginning) of 
   str. If str is empty, then the null string ("") is returned. If n <= 0 
   then the null string ("") is returned. If n > len(str) then the entire 
   source string is returned.

Example
   Dim text As String = "hello world"
   Print Left(text, 5)

   will produce the output:

   hello

An Unicode example:

dim text as wstring*20
text = "&#1055;&#1088;&#1080;&#1074;&#1077;&#1090;, &#1084;&#1080;&#1088;!"
print left(text, 6) 'displays "&#1055;&#1088;&#1080;&#1074;&#1077;&#1090;"

Platform Differences
   * DOS does not support the wide-character string version of Left.

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * QB does not support Unicode.

See also
   * Right
   * Mid (Function)



-------------------------------------------------------------- KeyPgLen ----
Len

Returns the length of an expression or data type

Syntax
   Declare Function Len ( ByRef expression As String ) As Integer
   Declare Function Len ( ByRef expression As ZString ) As Integer
   Declare Function Len ( ByRef expression As WString ) As Integer

   Declare Operator Len ( ByRef expression As datatype ) As datatype

   Declare Function Len ( datatype ) As Integer	

Usage
   result = Len( expression )
      or
   result = Len( DataType )

Parameters
   expression
      An expression of any type.
   datatype
      A DataType.

Return Value
   Returns the size of an expression or DataType (including the data fields 
   of a UDT) in bytes.

Description
   Len returns the length of an expression or the size of a DataType, in 
   bytes.

   In the first form, if expression is of type String, WString or ZString, 
   the length of the string in characters will be returned. If the 
   expression is of a user defined type, an Operator Len compatible with 
   that data type is called.  Otherwise, the size of the expression's data 
   type in bytes is returned.

   In the second form, if expression is ZString or WString, the size in 
   bytes of an ASCII or Unicode character is returned, respectively. If 
   datatype is String, the size of the string descriptor type is returned.

   If there is both a user defined type and a variable visible with the 
   same name in the current scope, the user defined type takes precedence 
   over the variable.  To ensure that the Len takes the variable instead of 
   the user defined type, wrap the argument to Len with parentheses to 
   force it to be seen as an expression.  For example Len((variable)).

   The Len unary Operator can be overloaded with user defined types.

Example
   Print Len("hello world") 'returns "11"
   Print Len(Integer) ' returns 4

   Type xyz
      a As Integer
      b As Integer
   End Type

   Print Len(xyz) ' returns 8
      

Version
   * Before fbc 1.08.0:
         Len was not returning the size of the data fields of a UDT.
         When a variable from a given namespace was accessed with the 
         namespace's name prefix, the argument to Len had to be wrapped 
         with parentheses to force it to be seen as an expression. For 
         example Len((namespace_name.variable)).

Dialect Differences
   * Len only allows expressions in the -lang qb dialect. 
   * Can be used with built-in types and user-defined types in the -lang fb
     and -lang fblite dialects.

Differences from QB
   * Can be used with built-in types and user-defined types in the -lang fb
     and -lang fblite dialects.
   * None in the -lang qb dialect.

See also
   * SizeOf



-------------------------------------------------------------- KeyPgLet ----
Let

Indicates the assignment operator.

Syntax
   Let variable = value
or
   Let( variable1 [, variable2 [, ... ]] ) = udt
or
   Operator typename.Let ( [ ByRef | ByVal ] rhs As datatype )
      statements
   end operator

Description
   Command intended to help the programmer to distinguish an assignment 
   statement (e.g. Let a = 1) from an equality test (e.g. If a = 1 then ...
   ).  As the compiler does not require it, it is usually omitted.

   Let can be used as a left-hand side operator to assign the members of a 
   user defined type to multiple variables. See Operator Let() (Assignment)

   Let is used with operator overloading to refer the assignment operator. 
   See Operator Let (Assignment)

Example
   '' Compile with -lang fblite or qb

   #lang "fblite"

   ' these two lines have the same effect:
   Let x = 100
   x = 100

Dialect Differences
   * The use of Let to indicate an assignment statement (Let variable = 
     expr) is not allowed in the -lang fb dialect.
   * The UDT to multi-variable Let assignment is only available in the 
     -lang fb dialect.
   * Overloading of operators is not available in the -lang qb and 
     -lang fblite dialects.

Differences from QB
   * None in the -lang fb dialect.
   * The Let operator is new to FreeBASIC.
   * The UDT to multi-variable Let assignment is new to FreeBASIC.

See also
   * Operator =[>] (Assignment)
   * Operator Let (Assignment)
   * Operator Let() (Assignment)
   * Operator



-------------------------------------------------------------- KeyPgLib ----
Lib

Specifies the library where a sub or function can be found as part of a 
declaration

Syntax
   Declare { Sub | Function } proc_name Lib "libname" [ Alias "symbol_name" 
   ] ( arguments list ) As return_type

   Extern "mangling" lib "libname"
      declarative statements
   end Extern

   Type T
      As Integer dummy
      Declare Constructor Lib "libname" [ Alias "symbol_name" ] ( arguments 
      list )
   end Type

Description
   In Sub or Function declarations, and also in class method declarations 
   (including constructors and destructors), Lib indicates the library 
   containing the function. Libraries specified in this way are linked in 
   as if #Inclib "Libname" or -l libname had been used.

   Lib can also be used with Extern ... End Extern Blocks to specifiy a Lib 
   for all declarations inside.

Example
   '' mydll.bas
   '' compile with:
   ''   fbc -dll mydll.bas

   Public Function GetValue() As Integer Export
     Function = &h1234
   End Function

   Declare Function GetValue Lib "mydll" () As Integer

   Print "GetValue = &h"; Hex(GetValue())

   ' Expected Output :
   ' GetValue = &h1234

Differences from QB
   * New to FreeBASIC

See also
   * Declare
   * #inclib



----------------------------------------------------- KeyPgLinegraphics ----
Line (Graphics)

Draws a line

Syntax
   Line [target,] [[STEP]|(x1, y1)]-[STEP] (x2, y2) [, [color][, [B|BF][, 
   style]]]
   or
   Line - (x2, y2) [, [color][, [B|BF][, style]]]

Parameters
   target
      specifies buffer to draw on
   STEP
      indicates that the starting coordinates are relative
   (x1, y1)
      starting coordinates of the line
   STEP
      indicates that ending coordinates are relative
   (x2, y2)
      ending coordinates of the line
   color
      the color attribute.
   B|BF
      specifies box or box filled mode
   style
      line style

Description
   Graphics statement that draws a straight line or a box between two 
   points. The action will take place on the current work page set via 
   ScreenSet, or onto the buffer Get/Put buffer if specified.

   Line coordinates are affected by custom coordinates system set via Window
   and View (Graphics) statements, and respect clipping rectangle set by 
   View (Graphics). If a pair of coordinates is preceded by the STEP 
   keyword, the coordinates are assumed to be relative to the last graphics 
   cursor position. If the B flag is specified, a rectangle will be drawn 
   instead of a line, with (x1,y1)-(x2,y2) as the coordinates of the 
   opposite rectangle corners. If BF is specified, a filled rectangle will 
   be drawn.

   Color denotes the color attribute, which is mode specific (see Color and 
   Screen (Graphics) for details). If omitted, the current foreground color 
   as set by the Color statement is used.

   Style, if specified, allows styled line drawing; its value is 
   interpreted as a 16-bit bitmask, and Line will use it to skip pixel 
   drawing. Starting at (x1,y1), the most significant bit of the style mask 
   is checked: if 1, the pixel is drawn, if 0, it's skipped. This repeats 
   for all the line pixels with the other bits, with the mask being reused 
   when the 16 bits are all checked.

   When Line is used as Line - (x2, y2), a line is drawn from the current 
   cursor position to the (x2,y2) coordinates specified by Line.  
   Alternatively, Point can be used to get the current cursor position.

   Note: Either chained use or boxes drawn with Line can induce pixels 
   overdrawn at some locations. Thus, the resultant (blended) color of 
   these overdrawn pixels is affected if a transparent color (in 
   conjunction with the GFX_ALPHA_PRIMITIVES option flag) is used.

Example
   '' draws a diagonal red line with a white box, and waits for 3 seconds
   Screen 13
   Line (20, 20)-(300, 180), 4
   Line (140, 80)-(180, 120), 15, b
   Line - ( 200, 200 ), 15
   Sleep 3000

   ' Draws 2 lines with 2 different line styles in 2 different colors
   ScreenRes 320, 240

   Line (10, 100)-(309, 140),  4, B, &b1010101010101010 ' red box with dashed border

   Line (20, 115)-(299, 115),  9,  , &b1111000011111111 ' blue dashed line
   Line (20, 125)-(299, 125), 10,  , &b0000000011110000 ' green dashed line

   Sleep

Differences from QB
   * target is new to FreeBASIC

See also
   * Circle
   * Window
   * View (Graphics)



-------------------------------------------------------- KeyPgLineinput ----
Line Input

Reads one line of input from the keyboard

Syntax
   Line Input [;] [promptstring {;|,} ] stringvariable

Parameters
   promptstring
      optional prompt to display before waiting for input. If it is 
      followed by a semicolon (;), a question mark ("? ") will be appended 
      to the prompt. If it is followed by a comma, nothing will be 
      appended.
   stringvariable
      variable to receive the line of text

Description
   Reads a line of text from the keyboard and stores it in a string 
   variable.

   The promptstring - if any - is written to the screen at the current 
   cursor location, and characters read are echoed to the screen 
   immediately following the prompt. If no prompt is specified, characters 
   are echoed at the current cursor location.

   The optional leading semicolon (;) after Line Input is similar to the 
   optional trailing semicolon in a Print statement: the cursor will remain 
   on the same line after all of the characters have been echoed, 
   otherwise, the cursor will move to the beginning of the next line.

   Line Input has a limited edit capacity: it allows to use the left and 
   right cursor keys to navigate the text, and to erase or insert 
   characters. If a better user interface is needed, a custom input routine 
   should be used.

Example
   Dim x As String

   Line Input "Enter a line:", x

   Print "You entered '"; x; "'"

Differences from QB
   * QBASIC only allowed literal strings for the prompt text.  FreeBASIC 
     allows any variable or constant string expression.

See also
   * Line Input #
   * Input



------------------------------------------------------ KeyPgLineinputPp ----
Line Input #

Reads one line of text from a file

Syntax
   Line Input #file number, string_variable

Parameters
   file number
      file number of an file opened for Input
   string_variable
      variable to receive the line of text

Description
   Reads a line from an open text file (opened for Input through a bound 
   file number) and stores it in a string variable.  

   A line of text ends at, but does not include the end of line characters. 
   An end of line character may be the LF character (Chr(10)) or the CRLF 
   character pair (Chr(13,10)).

Example
   Dim s As String

   Open "myfile.txt" For Output As #1
   Print #1, "Hello, World"
   Close #1

   Open "myfile.txt" For Input As #1
   Line Input #1, s
   Close #1
   Print s

Differences from QB
   * None

See also
   * Line Input
   * Input #
   * Open
   * Input (File Mode)



----------------------------------------------------------- KeyPgLoByte ----
LoByte

Gets the lowest byte of the operand.

Syntax
   #define LoByte( expr ) (Cast(UInteger, expr) And &h000000FF)

Usage
   result = LoByte( expr )

Parameters
   expr
      A numeric expression, converted to an UInteger value.

Return Value
   Returns the value of the low byte of expr.

Description
   This macro converts the numeric expression expr to an UInteger value, 
   then expands to an UInteger representing the value of its 
   least-significant (low) byte.

Example
   Dim N As UInteger

   'Note there are 16 bits
   N = &b1010101110000001
   Print "N is                                       "; N
   Print "The binary representation of N is          "; Bin(N)
   Print "The most significant byte (MSB) of N is    "; HiByte(N)
   Print "The least significant byte (LSB) of N is   "; LoByte(N)
   Print "The binary representation of the MSB is    "; Bin(HiByte(N))
   Print "The binary representation of the LSB is    "; Bin(LoByte(N))
   Sleep

The output would look like:

   N Is                                       43905
   The Binary representation of N Is          1010101110000001
   The most significant Byte (MSB) of N Is    171
   The least significant Byte (LSB) of N Is   129
   The Binary representation of the MSB Is    10101011
   The Binary representation of the LSB Is    10000001

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __LOBYTE.

Differences from QB
   * New to FreeBASIC

See also
   * HiByte
   * LoWord
   * HiWord



-------------------------------------------------------------- KeyPgLoc ----
LOC

Returns the file position where the last file read/write was performed

Syntax
   Declare Function LOC ( ByVal filenum As Long ) As LongInt

Usage
   result = LOC( filenum )

Parameters
   filenum
      The file number of an open file.

Return Value
   The file position where the last read/write was performed.

Description
   Returns the position where the last file read/write was performed.

   The position is indicated in records:
      In files opened FOR RANDOM the record length specified when file was 
      opened is used
      In  text files (FOR INPUT|OUTPUT|APPEND, a record length of 128 bytes 
      is supposed.
      In files opened for BINARY a 1 byte record length is used.

   In FreeBASIC the file position is 1 based, the first record of a file is 
   record 1 (LOC=1 after reading or writing the first record, LOC=0 for the 
   start position in the file).

   When used with a serial device, LOC returns the number of bytes waiting 
   to be read from the serial device's input buffer.

Example
   Dim b As String

   If Open Com ("com1:9600,n,8,1,cs,rs,ds,bin" For Binary As #1) <> 0 Then
     Print "unable to open serial port"
     End
   End If

   Print "Sending command: AT"

   Print #1, "AT" + Chr(13, 10);

   Sleep 500,1

   Print "Response:"

   While( LOC(1) > 0 )
     b = Input(LOC(1), 1)
     Print b;
   Wend

   Close #1

Differences from QB
   * None

See also
   * LOF
   * EOF
   * Seek (Function)
   * Open



------------------------------------------------------------ KeyPgLocal ----
Local

Error handling statement to set the current error handler

Syntax
   On Local Error Goto label

Description
   The Local clause in an On Error construction allows to define an error 
   handler in the same Sub or Function the On Local Error is in.

    Remark: Presently, the Local clause (authorized only inside 
   Sub/Function) is ignored by the compiler, and the error handler can be 
   either in the scope of the same procedure the On [Local] Error is in, or 
   in the main part of the module (if defined before the procedure).
   Exception if -gen gcc is used: when the On [Local] Error is inside a 
   Sub/Function, the error handler also must always be inside that same 
   procedure.

Example
   '' compile with -lang fblite or qb

   #lang "fblite"

   Declare Sub foo

   foo
   Print "ok"
   Sleep

   Sub foo
     Dim errno As Integer
     On Local Error Goto fail
     Open "xzxwz.zwz" For Input As #1
     On Local Error Goto 0
     Exit Sub
   fail:                  ' here starts the error handler
     errno = Err
     Print "Error "; errno      ' just print the error number
     Sleep
   End Sub

Differences from QB
   * The LOCAL clause comes from PDS 7.1. QB 4.5 does not allow local 
     error handling.

See also
   * On Error
   * Labels



----------------------------------------------------------- KeyPgLocate ----
Locate

Sets the current cursor position

Syntax
   Declare Function Locate( row As Long = 0, column As Long = 0, state As 
   Long = -1, start As Long = 0, stop As Long = 0 ) As Long

Usage
   Locate [row], [column], [state]

   result = Locate( [row], [column], [state] )
   new_column = LoByte( result )
   new_row = HiByte( result )
   new_state = HiWord( result )

Parameters
   row
      the 1-based vertical character position in the console.
   column
      the 1-based horizontal character position in the console.
   state
      the state of the cursor in console-mode only: 0 is off, 1 is on; text 
      cursor is never visible in graphics mode.
   start
      Ignored. Allowed for -lang qb dialect compatibility only.
   stop
      Ignored. Allowed for -lang qb dialect compatibility only.

Return Value
   Returns a 32 bit Long containing the current cursor position and state. 
   The Low Byte Of The Low Word contains the column, the 
   High Byte Of The Low Word contains the row, and the High Word contains 
   the cursor state.

   If any of the row, column or state parameters were just set by the call 
   to Locate, then the return value will reflect these new values, not the 
   previous ones. If any of the parameters were omitted in the call to 
   Locate, then the return value will reflect the current values, which are 
   the same as before the call to Locate.

   Locate will attempt to position the cursor at the specified row and 
   column. If the position is beyond the screen extents, cursor will not 
   reposition. And next Print to the screen will continue at last valid 
   cursor position.  When printing to the last line of the screen, and the 
   Print statement has a new line character, the screen will scroll and 
   reposition the cursor automatically to the last line, column 1.

Description
   Sets the text cursor in both graphics and console modes.

Example
   Locate 10
   Print "Current line:"; CsrLin

   '' Text cursor + mouse tracking
   Dim As Integer x = 0, y = 0, dx, dy

   Cls
   Locate , , 1

   While Inkey <> Chr(27)
      GetMouse dx, dy
      If( dx <> x Or dy <> y ) Then
         Locate y+1, x+1: Print " ";
         x = dx
         y = dy
         Locate 1, 1: Print x, y, ""
         Locate y+1, x+1: Print "X";
      End If
   Wend

Differences from QB
   * The start and stop arguments have no effect in FreeBASIC.
   * QB will raise an error if row or column are beyond the screen 
     extents.

See also
   * CsrLin
   * Pos
   * Print
   * ?



------------------------------------------------------------- KeyPgLock ----
Lock

Restricts read/write access to a file or portion of a file

Syntax
   Lock #filenum, record
   Lock #filenum, start To end

Parameters
   filenum
      The file number used to Open the file.
   record
      The record (Random files) to lock.
   start
      The first byte position (Binary files) to lock from.
   end
      The last byte position (Binary files) to lock to.

Description
   Lock temporarily restricts access by other threads or programs to a 
   file, or portion of a file, usually to allow safe writing to it.

   After modifying the data, an Unlock with the same parameters as the Lock 
   should be issued.

   Note: This command does not always work, neither as documented nor as 
   expected. It appears to be broken at the moment.

Example
   '' e.g. locking a file, reading 100 bytes, and unlocking it. 
   '' To run, make sure there exists a file called 'file.ext' 
   '' in the current directory that is at least 100 bytes.

   Dim array(1 To 100) As Integer
   Dim f As Integer, i As Integer
   f = FreeFile
   Open "file.ext" For Binary As #f
   Lock #f, 1 To 100
   For i = 1 To 100
      Get #f, i, array(i)
   Next
   Unlock #f, 1 To 100
   Close #f

Differences from QB
   * Currently, FB cannot implicitly lock the entire file
   * In Random mode, FB cannot lock a range of records

See also
   * Open
   * Unlock
   * ScreenLock



-------------------------------------------------------------- KeyPgLof ----
LOF

Returns the length of an open disk file

Syntax
   Declare Function LOF ( ByVal filenum As Long ) As LongInt

Usage
   result = LOF( filenum )

Parameters
   filenum
      The file number of an open disk file.

Return Value
   The length in bytes of an open disk file.

Description
   Returns the length, in bytes, of a file opened previously with Open 
   using the given filenum.

   With Open Com it returns the length of the data pending to be read in 
   the receive buffer.

Example
   Dim f As Integer
   f = FreeFile
   Open "file.ext" For Binary As #f
   Print LOF(f)
   Close #f

Differences from QB
   * None

See also
   * LOC
   * EOF
   * Open



-------------------------------------------------------------- KeyPgLog ----
Log

Returns the natural logarithm of a given number

Syntax
   Declare Function Log cdecl ( ByVal number As Double ) As Double

Usage
   result = Log( number )

Parameters
   number
      The number to calculate the natural log.

Return Value
   Returns the logarithm with the base e (also know as the natural 
   logarithm) of number.

Description
   There can be some confusion with this notation given that in mathematics 
   the natural logarithm function is usually denoted LN, while the 
   logarithm of base 10 is often denoted as LOG. FreeBASIC, like most 
   computer programming languages, uses LOG to denote the natural 
   logarithm. The required number argument can be any valid numeric 
   expression greater than zero. If number is zero, FreeBASIC returns a 
   special value representing "-infinity", printing like "-Inf". If number 
   is less than zero, Log returns a special value representing "not 
   defined", printing like "NaN" or "IND", exact text is platform 
   dependent. If number is an uninitialized variable, -infinity is 
   returned.

   Log can be overloaded as operator to accept user-defined types.

Example
   'Find the logarithm of any base
   Function LogBaseX (ByVal Number As Double, ByVal BaseX As Double) As Double
      LogBaseX = Log( Number ) / Log( BaseX )
      'For reference:   1/log(10)=0.43429448
   End Function

   Print "The log base 10 of 20 is:"; LogBaseX ( 20 , 10 )
   Print "The log base 2 of 16 is:"; LogBaseX ( 16 , 2 )

   Sleep

The output would look like:

   The Log Base 10 of 20 Is: 1.301029995663981
   The Log Base 2 of 16 Is: 4

Differences from QB
   * None

See also
   * Exp



------------------------------------------------------------- KeyPgLong ----
Long

Standard data type: 32-bit signed integer

Syntax
   Dim variable As Long

Description
   32-bit signed whole-number data type. Can hold values from -2147483648 
   to 2147483647. Corresponds to a signed DWORD.

Example
     Dim x As Long = &H80000000
     Dim y As Long = &H7FFFFFFF
     Print "Long Range = "; x; " to "; y

   Output:
   Long Range = -2147483648 To  2147483647

See also
   * Integer
   * LongInt
   * ULong
   * Table with variable types overview, limits and suffixes



---------------------------------------------------------- KeyPgLongint ----
LongInt

Standard data type: 64 bit signed

Syntax
   Dim variable As LongInt

Description
   A 64-bit signed whole-number data type. Can hold values from -9 223 372 
   036 854 775 808 to 9 223 372 036 854 775 807. Corresponds to a signed 
   QWORD.

Example
     Dim x As LongInt = &H8000000000000000
     Dim y As LongInt = &H7FFFFFFFFFFFFFFF
     Print "LongInt Range = "; x; " to "; y

   Output:
   LongInt Range = -9223372036854775808 To  9223372036854775807

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Longint.

Differences from QB
   * New to FreeBASIC

See also
   * ULongInt
   * CLngInt
   * Table with variable types overview, limits and suffixes



------------------------------------------------------------- KeyPgLoop ----
Loop

Control flow statement for looping.

Syntax
   Do
      [ statement block ]
   Loop [ { Until | While } condition ]

Example
   See example at Do...Loop.

See also
   * Do...Loop

   


----------------------------------------------------------- KeyPgLoWord ----
LoWord

Gets the lowest 16bit word of the operand.

Syntax
   #define LoWord( expr ) (Cast(UInteger, expr) And &h0000FFFF)

Usage
   result = LoWord( expr )

Parameters
   expr
      A numeric expression, converted to an UInteger value.

Return Value
   Returns the value of the low word of expr.

Description
   This macro converts the numeric expression expr to an UInteger value, 
   then expands to an UInteger representing the value of its 
   least-significant (low) 16bit word.

Example
   Dim N As UInteger

   'Note there are 32 bits
   N = &b10000000000000011111111111111111

   Print "N is                                       "; N
   Print "The binary representation of N is          "; Bin(N)
   Print "The most significant word (MSW) of N is    "; HiWord(N)
   Print "The least significant word (LSW) of N is   "; LoWord(N)
   Print "The binary representation of the MSW is    "; Bin(HiWord(N))
   Print "The binary representation of the LSW is    "; Bin(LoWord(N))

   Sleep

The output would look like:

   N Is                                       2147614719
   The Binary representation of N Is          10000000000000011111111111111111
   The most significant word (MSW) of N Is    32769
   The least significant word (LSW) of N Is   65535
   The Binary representation of the MSW Is    1000000000000001
   The Binary representation of the LSW Is    1111111111111111

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __LOWORD.

Differences from QB
   * New to FreeBASIC

See also
   * LoByte
   * HiByte
   * HiWord



------------------------------------------------------------- KeyPgLpos ----
LPos

Returns the number of characters sent to the printer port in the last LPrint
statement.

Syntax
   Declare Function LPos ( ByVal printer As Long ) As Long

Usage
   result = LPOS(printer)

Parameters
   printer
      Either 0, 1, 2 or 3.  Represents the printer port (LPT#)

Return Value
   Returns the number of characters sent.

Description
   Used to determine, from the last LPrint, how many characters were sent 
   to the printer port.

Example
   ' compile with -lang fblite or qb

   #lang "fblite"

   Dim test As String = "LPrint Example test"

   Print "Sending '" + test + "' to LPT1 (default)"
   LPrint test
   Print "LPT1 last recieved " + Str(LPos(1)) + " characters"
   Print "String sent was " + Str(Len(test)) + " characters long"

   Sleep

Differences from QB
   * None

See also
   * LPrint



----------------------------------------------------------- KeyPgLprint ----
LPrint

Writes text to the default printer.

Syntax
   LPrint  [ Using formatstring,] [expressionlist] [(, | ;)] ...

Parameters
   formatstring
      String specifying the output format.
   expressionlist
      List of variables to output according to the specified format.

Description
   Prints expressionlist to the printer attached to the parallel port LPT1, 
   or if it does not exist, to the default printer.  To print to a printer 
   different from the default one, use Open Lpt.

   The Using clause formats expressionlist according to formatstring.  
   Except an UDT, any data type can be passed to LPrint expressionlist, 
   expressions do not need to be first converted to strings.

   Using a comma (,) as separator or in the end of the expressionlist will 
   place the cursor in the next column (every 14 characters), using a 
   semi-colon (;) won't move the cursor. If neither of them are used in the 
   end of the expressionlist, then a new-line will be printed.

   Some printers will not print at all until a Chr(12) (End of Page) 
   character is printed.

   Internally, FreeBASIC uses the special file number -1 for printing using 
   LPrint.  This file number may be safely closed using Close -1.  The next 
   use of LPrint will automatically reopen it as needed.

Example
   '' Compile with -lang fblite or qb

   #lang "fblite"

   '' new-line
   LPrint "Hello World!"

   '' no new-line
   LPrint "Hello"; "World"; "!";

   LPrint

   '' column separator
   LPrint "Hello!", "World!"

   '' end of page
   LPrint Chr$(12)

Differences from QB
   * None

Dialect Differences
   * LPrint is not supported in the -lang fb dialect. In this dialect the 
     printer must be properly opened with Open Lpt and Print # must be used 
     to print.

See also
   * Open Lpt
   * Print
   * ?
   * Print #
   * ? #
   * Write



------------------------------------------------------------- KeyPgLset ----
LSet

Left-justifies a string

Syntax
   Declare Sub LSet ( ByRef dst As String, ByRef src As Const String )
   Declare Sub LSet ( ByVal dst As WString Ptr, ByVal src As Const WString 
   Ptr )

Usage
   LSet dst, src
   LSet dst_udt, src_udt

Parameters
   dst
      String String to receive the data.
   src
      Source String to get the data.
   dst_udt
      User defined Type to receive the data.	
   src_udt
      User defined Type to copy the data from.

Description
   LSet left justifies text into the string buffer dst, filling the left 
   part of the string with src and the right part with spaces. The string 
   buffer size is not modified.
   If text is too long for the string buffer size, LSet truncates 
   characters from the right.

   For compatibility with QBasic, LSet can also copy a user defined type 
   variable into another one. The copy is made byte for byte, without any 
   care for fields or alignment. It's up to the programmer to take care for 
   the  validity of the result.

Example
   Dim buffer As String
   buffer = Space(10)
   LSet buffer, "91.5"
   Print "-[" & buffer & "]-"

   Type mytype1
      x As Integer
      y As Integer
   End Type

   Type mytype2
      z As Integer
   End Type

   Dim a As mytype1 , b As mytype2
   b.z = 1234

   LSet a, b
   Print a.x

Differences from QB
   *In QB, the syntax was LSet dst = src. That syntax is also supported by 
     FB.

See also
   * RSet
   * Space
   * Put (File I/O)
   * MKD
   * MKI
   * MKL
   * MKS



------------------------------------------------------------ KeyPgLtrim ----
LTrim

Removes surrounding substrings or characters on the left side of a string

Syntax
   Declare Function LTrim ( ByRef str As Const String, [ Any ] ByRef 
   trimset As Const String = " " ) As String
   Declare Function LTrim ( ByRef str As Const WString, [ Any ] ByRef 
   trimset As Const WString = WStr(" ") ) As WString

Usage
   result = LTrim[$]( str [, [ Any ] trimset ] )

Parameters
   str
      The source string.
   trimset
      The substring to trim.

Return Value
   Returns the trimmed string.

Description
   This procedure trims surrounding characters from the left (beginning) of 
   a source string. Substrings matching trimset will be trimmed if 
   specified, otherwise spaces (ASCII code 32) are trimmed.

   If the Any keyword is used, any character matching a character in 
   trimset will be trimmed.

   All comparisons are case-sensitive.

Example
   Dim s1 As String = "  101 Things to do."
   Print "'" + LTrim(s1) + "'"
   Print "'" + LTrim(s1, " 01") + "'"
   Print "'" + LTrim(s1, Any " 01") + "'"

   Dim s2 As String = "BaaBaaBAA Test Pattern"
   Print "'" + LTrim(s2, "Baa") + "'"
   Print "'" + LTrim(s2, Any "BaA") + "'"

   will produce the output:

   '101 Things to do.'
   '  101 Things to do.'
   'Things to do.'
   'BAA Test Pattern'
   ' Test Pattern'

Platform Differences
   * DOS version/target of FreeBASIC does not support the wide-character 
     version of LTrim.

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * QB does not support specifying a trimset string or the ANY clause.

See also
   * RTrim
   * Trim




============================================================================
    M

----------------------------------------------------- KeyPgMidstatement ----
Mid (Statement)

Overwrites a substring of a string with another

Syntax
   Declare Sub Mid ( ByRef text As String, ByVal start As Integer, ByVal 
   length As Integer, ByRef expression As Const String )
   Declare Sub Mid ( ByVal text As WString Ptr, ByVal start As Integer, 
   ByVal length As Integer, ByVal expression As Const WString Ptr )

Usage
   Mid( text, start ) = expression
      Or
   Mid( text, start, length ) = expression

Parameters
   text
      The string to work with.
   start
      The start position in text of the substring to overwrite. The first 
      character starts at position 1.
   length
      The number of characters to overwrite.

Description
   Copies a maximum of length characters of expression into text, starting 
   at start.

   If length is not specified, all of expression is copied. The size of the 
   string text is unchanged; if expression is too big, as much of it is 
   copied up to the end of text.

   Mid can also be used as a function to return part of another string.  
   See Mid (Function).

Example
   Dim text As String

   text = "abc 123"
   Print text 'displays "abc 123"

   ' replace part of text with another string
   Mid(text, 5, 3) = "456" 
   Print text 'displays "abc 456"

Differences from QB
   * None

See also
   * Mid (Function)



------------------------------------------------------ KeyPgMidfunction ----
Mid (Function)

Returns a substring of a string

Syntax
   Declare Function Mid ( ByRef str as Const String, ByVal start as integer 
   ) as String
   Declare Function Mid ( ByVal str as Const WString Ptr, ByVal start as 
   integer ) as WString
   Declare Function Mid ( ByRef str as Const String, ByVal start as 
   integer, ByVal n as integer ) as String
   Declare Function Mid ( ByVal str as Const WString Ptr, ByVal start as 
   integer, ByVal n as integer ) as WString

Usage
   result = Mid[$]( str, start [, n ] )

Parameters
   str
      The source string.
   start
      The start position in str of the substring. The first character 
      starts at position 1.
   n
      The substring length, in characters.

Description
   Returns a substring starting from start in str. If str is empty then the 
   null string ("") is returned. If start <= 0 or start > len(str) then the 
   null string ("") is returned.

   In the first form of Mid, all of the remaining characters are returned. 
   In the second form, if n < 0 or n >= len(str) then all of the remaining 
   characters are returned.

Example
   Print Mid("abcdefg", 3, 2)
   Print Mid("abcdefg", 3)
   Print Mid("abcdefg", 2, 1)

   will produce the output:
   cd
   cdefg
   b

A Unicode example:
   Wiki: code rendered this way to allow display of the Unicode characters.

dim text as wstring * 20
   text = "&#1055;&#1088;&#1080;&#1074;&#1077;&#1090;, 
   &#1084;&#1080;&#1088;!"
   print mid(text, 6, 4) ' displays "&#1090;, &#1084;"

Platform Differences
   * DOS does not support the wide-character string versions of Mid.

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * QB does not support Unicode.

See also
   * InStr
   * Mid (Statement)
   * Left
   * Right
   * Asc



----------------------------------------------------------- KeyPgMinute ----
Minute

Gets the minute of the hour from a Date Serial 

Syntax
   Declare Function Minute ( ByVal date_serial As Double ) As Long

Usage
   #include "vbcompat.bi"
   result = Minute( date_serial )

Parameters
   date_serial
      the date serial

Return Value
   Returns the minute from a  variable containing a date in  Date Serial  
   format.

Description
 
   The compiler will not recognize this function unless vbcompat.bi is 
   included.

Example
   #include "vbcompat.bi"

   Dim ds As Double = DateSerial(2005, 11, 28) + TimeSerial(7, 30, 50)

   Print Format(ds, "yyyy/mm/dd hh:mm:ss "); Minute(ds)

Differences from QB
   * Did not exist in QB. This function appeared in PDS and VBDOS

See also
   * Date Serials



-------------------------------------------------------------- KeyPgMkd ----
MKD

Does a binary copy from a Double variable to a String, setting its length 
to 8 bytes

Syntax
   Declare Function MKD ( ByVal number As Double ) As String

Usage
   result = MKD[$]( number )

Parameters
   number
      A Double variable to binary copy to a String.

Return Value
   Returns a String with a binary copy of the Double.

Description
   Does a binary copy from a Double variable to a String, setting its 
   length to 8 bytes. The resulting string can be read back to a Double by 
   CVD.

   This function is useful to write numeric values to buffers without using 
   a Type definition.

Example
   Dim n As Double, e As String
   n = 1.2345
   e = MKD(n)
   Print n, CVD(e)

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * None

See also
   * MKI
   * MKL
   * MKS
   * CVD
   * CVI
   * CVL
   * CVS



------------------------------------------------------------ KeyPgMkdir ----
MkDir

Makes a folder/directory on the local file system

Syntax
   Declare Function MkDir ( ByRef folder As Const String ) As Long

Usage
   result = MkDir( folder )

Parameters
   folder
      The new default folder/directory to be created, or a path to the 
      sub-folder/sub-directory to be created.

Return Value
   Returns zero (0) on success, and negative one (-1) on failure.

Description
   Creates a folder/directoy on the local file system.

   If folder is not a simple folder/directory name, but a path to a 
   sub-folder/sub-directory, the parent folder(s)/directory(s) specified in 
   the path must already exist.
   (only one folder/directory can be created for each request)

Example
   Dim pathname As String = "foo\bar\baz"
   Dim result As Integer = MkDir( pathname )

   If 0 <> result Then Print "error: unable to create folder " & pathname & " in the current path."

Platform Differences
   * Linux requires the filename case matches the real name of the file. 
     Windows and DOS  are case insensitive. 
   * Path separators in Linux are forward slashes / . Windows uses 
     backward slashes \ but it allows for forward slashes .  DOS uses 
     backward  \ slashes. 

Differences from QB
   * None

See also
   * Shell
   * CurDir
   * ChDir
   * RmDir



-------------------------------------------------------------- KeyPgMki ----
MKI

Does a binary copy from an integer variable to a String of the same length 
as the size of the input variable

Syntax
   Declare Function MKI ( ByVal number As Integer ) As String
   Declare Function MKI<bits> ( ByVal number As Integer<bits> ) As String

Usage
   result = MKI[$]( number )
   result = MKI[$]<bits>( number )

Parameters
   number
      A Integer or Integer<bits> variable to binary copy to a String.

Return Value
   Returns a String containing a binary copy of number.

Description
   Does a binary copy from an Integer or Integer<bits> variable to a String,
   setting its length to the number of bytes in the type. The resulting 
   string can be read back to an integer type using CVI or CVI<bits>.

   This function is useful to write numeric values to buffers without using 
   a Type definition.

   MKI supports an optional <bits> parameter before the argument.  If bits 
   is 16, MKShort will be called instead; if bits is 32, MKL will be 
   called; if bits is 64, MKLongInt will be called.  The length of the 
   return value and the required number argument type will depend on which 
   function is called.  See each function's page for more information.

Example
   Dim a As Integer, b As String
   a=4534
   b=MKI(a)
   Print a, CVI(b)

Dialect Differences
   * In the -lang qb dialect, MKI returns a 2-byte-string, since a QB 
     integer is only 16 bits.
   * In the -lang qb dialect, <bits> parameter is not supported.
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

See also
   * CVI
   * MKShort
   * MKL
   * MKLongInt
   * Integer



-------------------------------------------------------------- KeyPgMkl ----
MKL

Does a binary copy from a Long variable to a String, setting its length to 
4 bytes

Syntax
   Declare Function MKL ( ByVal number As Long ) As String

Usage
   result = MKL( number )

Parameters
   number
      A Long variable to binary copy to a String.

Return Value
   Returns a String with a binary copy of the Long.

Description
   Does a binary copy from a Long variable to a String, setting its length 
   to 4 bytes. The resulting string can be read back to a Long by CVL.

   This function is useful to write numeric values to buffers without using 
   a Type definition.

Example
   Dim a As Long, b As String
   a = 4534
   b = MKL(a)
   Print a, CVL(b)
   Sleep

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * None

See also
   * MKD
   * MKI
   * MKS
   * CVD
   * CVI
   * CVL
   * CVS



-------------------------------------------------------- KeyPgMklongint ----
MKLongInt

Does a binary copy from a LongInt variable to a String, setting its length 
to 8 bytes

Syntax
   Declare Function MKLongInt ( ByVal number As LongInt ) As String

Usage
   result = MKLongInt[$]( number )

Parameters
   number
      A LongInt variable to binary copy to a String.

Return Value
   Returns a String with a binary copy of the LongInt.

Description
   Does a binary copy  from a LongInt variable to a string, setting its 
   length to 8 bytes. The resulting string can be read back to a longint by 
   CVLongInt

   This function is useful to write numeric values to buffers without using 
   a Type definition.

Example
   Dim a As LongInt, b As String
   a = 4534
   b = MKLongInt(a)
   Print a, CVLongInt(b)
   Sleep

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Mklongint.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * New to FreeBASIC

See also
   * CVLongInt



-------------------------------------------------------------- KeyPgMks ----
MKS

Does a binary copy from a Single variable to a String, setting its length 
to 4 bytes

Syntax
   Declare Function MKS ( ByVal number As Single ) As String

Usage
   result = MKS[$]( number )

Parameters
   number
      A Single variable to binary copy to a String.

Return Value
   Returns a String with a binary copy of the Single.

Description
   Does a binary copy  from a Single variable to a String, setting its 
   length to 4 bytes. The resulting string can be read back to a Single by 
   CVS.

   This function is useful to write numeric values to buffers without using 
   a Type definition.

Example
   Dim n As Single, e As String
   n = 1.2345
   e = MKS(n)
   Print n, CVS(e)

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   *None

See also
   * MKI
   * MKL
   * MKD
   * CVD
   * CVI
   * CVL
   * CVS



---------------------------------------------------------- KeyPgMkshort ----
MKShort

Does a binary copy from a Short variable to a String, setting its length to 
2 bytes

Syntax
   Declare Function MKShort ( ByVal number As Short ) As String

Usage
   result = MKShort[$](number)

Parameters
   number
      A Short variable to binary copy to a String.

Return Value
   Returns a String with a binary copy of the Short.

Description
   Does a binary copy  from a SHORT variable to a string, setting its 
   length to 2 bytes. The resulting string can be read back to a Short by 
   CVShort

   This function is useful to write numeric values to buffers without using 
   a Type definition.

Example
   Dim a As Short, b As String
   a = 4534
   b = MKShort(a)
   Print a, CVShort(b)
   Sleep

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Mkshort.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * In QBasic this function is called MKI.

See also
   * CVShort



-------------------------------------------------------- KeyPgOpModulus ----
Operator Mod (Modulus)

Finds the remainder from a division operation

Syntax
   Declare Operator Mod ( ByRef lhs As Integer, ByRef rhs As Integer ) As 
   Integer

Usage
   result = lhs Mod rhs

Parameters
   lhs
      The left-hand side dividend expression.
   rhs
      The right-hand side divisor expression.

Return Value
   Returns the remainder of a division operation.

Description
   Operator Mod (Modulus) divides two Integer expressions and returns the 
   remainder. Float numeric values are converted to Integer by rounding up 
   or down.

   Neither of the operands are modified in any way.

   This operator can be overloaded for user-defined types.

Example
   Print 47 Mod 7
   Print 5.6 Mod 2.1
   Print 5.1 Mod 2.8

Output:

   5
   0
   2

This is because: 
   * 47 divided by 7 gives a remainder of 5
   * 5.6 is rounded to 6 while 2.1 is rounded to 2. This makes the problem 
     6 MOD 2 which means 6 divided by 2 which gives a remainder of 0
   * 5.1 is rounded to 5 while 2.8 is rounded to 3. This makes the problem 
     5 MOD 3 which means 5 divided by 3 which gives a remainder of 2

Dialect Differences
   * In the -lang qb dialect, this operator cannot be overloaded.

Differences from QB
   * None

See also
   * Mathematical Functions



------------------------------------------------------------ KeyPgMonth ----
Month

Gets the month of the year from a Date Serial

Syntax
   Declare Function Month ( ByVal date_serial As Double ) As Long

Usage
   #include "vbcompat.bi"
   result = Month( date_serial )

Parameters
   date_serial
      the date

Return Value
   Returns the month number from a variable containing a date in  
   Date Serial  format.

   The month values are in the range 1-12 being 1 for January and 12 for 
   December.

Description

   The compiler will not recognize this function unless vbcompat.bi is 
   included.

Example
   #include "vbcompat.bi"

   Dim a As Double = DateSerial(2005,11,28) + TimeSerial(7,30,50)

   Print Format(a, "yyyy/mm/dd hh:mm:ss "); Month(a)

Differences from QB
   * Did not exist in QB. This function appeared in PDS and VBDOS

See also
   * Date Serials



-------------------------------------------------------- KeyPgMonthname ----
MonthName

Gets the name of a month from its integral representation

Syntax
   Declare Function MonthName ( ByVal month As Long, ByVal abbreviate As 
   Long = 0 ) As String

Usage
   #include "vbcompat.bi"
   result = MonthName( month_number [, abreviate ] )

Parameters
   month
      the number of the month of the year - 1:January through 12:December
   abbreviate
      flag to indicate that name should be abbreviated

Return Value
   Returns the local operating system language month name from month value 
   1 to 12.

Description
   If abbreviate is true, the month name abbreviation  is returned. If 
   omitted or false, the whole name is returned.
    
   The compiler will not recognize this function unless vbcompat.bi or 
   datetime.bi is included.

Example
   #include "vbcompat.bi"

   Dim ds As Double = DateSerial(2005, 11, 28) + TimeSerial(7, 30, 50)

   Print Format(ds, "yyyy/mm/dd hh:mm:ss "); MonthName(Month(ds))

Differences from QB
   * Did not exist in QB. This function appeared in Visual Basic.

See also
   * Date Serials



--------------------------------------------------------- KeyPgMultikey ----
MultiKey

Detects the status of keys by keyboard scancode.

Syntax
   Declare Function MultiKey ( ByVal scancode As Long ) As Long

Usage
   result = MultiKey(scancode)

Parameters
   scancode
      The scan code of the key to check.

Return Value
   Returns -1 if the key for the specified scan code is pressed, otherwise 
   returns 0.

Description
   MultiKey is a function which will detect the status of any key, 
   determined by scancode, at any time. It will return -1 if the key is 
   pressed, otherwise it will return 0.

   The keyboard input buffer is not disabled while you use MultiKey; that 
   is, pressed keys will be stored and subsequently returned by your next 
   call to Inkey or GetKey or Input. This means you have to empty the 
   keyboard input buffer manually when you finish using MultiKey, using 
   something like the following method:
   While Inkey <> "": Wend  '' loop until the keyboard input buffer is empty
         

   Keeping Inkey to work while you use MultiKey allows more flexibility and 
   can be useful to detect Chr(255)+"k" combo returned on window close 
   button click, if a windowed graphics mode has been set via the Screen 
   statement. For a list of accepted scancodes, see DOS keyboard scancodes; 
   these are guaranteed to be valid for all FreeBASIC supported platforms.
   MultiKey should always work in graphics mode, as long as the screen is 
   Unlocked. Support in the console depends on the platform the program is 
   run on though, and cannot be guaranteed.

Example
   #include "fbgfx.bi"
   #if __FB_LANG__ = "fb"
   Using FB '' Scan code constants are stored in the FB namespace in lang FB
   #endif

   Dim As Integer x, y

   ScreenRes 640, 480

   Color 2, 15

   x = 320: y = 240
   Do
      ' Check arrow keys and update the (x, y) position accordingly
      If MultiKey(SC_LEFT ) And x >   0 Then x = x - 1
      If MultiKey(SC_RIGHT) And x < 639 Then x = x + 1
      If MultiKey(SC_UP   ) And y >   0 Then y = y - 1
      If MultiKey(SC_DOWN ) And y < 479 Then y = y + 1
      
      ' Lock the page while we work on it
      ScreenLock
         ' Clear the screen and draw a circle at the position (x, y)
         Cls
         Circle(x, y), 30, , , , ,F
      ScreenUnlock
      
      Sleep 15, 1
      
      ' Run loop until user presses Escape
   Loop Until MultiKey(SC_ESCAPE)

   ' Clear Inkey buffer
   While Inkey <> "": Wend

   Print "Press CTRL and H to exit..."

   Do
      Sleep 25
      
      '' Stay in loop until user holds down CTRL and H at the same time
      If MultiKey(SC_CONTROL) And MultiKey(SC_H) Then Exit Do
   Loop
      

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Multikey.

Differences from QB
   * New to FreeBASIC

See also
   * Keyboard scancodes
   * GetMouse
   * GetJoystick
   * Screen (Graphics)
   * Inkey
   * Event
   * ScreenEvent



------------------------------------------------------ KeyPgMutexCreate ----
MutexCreate

Creates a mutex used for synchronizing the execution of threads

Syntax
   Declare Function MutexCreate ( ) As Any Ptr

Usage
   result = MutexCreate

Return Value
   The Any Ptr handle of the mutex created, or the null pointer (0) on 
   failure.

Description
   Mutexes, short for "Mutually Exclusive", are a way of synchronizing 
   shared data within threads.  If there is a global variable used by 
   multiple threads (or a local static variable used by a single thread 
   called multiple times), it should be "locked" during its use with a 
   mutex.  This halts all threads using MutexLock with that mutex 
   (including the implicit main thread executing main program), until it is 
   unlocked with MutexUnlock.

   Mutexcreate creates a mutex, returning a handle which is to be referred 
   to when locking, unlocking, or destroying the mutex.  Mutexes created 
   with Mutexcreate should be destroyed when no longer needed or before the 
   end of the program with MutexDestroy.

   A  mutex is a lock that guarantees three things:
   1. Atomicity - Locking a mutex is an atomic operation, meaning that the 
   operating system (or threads library) assures you that if you locked a 
   mutex, no other thread succeeded in locking this mutex at the same time.
   2. Singularity - If a thread managed to lock a mutex, it is assured that 
   no other thread will be able to lock the thread until the original 
   thread releases the lock.
   3. Non-Busy Wait - If a thread attempts to lock a thread that was locked 
   by a second thread, the first thread will be suspended (and will not 
   consume any CPU resources) until the lock is freed by the second thread. 
   At this time, the first thread will wake up and continue execution, 
   having the mutex locked by it. 

Example
   See also the ThreadCreate examples.

   'Visual example of mutual exclusion between 2 threads by using Mutex:
   'the "user-defined thread" computes the points coordinates on a circle,
   'and the "main thread" plots the points.
   '
   'Principle of mutual exclusion
   '          Thread#A                XOR                  Thread#B
   '.....                                         .....
   'MutexLock(mut)                                MutexLock(mut)
   '  Do_something#A_with_exclusion                 Do_something#B_with_exclusion
   'MutexUnlock(mut)                              MutexUnlock(mut)
   '.....                                         .....
   '
   'Behavior:
   '- The first point must be pre-calculated.
   '- Nothing prevents that a same calculated point could be plotted several times
   '(depends on execution times of the loops between main thread and user thread).
   '- Nothing prevents that a calculated point could be not plotted
   '(same remark on the loop times).
   '
   'If you comment out the lines containing "MutexLock" and "MutexUnlock"
   '(inside "user-defined thread" or/and "main thread"),
   'there will be no longer mutual exclusion between computation of coordinates and plotting of points,
   'and many points will not be plotted on circle (due to non coherent coordinates).

   '-----------------------------------------------------------------------------------------------------

   Type ThreadUDT                                   'Generic user thread UDT
      Dim handle As Any Ptr                        'Any Ptr handle to user thread
      Dim sync As Any Ptr                          'Any Ptr handle to mutex
      Dim quit As Byte                             'Boolean to end user thread
      Declare Static Sub Thread (ByVal As Any Ptr) 'Generic user thread procedure
      Dim procedure As Sub (ByVal As Any Ptr)      'Procedure(Any Ptr) to be executed by user thread
      Dim p As Any Ptr                             'Any Ptr to pass to procedure executed by user thread
      Const False As Byte = 0                      'Constante "false"
      Const True As Byte = Not False               'Constante "true"
   End Type

   Static Sub ThreadUDT.Thread (ByVal param As Any Ptr) 'Generic user thread procedure
      Dim tp As ThreadUDT Ptr = param                  'Casting to generic user thread UDT
      Do
         Static As Integer I
         MutexLock(tp->sync)                          'Mutex (Lock) for user thread
         tp->procedure(tp->p)                         'Procedure(Any Ptr) to be executed by user thread
         I += 1
         Locate 30, 38
         Print I;
         MutexUnlock(tp->sync)                        'Mutex (Unlock) for user thread
         Sleep 5, 1
      Loop Until tp->quit = tp->True                   'Test for ending user thread
   End Sub

   '-----------------------------------------------------------------------------------------------------

   Type Point2D
      Dim x As Integer
      Dim y As Integer
   End Type

   Const x0 As Integer = 640 / 2
   Const y0 As Integer = 480 / 2
   Const r0 As Integer = 200
   Const pi As Single = 4 * Atn(1)

   Sub PointOnCircle (ByVal p As Any Ptr)
      Dim pp As Point2D Ptr = p
      Dim teta As Single = 2 * pi * Rnd
      pp->x = x0 + r0 * Cos(teta)
      Sleep 5, 1                         'To increase possibility of uncorrelated data occurrence
      pp->y = y0 + r0 * Sin(teta)
   End Sub

   Screen 12
   Locate 30, 2
   Print "<any_key> : exit";
   Locate 30, 27
   Print "calculated:";
   Locate 30, 54
   Print "plotted:";

   Dim Pptr As Point2D Ptr = New Point2D
   PointOnCircle(Pptr)                   ' Computation for a first point valid on the circle

   Dim Tptr As ThreadUDT Ptr = New ThreadUDT
   Tptr->sync = MutexCreate
   Tptr->procedure = @PointOnCircle
   Tptr->p = Pptr
   Tptr->handle = ThreadCreate(@ThreadUDT.Thread, Tptr)

   Do
      Static As Integer I
      Sleep 5, 1
      MutexLock(Tptr->sync)   'Mutex (Lock) for main thread
      PSet (Pptr->x, Pptr->y) 'Plotting one point
      I += 1
      Locate 30, 62
      Print I;
      MutexUnlock(Tptr->sync) 'Mutex (Unlock) for main thread
   Loop Until Inkey <> ""
    
   Tptr->quit = Tptr->True
   ThreadWait(Tptr->handle)
   MutexDestroy(Tptr->sync)
   Delete Tptr
   Delete Pptr

   Sleep

   See also the similar CondCreate example

Dialect Differences
   * Threading is not allowed in the -lang qb dialect.

Platform Differences
   * The DOS version of FreeBASIC does not allow for threads, as the OS 
     does not support them.
   * In Linux the threads are always started in the order they are 
     created, this can't be assumed in Win32. It's an OS, not a FreeBASIC 
     issue. 

Differences from QB
   * New to FreeBASIC

See also
   * MutexDestroy
   * MutexLock
   * MutexUnlock
   * ThreadCreate
   * ThreadWait



----------------------------------------------------- KeyPgMutexDestroy ----
MutexDestroy

Destroys a mutex

Syntax
   Declare Sub MutexDestroy ( ByVal id As Any Ptr )

Usage
   MutexDestroy( id )

Parameters
   id
      The Any Ptr handle of the mutex to be destroyed.

Description
   Mutexdestroy discards a mutex created by MutexCreate.  This call should 
   be executed after any threads using the mutex are no longer in use.

   See MutexCreate for more general information on mutexes.

Example
   See the examples in MutexCreate and also ThreadCreate.

Dialect Differences
   * Threading is not allowed in the -lang qb dialect.

Platform Differences
   * The DOS version of FreeBASIC does not allow for threads, as the OS 
     does not support them.
   * In Linux the threads are always started in the order they are 
     created, this can't be assumed in Win32. It's an OS, not a FreeBASIC 
     issue. 

Differences from QB
   * New to FreeBASIC

See also
   * MutexCreate
   * MutexLock
   * MutexUnlock
   * ThreadCreate
   * ThreadWait



-------------------------------------------------------- KeyPgMutexLock ----
MutexLock

Acquires a mutex

Syntax
   Declare Sub MutexLock ( ByVal id As Any Ptr )

Usage
   MutexLock( id )

Parameters
   id
      The Any Ptr handle of the mutex to be locked.

Description
   Mutexlock halts any other threads using a mutex "handle", generated by 
   MutexCreate, until the handle is unlocked with MutexUnlock.
   Such a halted thread has its execution suspended and does not consume 
   any CPU time until the mutex is unlocked.

   See MutexCreate for more general information on mutexes.

Example
   See also the examples in MutexCreate and also ThreadCreate.

   'Example of mutual exclusion for synchronization between 2 threads
   'by using 2 Mutexes only (by self lock and mutual unlock):
   'The Producer works one time, then the Consumer works one time.
   '
   'Principle of synchronisation by mutual exclusion
   '(initial condition: mut#A and mut#B locked)
   '
   '          Thread#A              XORs              Thread#B
   'Do_something#A_with_exclusion          MutexLock(mut#A)
   'MutexUnlock(mut#A)                       Do_something#B_with_exclusion
   '.....                                  MutexUnlock(mut#B)
   'MutexLock(mut#B)                       .....

   '----------------------------------------------------------------------

   Dim Shared produced As Any Ptr
   Dim Shared consumed As Any Ptr
   Dim consumer_id As Any Ptr
   Dim producer_id As Any Ptr

   Sub consumer ( ByVal param As Any Ptr )
      For i As Integer = 0 To 9
         MutexLock produced
         Print , ",consumer gets:" ; i
         MutexUnlock consumed
         Sleep 5, 1
      Next i
   End Sub

   Sub producer ( ByVal param As Any Ptr )
      For i As Integer = 0 To 9
         Print "Producer puts:" ; i;
         MutexUnlock produced
         MutexLock consumed
      Sleep 5, 1
   Next i
   End Sub

   produced = MutexCreate
   consumed = MutexCreate
   If ( produced = 0 ) Or ( consumed = 0 ) Then
      Print "Error creating mutexes! Exiting..."
      Sleep
      End
   End If

   MutexLock produced
   MutexLock consumed

   consumer_id = ThreadCreate ( @ consumer )
   producer_id = ThreadCreate ( @ producer )
   If ( producer_id = 0 ) Or ( consumer_id = 0 ) Then
      Print "Error creating threads! Exiting..."
      Sleep
      End
   End If

   ThreadWait consumer_id
   ThreadWait producer_id

   MutexDestroy consumed
   MutexDestroy produced

   Sleep

   ' 'Threadcreate' launches one time the user-defined Sub in a separate execution thread
   '    (which runs simultaneously with the rest of the main code).
   ' If you want obtain a periodically display from the thread,
   '    you must put (into the thread) a [Do...Loop] block with a 'Sleep x, 1' to adjust the display period
   '    and a flag to exit the loop (and terminate the thread).
   '
   ' Warning:
   ' - Each thread has not its own memory of cursor position, so for that and other reasons, it is mandatory
   '      to apply an exclusion between displaying from the main code (main thread) and displaying from the user thread,
   '      by using a 'Mutex' ([Mutexlock...Mutexunlock] block).
   '   At beginning of each display block both into main thread and user thread,
   '      the initial cursor position must also be re-initialized.
   ' - The input keywords (like keyboard, mouse) cannot be safely run when the screen is locked,
   '      therefore a such keyword must be outside of any [Screenlock...Screenunlock] block (outside this block in its own thread,
   '      and protected of block of another thread by a 'Mutex').
   '
   ' See below a rustic program, but showing all these constraints:

   Dim Shared As Any Ptr sync   '' pointer to Mutex
   Dim Shared As Byte quit = 0  '' flag to end user thread
   Dim As Any Ptr handle        '' pointer to thread handle

   Sub ProcedureThread (ByVal param As Any Ptr)  '' param not used in thread body
      Do
         MutexLock(sync)       '' Mutex for exclusion of displaying
            ScreenLock        '' keyword after Mutexlock
               Locate 1, 70  '' re-initialize cursor position
               Print Date
               Locate , 71
               Print Time;
            ScreenUnlock      '' keyword before Mutexunlock
         MutexUnlock(sync)     '' end exclusion
         Sleep 100, 1          '' ajust display period
      Loop Until quit <> 0      '' test for exit thread
   End Sub

   Screen 12
   Locate 1, 62
   Print "Date:"
   Locate , 62
   Print "Time:";
   Locate 15, 20
   Print "Mouse (position):"
   Locate , 20
   Print "Mouse (buttons) :";
   Locate 30, 2
   Print "<any_key> or <click on window close button>: exit";

   sync = MutexCreate                          '' create Mutex (before Threadcreate)
   handle = ThreadCreate(@ProcedureThread, 0)  '' launch thread

   Dim As String s
   Do
      MutexLock(sync)                     '' Mutex for exclusion of displaying
         Dim As Integer x, y, b
         GetMouse x, y , , b             '' keyword outside [Screenlock...Screenunlock] and protected by Mutex
         ScreenLock                      '' keyword after Mutexlock
            Locate 15, 37               '' re-initialize cursor position
            Print Using "######"; x; y
            Locate , 43
            Print Using "##"; b;
         ScreenUnlock                    '' Keyword before Mutexunlock
         s = Inkey                       '' keyword outside [Screenlock...Screenunlock] and protected by Mutex
      MutexUnlock(sync)                   '' end exclusion
      Sleep 10, 1                         '' ajust display period
   Loop Until s <> ""
    
   quit = Not quit     '' order thread end
   ThreadWait(handle)  '' wait for thread end
   MutexDestroy(sync)  '' free Mutex

Dialect Differences
   * Threading is not allowed in the -lang qb dialect.

Platform Differences
   * The DOS version of FreeBASIC does not allow for threads, as the OS 
     does not support them.
   * In Linux the threads are always started in the order they are 
     created, this can't be assumed in Win32. It's an OS, not a FreeBASIC 
     issue. 

Differences from QB
   * New to FreeBASIC

See also
   * MutexCreate
   * MutexDestroy
   * MutexUnlock
   * ThreadCreate
   * ThreadWait



------------------------------------------------------ KeyPgMutexUnlock ----
MutexUnlock

Releases a mutex lock

Syntax
   Declare Sub MutexUnlock ( ByVal id As Any Ptr )

Usage
   MutexUnlock( id )

Parameters
   id
      The Any Ptr handle of the mutex to be unlocked.

Description
   Mutexunlock releases a mutex "handle" created by MutexCreate, and locked 
   with MutexLock.  This allows other threads sharing the mutex to continue 
   execution.

   See MutexCreate for more general information on mutexes.

Example
   See the examples in MutexCreate and also ThreadCreate.

Dialect Differences
   * Threading is not allowed in the -lang qb dialect.

Platform Differences
   * The DOS version of FreeBASIC does not allow for threads, as the OS 
     does not support them.
   * In Linux the threads are always started in the order they are 
     created, this can't be assumed in Win32. It's an OS, not a FreeBASIC 
     issue. 

Differences from QB
   * New to FreeBASIC

See also
   * MutexCreate
   * MutexDestroy
   * MutexLock
   * ThreadCreate
   * ThreadWait




============================================================================
    N

------------------------------------------------------------ KeyPgNaked ----
Naked

Write functions without prolog/epilog code

Syntax
   {Sub | Function} identifier Naked [calling_convention] ( param_list ) [[ 
   ByRef ] As data_type]
      asm_statements
   End {Sub | Function}

Parameters
   identifier - name of the procedure.
   calling_convention - calling convention of the procedure - can be cdecl, 
   pascal, or stdcall
   asm_statements - the code in the procedure body.  The code for handling 
   parameters and returning values must all be done manually.  Note that 
   the methods for doing these can change, depending on the 
   calling convention.
   param_list - parameters to be passed to the procedure.
   data_type - the data type of the function.

Description
   Naked allows the programmer to write procedures without the compiler 
   generating any prolog/epilog code.
   This is useful when writing small, fast functions in Asm without any 
   unnecessary overhead (so, no register preservation for such Asm blocks).

Example
   '' Naked cdecl function (for fbc 32-bit)
   Function subtract_c Naked cdecl _   '' parameters pushed onto call stack in reverse order of declaration
      ( _
         ByVal a As Long, _
         ByVal b As Long _        '' parameter pushed onto stack in first
      ) As Long
      
      Asm
         mov eax, dword Ptr [esp+4]  '' eax = a
         Sub eax, dword Ptr [esp+8]  '' eax -= b
         ret                         '' return result in eax
      End Asm
      
   End Function

   Print subtract_c( 5, 1 ) '' 5 - 1

   ''---------------------------------------------------------------------------------------------------------------------

   '' Naked stdcall function (for fbc 32-bit)
   Function subtract_s Naked stdcall _ '' parameters pushed onto call stack in reverse order of declaration
                      _          '' called procedure responsible for removing parameters from stack
                      _          ''   (appending constant to RET instruction specifying number of bytes to release)
      ( _
         ByVal a As Long, _
         ByVal b As Long _        '' parameter pushed onto stack in first
      ) As Long
      
      Asm
         mov eax, dword Ptr [esp+4]  '' eax = a
         Sub eax, dword Ptr [esp+8]  '' eax -= b
         ret 8                       '' return result in eax and 8 bytes (2 integers) to release
      End Asm
      
   End Function

   Print subtract_s( 5, 1 ) '' 5 - 1 

   ''---------------------------------------------------------------------------------------------------------------------

   '' Naked pascal function (for fbc 32-bit)
   Function subtract_p Naked pascal _  '' parameters pushed onto call stack in same order as declaration
                      _          '' called procedure responsible for removing parameters from stack
                      _          ''   (appending constant to RET instruction specifying number of bytes to release)
      ( _
         ByVal a As Long, _       '' parameter pushed onto stack in first
         ByVal b As Long _
      ) As Long
      
      Asm
         mov eax, dword Ptr [esp+8]  '' eax = a
         Sub eax, dword Ptr [esp+4]  '' eax -= b
         ret 8                       '' return result in eax and 8 bytes (2 longs) to release
      End Asm
      
   End Function

   Print subtract_p( 5, 1 ) '' 5 - 1

   '' Naked cdecl function (for fbc 32-bit)
   '' plus ecx register preserved in asm block by creating user stack
   Function subtract_cp Naked cdecl _      '' parameters pushed onto call stack in reverse order of declaration
      ( _
         ByVal a As Long, _
         ByVal b As Long _            '' parameter pushed onto stack in first
      ) As Long
      
      Asm
         push ebp                        '' push ebp onto stack   => esp -= 4
         mov ebp, esp                    '' ebp = esp
                                 ''    => create user stack 4 bytes above call stack
         push ecx                        '' push ecx onto user stack   => esp -= 4
         mov eax, dword Ptr [(ebp+4)+4]  '' eax = a   (supplementary offset of +4 bytes only due to 'push ebp')
         mov ecx, dword Ptr [(ebp+8)+4]  '' ecx = b   (supplementary offset of +4 bytes only due to 'push ebp')
         Sub eax, ecx                    '' eax -= ecx
         pop ecx                         '' pop ecx from user stack   => esp += 4
         mov esp, ebp                    '' esp = ebp
         pop ebp                         '' pop ebp from stack   => esp += 4
                                 ''    => discard user stack
         ret                             '' return result in eax
      End Asm
      
   End Function

   Print subtract_cp( 5, 1 ) '' 5 - 1

Platform Differences
   * The default calling convention depends on the target platform, thus 
     it is best to specify the expected calling convention explicitly when 
     using Naked.

Differences from QB
   * New to FreeBASIC

See also
   * Asm
   * Calling Conventions
   * Function
   * Sub
   * cdecl
   * pascal
   * stdcall



------------------------------------------------------------- KeyPgName ----
Name

Renames a file on disk

Syntax
   Declare Function Name( ByRef oldname As Const String, ByRef newname As 
   Const String ) As Long

Usage
   result = Name( oldname, newname )

Parameters
   oldname
      Name of an existing file.
   newname
      New name of the file.

Return Value
   Returns zero (0) on success and non-zero on failure.

Description
   Renames a file or folder originally called oldname to newname.

   The function is not guaranteed to succeed if a file/folder exists with 
   the same name.  It may  succeed, overwriting the original, or it may 
   fail.  For greater control, FileExists could be used to test for an 
   existing file, and Kill could be used to delete an existing file 
   beforehand.

Example
   Dim OldName As String
   Dim NewName As String
   Dim result As Integer 

   OldName = "dsc001.jpg"
   NewName = "landscape.jpg"

   result = Name( OldName, NewName )
   If 0 <> result Then 
      Print "error renaming " & oldname & " to " & newname & "."
   End If

Differences from QB
   * In QB, NAME required AS rather than a comma between the old and new 
     names.  This is because NAME was a language keyword rather than a 
     function.

See also
   * Kill
   * FileExists



-------------------------------------------------------- KeyPgNamespace ----
Namespace

Declares a namespace block.

Syntax
   Namespace identifier [ Alias "aliasname" ]
      statements
   End Namespace

Parameters
   identifier
      The name of the namespace (including nested names specifier).
   aliasname
      An alternate external name for the namespace.

Description
   Namespaces allow to group entities like objects (predefined data-types 
   and UDTs including Union and Enum) and procedures (including their 
   declarations) under a name. This way the global scope can be divided in 
   "sub-scopes", each one with its own name. 

   Whether or not explicitly declared a namespace in a source file, the 
   compiler adds a default namespace. This unnamed namespace, called the 
   global namespace, is present in every file.
   Any identifier in the global namespace is available for use in a named 
   namespace (even global symbols with the same name as keywords may be 
   declared inside a namespace). 

   Namespaces implicitly have public access and this is not modifiable.
   A variable declared inside a namespace is always implicitly static and 
   visible throughout the entire program even if the declaration modifier 
   Shared is not specified (static and shared are optional, but this may 
   improve code readability).

   Namespaces do not have any effect on the visibility of a define.
   It is possible to define a namespace in two or more declarations.

   Namespaces are commonly used in libraries where you don't want all the 
   symbols from that library to crowd the user's space (called the global 
   namespace). 
   For example, if you used the "Forms" library, it might define the Point 
   type for describing an X and Y coordinate, and you might also define it 
   for another purpose. This can be resolved by creating the namespace 
   Forms for the library, and then referring to its Point type as 
   Forms.Point, and yours as just Point. 

   To access from outside a defined symbol in a namespace, add the 
   namespace identifier followed by a dot as a prefix of the symbol, or 
   bring the namespace symbols into the current scope by means of the 
   Using (Namespaces) statement.
   To access duplicated symbols defined as global outside the namespace, 
   add one or preferably two dot(s) as prefix: .SomeSymbol or preferably ..
   SomeSymbol (or only ..SomeSymbol if inside a With..End With block).

   Note: The parser allows to define anonymous Namespaces (without 
   identifier term), but this is the only similarity with the actual C++ 
   capability: The FB compiler automatically generates multiple separate 
   anonymous Namespaces instead of one only per module in such a case.
   The FB anonymous Namespaces are almost unusable because all their 
   declarations are inaccessible, even from the body of the module that 
   contains them. Apart from encapsulating module constructors/destructors 
   also inside, nothing else can be done with them.

Example
   Namespace Forms
      Type Point '' A 2D point
         As Integer x
         As Integer y
      End Type
      '' Since we are inside of the namespace, Point resolves to Forms.Point.
      Sub AdjustPoint( ByRef pt As Point, ByVal newx As Integer, ByVal newy As Integer )
         pt.x = newx
         pt.y = newy
      End Sub
   End Namespace

   Type Point '' A 3D point
      As Integer x
      As Integer y
      As Integer z
   End Type

   Sub AdjustPoint( ByRef pt As Point, ByVal newx As Integer, ByVal newy As Integer, ByVal newz As Integer )
      pt.x = newx
      pt.y = newy
      pt.z = newz
   End Sub

   Dim pt1 As Point
   AdjustPoint( pt1, 1, 1, 1 )
   Dim pt2 As Forms.Point
   Forms.AdjustPoint( pt2, 1, 1 )

   Namespaces are GCC C++ compatible, the following code aims to test that.
   (cpp)
   // mylib.cpp
   // To compile:
   //	g++ -c mylib.cpp -o mylib.o
   //	ar rcs libmylib.a mylib.o

   #include <string.h>
   #include <ctype.h>

   Namespace mylib
   {
   	Int test() 
   	{
   		Return 123;
   	}
   }

   '' test.bas

   Extern "c++" Lib "mylib"
      Namespace mylib Alias "mylib"
         Declare Function test() As Integer
      End Namespace
   End Extern

   Print mylib.test()

Dialect Differences
   * Namespaces are not supported in the -lang qb dialect.

Differences from QB
   * New to FreeBASIC

See also
   * Using (Namespaces)



------------------------------------------------------------ KeyPgOpNew ----
Operator New Expression

Operator to dynamically allocate memory and construct data of a specified 
type.

Usage
   result = New datatype
      or
   result = New datatype ( initializers, ... )
      or
   result = New datatype[ count ]

Parameters
   datatype
      Name of the data type to create.
   initializers
      Initial value(s) for the variable.
   count
      Exact number of elements to allocate.

Return Value
   A pointer of type datatype to the newly allocated data, or null pointer 
   if the memory allocation failed.

Description
   The New Expression operator dynamically allocates memory and constructs 
   a specified data type.

   For simple types, like integers, an initial value can be given. For 
   types without constructors, initial values can be specified for each 
   field (either with default initializer at data-field declaration, or 
   with initializer list as in New datatype (initializers, ..) if all type 
   data-fields are numeric primitives only and without any default 
   initializers). For types with at least one constructor, the initialize 
   list (if any) must match an existing constructor. If no initializers are 
   given, the default values for those types will be set.

   New[] Expression operator is the (one-dimensional) array-version of the 
   New Expression operator and allocates enough memory for the specified 
   number of objects. The default constructor for the type will be used to 
   set the initial values for each item.

   Objects created with New Expression operator must be freed with 
   Delete Statement operator. Object array created with New[] Expression 
   operator must be freed with Delete[] Statement operator, the 
   array-version of Delete Statement operator. You cannot mix and match the 
   different versions of the operators.

   Specifying an initial value of Any, as in New datatype (Any) will 
   allocate memory for the type, but not initialize the data.  This is only 
   valid on data types that do not have constructors (otherwise for data 
   types with constructors, syntax of simple memory allocation with pointer 
   conversion, like Cptr(datatype Ptr, Allocate(Sizeof(datatype))), can be 
   substituted to the invalid use of New...Any).

   Specifying an initial value of Any, as in New datatype[count] {Any} will 
   allocate memory for the array, but not initialize the data.  This is 
   only valid on data types that do not have constructors (otherwise for 
   data types with constructors, syntax of simple memory allocation with 
   pointer conversion, like Cptr(datatype Ptr, Allocate(count * 
   Sizeof(datatype))), can be substituted to the invalid use of New...Any).

   The total memory, in bytes, to be allocated with New datatype[count] 
   expression is calculated as sizeof(datatype) * count, plus 
   sizeof(uinteger) if there is an implicit or explicit Destructor.  The 
   total memory requested in bytes to be allocated must not overflow the 
   value that can be held by a UInteger.  The extra uinteger, if allocated, 
   stores the number of elements as part of the allocation, so that 
   Delete Statement can determine the count of destructors to call.

   If the memory allocation fails, a null pointer is returned and no 
   constructors are called.

   The dynamic memory allocation process part provided by the New 
   Expression operator can be overloaded for user-defined types as a member 
   operator New Overload. The following process part for data construction 
   can never be modified.

   Note: Using pointer = New datatype[count] may be unsafe if pointer was 
   declared with a type different from datatype (for sub-type polymorphism 
   purpose for example), because the pointer arithmetic fails to access the 
   elements if the pointer type size is different from the size of datatype 
   (when using Operator [] (Pointer Index) or adding an offset (element 
   number) to the pointer, or even when Delete[] Statement itself (the 
   array-version of Delete Statement) must destroy the elements).

Example
   Type Rational
      As Integer numerator, denominator
   End Type

   ' Create and initialize a "rational" and store its address.
   Dim p As Rational Ptr = New Rational(3, 4)

   ' Test if null return pointer
   If (p = 0) Then
      Print "Error: unable to allocate memory"
   Else
      Print p->numerator & "/" & p->denominator
      ' Destroy the rational and give its memory back to the system.
      Delete p
   End If

   Sleep

   ' Allocate memory for 100 integers and store the address of the first one.
   Dim p As Integer Ptr = New Integer[100]

   ' Test if null return pointer
   If (p = 0) Then
      Print "Error: unable to allocate memory"
   Else
      ' Assign some values to the integers in the array.
      For i As Integer = 0 To 99
         p[i] = i
      Next
      ' Free the entire integer array.
      Delete[] p
   End If

   Print "Done."
   Sleep

   '' Example of nested New [] to get a 2-dimentional object array (4*3)

   Type UDT
      Dim As Integer N
      Declare Constructor ()
      Declare Destructor ()
   End Type

   Constructor UDT ()
      Print "Constructor",
   End Constructor

   Destructor UDT ()
      Print "Destructor",
   End Destructor

   Dim As UDT Ptr Ptr p = New UDT Ptr [4]  '' New [] allocation for the first dimension:
                                 ''   no internal allocation of extra uinteger because
                                 ''   allocation of array of pointers (to UDT objects with destructor)
   For I As Integer = 0 To 3
      p[I] = New UDT [5]                  '' New [] allocations for the last dimension:
                                 ''   internal allocation of an extra uinteger for each New [],
                                 ''   because allocation of an array of UDT objects with destructor
      Print
   Next I

   For I As Integer = 0 To 3
      For J As Integer = 0 To 4
         p[I][J].N = I * 10 + J  '' assignment of each object array element
      Next J
   Next I

   Print
   For I As Integer = 0 To 3
      For J As Integer = 0 To 4
         Print p[I][J].N,        '' display of each object array element
      Next J
      Print
   Next I
   Print

   For I As Integer = 0 To 3
      Delete [] p[I]  '' Delete [] deallocations for the last dimension
      Print
   Next I
   Delete [] p         '' Delete [] deallocation for the first dimension)
   Print

   Sleep

      Output example:

   Constructor   Constructor   Constructor   Constructor   Constructor
   Constructor   Constructor   Constructor   Constructor   Constructor
   Constructor   Constructor   Constructor   Constructor   Constructor
   Constructor   Constructor   Constructor   Constructor   Constructor

    0             1             2             3             4
    10            11            12            13            14
    20            21            22            23            24
    30            31            32            33            34

   Destructor    Destructor    Destructor    Destructor    Destructor
   Destructor    Destructor    Destructor    Destructor    Destructor
   Destructor    Destructor    Destructor    Destructor    Destructor
   Destructor    Destructor    Destructor    Destructor    Destructor

Dialect Differences
   * Only available in the -lang fb dialect.

Differences from QB
   * New to FreeBASIC

See also
   * Delete Statement
   * Placement New
   * New Overload



--------------------------------------------------- KeyPgOpPlacementNew ----
Operator Placement New

Operator to construct an object at a specified memory address.

Syntax
   result = New(address) datatype
      or
   result = New(address) datatype ( initializers, ... )
      or
   result = New(address) datatype[ count ]

Parameters
   address 
      the location in memory to construct. the parenthesis are not 
      optional.
   initializers
      Initial value(s) for the variable.
   datatype
      name of the data type to construct.
   count
      Number of elements to construct.

Return Value
   A pointer of type datatype to the newly constructed data.

Description
   The Placement New operator constructs a specified data type at the 
   specified memory location. 

   For simple types, like integers, an initial value can be given. For 
   types without Constructors, initial values can be specified for each 
   field (either with default initializer at data-field declaration, or 
   with initializer list as in New datatype (initializers, ..) if all type 
   data-fields are numeric primitives only and without any default 
   initializers). For types with at least one constructor, the initialize 
   list (if any) must match an existing constructor. If no initializers are 
   given, the default values for those types will be set.

   Memory is not allocated when using the Placement New operator. Instead, 
   the memory at the specified address is used (the provided memory size 
   must be large enough to contain all the placement).
   It is incorrect to call Delete Statement on the address. The proper way 
   is to only call the destructor if one exists (implicitly or explicitly), 
   with syntax as for a member method by using member access operator.
   See examples below for proper Placement New operator usage.

   Placement New[] operator is the (one-dimensional) array-version of the 
   Placement New operator and constructs the specified number of objects 
   from the specified memory location. The default constructor for the type 
   will be used to set the initial values for each item.

   Specifying an initial value of Any, as in New(address)datatype (Any) or 
   New(address)datatype[count] {Any} will not initialize the data.  This is 
   only valid on data types that do not have constructors (otherwise for 
   data types with constructors, syntax of simple pointer conversion, like 
   Cptr(datatype Ptr, address), can be substituted to the invalid use of 
   New...Any).

   Because it does not provide any dynamic memory allocation process, the 
   Placement New operator (unlike the New Expression operator) does not 
   allow any overloading by a member operator for user-defined types.

   Note: Using pointer = New(address)datatype[count] may be unsafe if 
   pointer was declared with a type different from datatype (for sub-type 
   polymorphism purpose for example), because the pointer arithmetic fails 
   to access the elements if the pointer type size is different from the 
   size of datatype (when using Operator [] (Pointer Index) or adding an 
   offset (element number) to the pointer).

Example
   '' "placement new" example

   Type Rational
      As Integer    numerator, denominator
      Declare Constructor ( ByVal n As Integer, ByVal d As Integer )
      As String ratio = "/"
   End Type

   Constructor Rational ( ByVal n As Integer, ByVal d As Integer )
      This.numerator = n
      This.denominator = d
   End Constructor

   Scope
      
      '' allocate some memory to construct as a Rational
      Dim As Any Ptr ap = CAllocate(Len(Rational))
      
      '' make the placement new call
      Dim As Rational Ptr r = New (ap) Rational( 3, 4 )
      
      '' you can see, the addresses are the same, just having different types in the compiler
      Print ap, r
      
      '' confirm all is okay
      Print r->numerator & r->ratio & r->denominator
      
      '' delete must not be used with placement new
      '' destroying must be done explicitly if a destructor exists (implicitly or explicitly)
      ''   (in this example, the var-string member induces an implicit destructor)
      r->Destructor( )
      
      '' we explicitly allocated, so we explicitly deallocate
      Deallocate( ap )
      
   End Scope

Dialect Differences
   * Only available in the -lang fb dialect.

Differences from QB
   * New to FreeBASIC

See also
   * Destructor
   * New Expression



------------------------------------------------------------- KeyPgNext ----
Next

Control flow statement to mark the end of a For...Next loop.

Syntax
   Next [ identifier_list ]

Description
   Indicates the end of a statement block associated with a matching For 
   statement. 

   When Next is used on its own without an identifier_list, it closes the 
   most recent For statement block.

   identifier_list is optional and may be one or more variable names 
   separated by commas.  This form of the Next statement is retained for 
   compatibility with QB.  identifier_list, if given, must match the 
   identifiers used in the associated For statements in reverse order, from 
   inner to outer.

Example
   For i As Integer = 1 To 10
      For j As Integer = 1 To 2
         ' ...
      Next
   Next

   For i As Integer = 1 To 10
      For j As Integer = 1 To 2
         ' ...
      Next j
   Next i

   For i As Integer = 1 To 10
   For j As Integer = 1 To 2
      ' ...
   Next j,i

Differences from QB
   * ByRef arguments cannot be used as counters.

See also
   * For...Next



------------------------------------------------------- KeyPgResumenext ----
Resume Next

Error handling statement to resume execution after a jump to an error 
handler

Syntax
   Resume Next

Description
   Resume Next is used in the traditional QB error handling mechanism 
   within an error handler (called by On Error) to return execution to the 
   line after the one that caused the error.  Usually this is used to avoid 
   executing the same line and causing the error again.

   Resume Next resets the Err value to 0

Example
   '' Compile with -lang fblite or qb

   #lang "fblite"

   Dim As Single i, j

   On Error Goto ErrHandler

   i = 0
   j = 5
   j = 1 / i ' this line causes a divide-by-zero error; execution jumps to ErrHandler label

   Print "ending..."

   End ' end the program so that execution does not fall through to the error handler again

   ErrHandler:

   Resume Next ' execution jumps to 'Print "ending..."' line, but j is now in an undefined state

Dialect Differences
   *  RESUME NEXT is not supported in the -lang fb dialect. Statements can 
     be used in its function form to return an error code
   If Open( "text" For Input As #1 ) <> 0 Then
     Print "Unable to open file"
   End If

 

Differences from QB
   * Must compile with -ex or -exx option

See also
   * Err
   * Resume
   * Error Handling



------------------------------------------------------------ KeyPgOpNot ----
Operator Not (Complement)

Returns the bitwise-not (complement) of a numeric value

Syntax
   Declare Operator Not ( ByRef rhs As Byte ) As Integer
   Declare Operator Not ( ByRef rhs As UByte ) As Integer
   Declare Operator Not ( ByRef rhs As Single ) As Integer
   Declare Operator Not ( ByRef rhs As Double ) As Integer

   Declare Operator Not ( ByRef rhs As T ) As T

Usage
   result = Not rhs

Parameters
   rhs
      The right-hand side expression.
   T
      Any numeric or boolean type.

Return Value
   Returns the bitwise-complement of its operand.

Description
   This operator returns the bitwise-complement of its operand, a logical 
   operation that results in a value with bits set depending on the bits of 
   the operand.
   (for a boolean type, 'Not false' returns 'true' and 'Not true' returns 
   'false')

   The truth table below demonstrates all combinations of a 
   boolean-complement operation:

      +-------+------+
      |Rhs Bit|Result|
      |0      |1     |
      |1      |0     |
      +-------+------+

   This operator can be overloaded for user-defined types.

Example
   ' Using the NOT operator on a numeric value

   Dim numeric_value As Byte
   numeric_value = 15 '00001111

   'Result = -16 =     11110000
   Print Not numeric_value

   ' Using the NOT operator on conditional expressions
   Dim As UByte numeric_value1, numeric_value2
   numeric_value1 = 15
   numeric_value2 = 25

   If Not numeric_value1 = 10 Then Print "Numeric_Value1 is not equal to 10"
   If Not numeric_value2 = 25 Then Print "Numeric_Value2 is not equal to 25"

   ' This will output "Numeric_Value1 is not equal to 10" because
   ' the first IF statement is false.
   ' It will not output the result of the second IF statement because the
   ' condition is true. 

Dialect Differences
   * In the -lang qb dialect, this operator cannot be overloaded.

Differences from QB
   * None

See also
   * Operator Truth Tables



-------------------------------------------------------------- KeyPgNow ----
Now

Gets the current system time as a Date Serial 

Syntax
   Declare Function Now ( ) As Double

Usage
   #include "vbcompat.bi"
   result = Now

Return Value
   Returns a date serial containing the system's date and time at execution 
   time.

Description
   As the time is the decimal part of a date serial, if the value of Now is 
   saved to an integer, the time in it will be reset to 00:00:00

   The compiler will not recognize this function unless vbcompat.bi is 
   included.

Example
   #include "vbcompat.bi"

   Dim a As Double = Now()

   Print Format(a, "yyyy/mm/dd hh:mm:ss") 

Differences from QB
   * Did not exist in QB. This function appeared in PDS and VBDOS

See also
   * Date Serials




============================================================================
    O

----------------------------------------------------------- KeyPgObject ----
Object

Built-in type providing run-time type information

Syntax
   Type Object
      As fb_BaseVT Ptr vtable_ptr
      Declare Constructor()
   End Type

Usage
   Type typename Extends Object
   End Type

   Dim variable As Object

Description
   Object is a built-in type which provides Run-Time Type Information 
   (RTTI) for all types derived from it using Extends, allowing them to be 
   used with Operator Is, and to support Virtual and Abstract methods.

   Extending the built-in Object type allows to add an extra hidden vtable 
   pointer field at the top of the Type. The vtable is used to dispatch 
   Virtual  and Abstract methods and to access information for run-time 
   type identification used by Operator Is.

Example
   See the Operator Is page, the Virtual and Abstract pages.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Object.

Differences from QB
   * New to FreeBASIC

See also
   * Extends
   * Extends Zstring
   * Extends Wstring
   * Operator Is
   * Virtual
   * Abstract



-------------------------------------------------------------- KeyPgOct ----
Oct

Converts a number to octal representation

Syntax
   Declare Function Oct ( ByVal number As UByte ) As String
   Declare Function Oct ( ByVal number As UShort ) As String
   Declare Function Oct ( ByVal number As ULong ) As String
   Declare Function Oct ( ByVal number As ULongInt ) As String
   Declare Function Oct ( ByVal number As Const Any Ptr ) As String

   Declare Function Oct ( ByVal number As UByte, ByVal digits As Long ) As 
   String
   Declare Function Oct ( ByVal number As UShort, ByVal digits As Long ) As 
   String
   Declare Function Oct ( ByVal number As ULong, ByVal digits As Long ) As 
   String
   Declare Function Oct ( ByVal number As ULongInt, ByVal digits As Long ) 
   As String
   Declare Function Oct ( ByVal number As Const Any Ptr, ByVal digits As 
   Long ) As String

Usage
   result = Oct[$]( number [, digits ] )

Parameters
   number
      A number or expression evaluating to a number.  A floating-point 
      number will be converted to a LongInt.
   digits
      Desired number of digits in the returned string.

Return Value
   A string containing the unsigned octal representation of number.

Description
   Returns the unsigned octal string representation of number. Octal digits 
   range from 0 to 7.

   If you specify digits > 0, the result string will be exactly that 
   length.  It will be truncated or padded with zeros on the left, if 
   necessary.

   The length of the returned string will not be longer than the maximum 
   number of digits required for the type of number (3 characters for Byte, 
   6 for Short, 11 for Long, and 22 for LongInt)

   If you want to do the opposite, i.e. convert an octal string back into a 
   number, the easiest way to do it is to prepend the string with "&O", and 
   convert it to an integer type, using a function like CInt, similarly to 
   a normal numeric string.  E.g. CInt("&O77")

Example
   Print Oct(54321)
   Print Oct(54321, 4)
   Print Oct(54321, 8)

   will produce the output:

   152061
   2061
   00152061

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * In QBASIC, there was no way to specify the number of digits returned.
   * The size of the string returned was limited to 32 bits, or 11 octal 
     digits.

See also
   * Bin
   * Hex
   * ValInt
   * ValLng



--------------------------------------------------------- KeyPgOffsetof ----
OffsetOf

Returns the offset of a field within a type.

Syntax
   #define OffsetOf(typename, fieldname) CInt( @Cast( typename Ptr, 0 )->
   fieldname )	

Usage
   result = OffsetOf( typename, fieldname )

Parameters
   typename
      Name of the type as defined using the Type...End Type statements.
   fieldname
      Name of the field as defined within the type (or within the base 
      types for a derived type).

Description
   For a non-derived type, OffsetOf will return the location fieldname as 
   offset in bytes from the beginning of typename.

   For a derived type, OffsetOf will return the location fieldname as 
   offset in bytes from the beginning of its highest base type.
   Note: if a member of the base type is overridden by a new member, the 
   offset of the old member cannot be accessed from the derived type.

Example
   Type MyType
     x As Single
     y As Single
     Union
      b As Byte
      i As Integer
     End Union
   End Type

   Print "OffsetOf x = "; OffsetOf(MyType, x)
   Print "OffsetOf y = "; OffsetOf(MyType, y)
   Print "OffsetOf b = "; OffsetOf(MyType, b)
   Print "OffsetOf i = "; OffsetOf(MyType, i)

Output
   OffsetOf x =  0
   OffsetOf y =  4
   OffsetOf b =  8
   OffsetOf i =  8

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Offsetof.

Differences from QB
   * New to FreeBASIC

See also
   * Type...End Type
   * SizeOf



---------------------------------------------------------- KeyPgOnerror ----
On Error

Error handling statement to set the current error handler

Syntax
   On [Local] Error Goto label

Parameters
   label
      Label to jump to when an error occurs

Description
   On Error triggers a jump to an error handler when an error occurs. Such 
   errors can be triggered by built-in statements such as Open, or when the 
   Error statement is used.

   Note: The error checking for built-in statements is only enabled if the 
   program is compiled with one of the -e, -ex or -exx options. On Error 
   remains working with Error even when none of these options are used.

   On Local Error can be used to specify a local error handler inside a 
   procedure. This allows for specialized per-procedure error handling and 
   will override the global error handler, if any. Without Local, the 
   handler must be in the main part of the module.
   Remark: Presently, the Local clause is ignored by the compiler.

   On Error Goto 0 deactivates the current error handler.

Example
   '' Compile with QB (-lang qb) dialect

   '$lang: "qb"

   On Error Goto errorhandler
   Error 24 '' simulate an error
   Print "this message will not be seen"

   errorhandler:
   n = Err
   Print "Error #"; n; "!"
   End

   '' compile as: fbc onerror.bas -ex

   #lang "fblite"

   Function hFileExists( filename As String ) As Integer Static
      Dim f As Integer

      hFileExists = 0

      On Local Error Goto exitfunction

      f = FreeFile
      Open filename For Input As #f
      
      Close #f

      hFileExists = -1

   exitfunction:
      Exit Function
   End Function

      Print "File exists (0=false): "; hFileExists( Command )

      On Error Goto errhandler
      Error 1234
      Print "back from resume next"
      End 0

   errhandler:
      Print "error number: " + Str( Err ) + " at line: " + Str( Erl )
      Resume Next

Differences from QB
   * QB has no LOCAL clause and requires the label to be in the main part 
     of the module. 

See also
   * Error
   * Local
   * Err
   * Runtime Error Codes
   * Error Handling
   * Labels



---------------------------------------------------------- KeyPgOngosub ----
On...Gosub

Calls a label based on an expression

Syntax
   On expression GoSub label1[, ...]

Description
   Branches to different labels depending on the value of expression. An 
   expression value of 1 will branch to the first label, a value of 2 to 
   the second, etc.  If the value of expression is zero (0) or greater than 
   the number of items in the list, execution continues on the next 
   statement following the On...Gosub.

   This statement behaves exactly like GoSub and execution may return to 
   the statement following the On...Gosub using Return.

   It is recommended that the structured Select Case conditional statement 
   be used instead of On...Gosub.

Example
   '' Compile with -lang qb

   '$lang: "qb"

   choice = 3
   On choice GoSub labela, labelb, labelc
   Print "Good bye."
   End

   labela:
   Print "choice a"
   Return

   labelb:
   Print "choice b"
   Return

   labelc:
   Print "choice c"
   Return

Dialect Differences
   * Only available in the -lang qb and -lang fblite dialects.
   * On Gosub support is disabled by default in the -lang fblite unless 
     the Option Gosub statement is used.

Differences from QB
   * FreeBASIC does not generate a run-time error if expression is 
     negative or greater than 255.

See also
   * Select Case
   * On...Goto
   * GoSub
   * Return (From Gosub)
   * Option Gosub
   * Labels



----------------------------------------------------------- KeyPgOngoto ----
On...Goto

Jumps to a label based on an expression.

Syntax
   On expression Goto label1[, ...]

Description
   Branches to different labels depending on the value of expression. An 
   expression value of 1 will branch to the first label, a value of 2 to 
   the second, etc.  If the value of expression is zero (0) or greater than 
   the number of items in the list, execution continues on the next 
   statement following the On...Goto.

   It is recommended that the structured Select Case conditional statement 
   be used instead of On...Goto.

Example
   Dim choice As Integer

   Input "Enter a number: ", choice

   On choice Goto labela, labelb, labelc

   labela:
   Print "choice a"
   End

   labelb:
   Print "choice b"
   End

   labelc:
   Print "choice c"
   End

Differences from QB
   * FreeBASIC does not generate a run-time error if expression is 
     negative or greater than 255.

See also
   * Select Case
   * On...Gosub
   * Goto
   * Labels



---------------------------------------------------------- KeyPgInclude ----
#include

Preprocessor statement to include contents of another source file

Syntax
   #include [once] "file"

Description
   #include inserts source code from another file at the point where the 
   #include directive appears.  This has the effect of compiling the source 
   code from the include file as though it were part of the source file 
   that includes it.  Once the compiler has reached the end of the include 
   file, the original source file continues to be compiled.

   This is useful to remove code from a file and separate it into more 
   files. It is useful to have a single file with declarations in a program 
   formed by several modules. You may include files within an include file, 
   although avoid including the original file into itself, this will not 
   produce valid results. Typically, include files will have an extension 
   of .bi and are mainly used for declaring subs/functions/variables of a 
   library, but any valid source code may be present in an include file.

   The Once specifier tells the compiler to include the file only once even 
   if it is included several times by the source code.

   $Include is an alternative form of include, existing only for 
   compatibility with QuickBASIC. It is recommended to use #include 
   instead.

   The compiler will automatically convert path separator characters ( '/' 
   and '\' ) as needed to properly load the file.  The filename name may be 
   an absolute or relative path.  

   For relative paths, or where no path is given at all, the include file 
   is search for in the following order:
   * Relative from the directory of the source file
   * Relative from the current working directory
   * Relative from addition directories specified with the -i command line 
     option
   * The include folder of the FreeBASIC installation (FreeBASIC\inc, 
     where FreeBASIC is the folder where the fbc executable is located)

Example
   ' header.bi file
   Type FooType
      Bar As Byte
      Barbeque As Byte 
   End Type

   ' main.bas file
   #include "header.bi"

   Dim Foo As FooType

   Foo.Bar = 1
   Foo.Barbeque = 2

Differences from QB
   * New to FreeBASIC

See also
   * #define
   * #inclib
   * Compiler Option: -i
   * Compiler Option: -include



------------------------------------------------------------- KeyPgOpen ----
Open

Opens a disk file for reading or writing using file operations

Syntax
   Open filename For Input [encoding_type] [lock_type] As [#]filenumber
   Open filename For Output [encoding_type] [lock_type] As [#]filenumber
   Open filename For Append [encoding_type] [lock_type] As [#]filenumber

   Open filename For Binary [access_type] [lock_type] As [#]filenumber
   Open filename For Random [access_type] [lock_type] As [#]filenumber [Len 
   = record_length]

Usage
   result = Open( filename[,] For {Input|Output|Append}[,] As filenumber )
      or
   result = Open( filename[,] For Binary[,] Access {Read|Write}[,] As 
   filenumber )
      or
   result = Open( filename[,] For Random[,] Access {Read|Write}[,] As 
   filenumber [[,] Len =  record_length] )
      or
   Open filename For {Input|Output|Append} As filenumber
      or
   Open filename For Binary Access {Read|Write} As filenumber
      or
   Open filename For Random Access {Read|Write} As filenumber [Len =  
   record_length]

Parameters
   filename
      A string value of the name of the disk file to open. Relative file 
      paths are relative to the current directory (see CurDir).
   encoding_type
      The encoding to be used when reading or writing text, can be one of:
         * Encoding "ascii" (ASCII encoding is used, default)
         * Encoding "utf8" (8-bit Unicode encoding is used)
         * Encoding "utf16" (16-bit Unicode encoding is used)
         * Encoding "utf32" (32-bit Unicode encoding  is used)
   access_type
      The type of access requested by the calling process.
         * Access [Read] [Write] (both read and write access can be used, 
           which is the default)
   lock_type
      Imposes restrictions on disk file access from other processes 
      (threads or programs), can be either:
         * Shared (the file can be freely accessed by other processes)
         * Lock [Read] [Write] (both read and write access can be denied 
           to other processes)
   filenumber
      An available file number to bind to the disk file, which can be found 
      with FreeFile.
   record_length
      The size, in bytes, of each record read from or written to the disk 
      file. The default is 128.

Return Value
   In the first usage, Open() returns a 32 bit Long value: zero (0) on 
   success and a non-zero error code otherwise.

Description
   Opens a disk file for reading and/or writing. The file number file_num 
   is bound to the file on disk, for use in subsequent file operations, 
   such as Input # and Lock. The next available file number can be 
   retrieved with FreeFile.

   The Input, Output and Append file modes open disk files for sequential 
   text I/O, useful for reading or writing plain text files:
      * When the Input mode is specified, only reading file operations can 
        be used, like Line Input # and Get #. If the disk file does not 
        exist a runtime error will be thrown.
      * The Append mode specifies that only writing operations can be 
        used, like Print # and Put #.  Writing operations will take place 
        at the end of the disk file if it exists, preserving the existing 
        data.
      * The Output mode is like the Append mode, except that if the file 
        exists then its contents are deleted and its length reset to zero 
        before writing.

   The Input, Output and Append file modes also allow selection of a 
   character encoding to be used when reading from or writing text to the 
   disk file. ASCII or a Unicode encoding may be specified (see the 
   description of the encoding_type parameter above).

   The Binary and Random file modes open disk files for random-access 
   reading or writing of arbitrary sized binary data:
      * The Binary file mode allows reading and writing of simple data 
        type values, like Byte or LongInt, using binary read or write 
        operations, like Get #. LOC and Seek are among the procedures used 
        for reading and writing to arbitrary locations in the disk file.
      * The Random file mode is similar to Binary, except that file I/O 
        operations always use a constant data size when reading or writing.

   By default, the Binary and Random file modes allow both reading and 
   writing operations on the opened disk file, but this can be changed by 
   specifying an access type (see the description for the access_type 
   parameter above). When opening an existing file in Binary or Random file 
   mode, and with the only Write access type specified, all data in the 
   file are previously deleted at opening, before any other operation.

   For any file mode, access to the opened disk file can be restricted or 
   granted to other threads or programs by specifying a lock type (see the 
   description for the lock_type parameter above). If no lock type is 
   specified, other threads of the current program can freely open the disk 
   file (Shared), while other programs cannot (Lock Read Write). Lock and 
   Unlock can be used to temporarily restrict access to parts of a file.

   The error code returned by Open  can be checked using Err in the next 
   line. The function version of  Open returns directly the error code as a 
   32 bit Long.

Example
   ' Create a string and fill it.
   Dim buffer As String, f As Integer
   buffer = "Hello World within a file."

   ' Find the first free file number.
   f = FreeFile

   ' Open the file "file.ext" for binary usage, using the file number "f".
   Open "file.ext" For Binary As #f
   If Err>0 Then Print "Error opening the file":End

   ' Place our string inside the file, using number "f".
   Put #f, , buffer

   ' Close all open files.  
   Close

   ' End the program. (Check the file "file.ext" upon running to see the output.)
   End

   'OPEN A COM PORT
   Open Com "COM1:9600,N,8,1" As #1
   If Err>0 Then Print "The port could not be opened."

   'COM1, 9600 BAUD, NO PARITY BIT, EIGHT DATA BITS, ONE STOP BIT

   'function version of OPEN
   If Open("file.ext" For Binary Access Read As #1) = 0 Then

      Print "Successfully opened file"

      '' ...

      Close #1

   Else

      Print "Error opening file"

   End If

Platform Differences
   * Linux requires the filename case matches the real name of the file. 
     Windows and DOS are case insensitive.
   * Path separators in Linux are forward slashes /. Windows uses backward 
     slashes \ but it allows for forward slashes /.  DOS uses backward 
     slashes \.
   * On Windows, a file number used in a dynamic link library is not the 
     same as an identical file number used in the main program.  File 
     numbers can not be passed or returned and then used between a DLL and 
     an executable.
   * If you try to open a directory on Linux, the Open command will 
     succeed.

Differences from QB
   * Using MS-DOS device names to open streams or hardware devices ("LPT:"
     , "SCR:", etc.) is supported only in the -lang qb dialect; for other 
     modes FreeBASIC's new composite keywords must be used: see Open Com,  
     Open Cons,  Open Err,  Open Pipe,  Open Lpt,  Open Scrn.
   * Open can be called as a function that returns an error code.

Dialect Differences
   * The -lang qb dialect supports the old GW-BASIC-style syntax OPEN 
     mode_string, #filenumber, filename [length] with mode_string being "I" 
     for input, "O" for output, "A" for append, "R" for random, "B" for 
     binary. 

See also
   * Err (and a list of error codes)
   * Close
   * FreeFile
   * Open Cons, Open Err, Open Pipe, Open Lpt, Open Com, Open Scrn



---------------------------------------------------------- KeyPgOpenCom ----
Open Com

Opens a serial port for input and output

Syntax
   Declare Function Open Com ( byref options As String, As filenumber As 
   Long ) As Long

Usage
   result = Open Com( options[,] As[#] filenumber )

Parameters
   options
      A String containing options used in controlling the port.
   filenumber
      The file number to bind to the port.

Return Value
   Open Com() returns a 32 bit Long: a zero (0) on success and a non-zero 
   error code otherwise.

Description
   This command opens a serial port of the PC, allowing to send and receive 
   data by using the normal file commands as Print  #, Input #, Get #, ...

   The main parameter is a String that describes, at the very least, which 
   communications port to open. It has the format:

      "Comn: [ baudrate ][ , [ parity ][ , [ data_bits ][ , [ stop_bits ][ 
      , [ extended_options ]]]]]"

   where,
   n
      Com port to open. "1", "2", "3", "4", etc.  Some platforms will 
      support more serial ports depending on how the operating system is 
      configured.  Where n is not given, "COM:" will map to "COM1:", except 
      on Linux where "COM:" maps to "/dev/modem"
   baudrate
      "300" (default), "1200", ..., etc.
   parity
      "N" (none), "E" (even, default), "O" (odd), "S" (space), "M" (mark), 
      "PE" (QB-quirk: checked, even parity)
   data_bits
      "5", "6", "7" (default) or "8".
   stop_bits
      "1", "1.5" or "2". (default value depends on baud rate and data bits, 
      see table below)

            +-----------------------------------+---------------------------+
            |Condition                          |Default number of stop bits|
            |baud rate <= 110 and data bits = 5 |1.5                        |
            |baud rate <= 110 and data bits >= 6|2                          |
            |baud rate > 110                    |1                          |
            +-----------------------------------+---------------------------+

   extended_options
      Miscellaneous options. (See table below)

            +------+-------------------------------------------------------------------------------+
            |Option|Action                                                                         |
            |'CSn' |Set the CTS duration (in ms) (n>=0), 0 = turn off, default = 1000              |
            |'DSn' |Set the DSR duration (in ms) (n>=0), 0 = turn off, default = 1000              |
            |'CDn' |Set the Carrier Detect duration (in ms) (n>=0), 0 = turn off                   |
            |'OPn' |Set the 'Open Timeout' (in ms) (n>=0), 0 = turn off                            |
            |'TBn' |Set the 'Transmit Buffer' size (n>=0), 0 = default, depends on platform        |
            |'RBn' |Set the 'Receive Buffer' size (n>=0), 0 = default, depends on platform         |
            |'RS'  |Suppress RTS detection                                                         |
            |'LF'  |Communicate in ASCII mode (add LF to every CR) - Win32 doesn't support this one|
            |'ASC' |same as 'LF'                                                                   |
            |'BIN' |The opposite of LF and it'll always work                                       |
            |'PE'  |Enable 'Parity' check                                                          |
            |'DT'  |Keep DTR enabled after CLOSE                                                   |
            |'FE'  |Discard invalid character on error                                             |
            |'ME'  |Ignore all errors                                                              |
            |'IRn' |IRQ number for COM (only supported (?) on DOS)                                 |
            +------+-------------------------------------------------------------------------------+

   All items except for the COM port are optional. The order of baudrate, 
   parity, data_bits, stop_bits is fixed. Any skipped fixed item ( baudrate
   , etc...) must be empty.

   The error code returned by Open Com can be checked using Err in the next 
   line. The function version of  Open Com returns directly the error code 
   as a 32 bit Long.

Example
   Open Com "COM1:9600,N,,2" As 1

   Opens COM1 with 9600 baud, no parity, 7 data bits and 2 stop bits.

   Open Com "COM1:115200" As 1

   Opens COM1 with 115200 baud, "even" parity, 7 data bits and 1 stop bits. 
   

Platform Differences
   * On the Windows platform 
      "COM:" maps to "COM1:"
      baud rate must be an unsigned 32-bit integer, and is passed on 
      directly to the operating system.
   * On the Linux platform
      "COM:" maps to "/dev/modem"
      "COM1:" maps to "/dev/ttyS0"
      "COM2:" maps to "/dev/ttyS1", etc 
      "/dev/xyz:" maps to "/dev/xyz", etc
      baud rate must be one of 50, 150, 300, 600, 1200, 1800, 2400, 4800, 
      9600, 19200, 38400, 57600, 115200, 230400, 460800, 500000, 576000, 
      921600, 1000000, 1152000
      in fbc >= 1.09.0, baud rate can also be one of 1500000, 2000000, 
      2500000, 3000000, 3500000, 4000000
      the baud rates supported depend on the system where the fbc compiler 
      itself was compiled and built
   * The DOS serial driver is experimental and can access COM ports 1 to 4 
     
      It uses the following base io and IRQ's as default: 
      COM1 - &h3f8 - IRQ4 
      COM2 - &h2f8 - IRQ3 
      COM3 - &h3e8 - IRQ4 
      COM4 - &h2e8 - IRQ3 
      An alternate IRQ can be specified using the the "IRn" protocol option 
      where n is 3 through 7.
      Currently not supported: IRQ's on the slave PIC, alternate base I/O 
      addresses, Timeouts and most errors as detected in QB, hardware flow 
      control, FIFO's.
      "COM:" maps to "COM1:"
      baud rate must be between 50 and 115200
Dialect Differences
   * In the -lang qb dialect the old syntax OPEN "COMx:... is supported. 

Differences from QB
   * In QB the syntax was OPEN  "COMx:[baudrate] [,parity, [data_bits, 
     [stop_bits, [extended_options]]]]"  FOR INPUT|OUTPUT|RANDOM AS [#] n
   * In QB, only "COM1:" and "COM2:" are supported.  In FreeBASIC, any 
     correctly configured serial port may be used.

See also
   * Open



--------------------------------------------------------- KeyPgOpenCons ----
Open Cons

Opens the console's standard input (stdin) or output (stdout) streams for 
use in file operations.

Syntax
   Open Cons As [#]filenumber
   Open Cons For Input As [#]filenumber
   Open Cons For Output As [#]filenumber

Usage
   result = Open Cons( [For {Input|Output}[,]] As filenumber )
      (or using the QB-like syntax,)
   Open Cons [For {Input|Output}] As filenumber

Parameters
   filenumber
      An available file number to bind to the stdin or stdout stream, which 
      can be found with FreeFile.

Return Value
   In the first usage, Open Cons() returns a 32 bit Long: a zero (0) on 
   success and a non-zero error code otherwise.

Description
   Open Cons opens the console's stdin or stdout streams for reading or 
   writing. A file number is bound to the stream, which is used in 
   subsequent file operations, such as Input #. An available file number 
   can be retrieved with FreeFile.

   The Input file mode opens the stdin stream for reading file operations, 
   such as Line Input #, while the Output file mode opens the stdout stream 
   for writing file operations, such as Print #. The Output file mode is 
   the default if not specified.

   The stdin and stdout streams are the ones used when the calling process' 
   input or output is redirected (piped) by OS commands, or when it is 
   opened with Open Pipe.

   To open both the stdin and stdout streams for file operations, a process 
   must use multiple file numbers.

   The error code returned by Open Cons can be checked using Err in the 
   next line. The function version of  Open Cons returns directly the error 
   code as a 32 bit Long.

   Warning: Presently, Open Cons does not work as described above. Without 
   any file mode specifier, a runtime error 1 (illegal function call) 
   occurs. With the Input file mode specifier, the only input mode is well 
   supported. But with the Output file mode specifier, input and output 
   modes are simultaneously supported.

Runtime errors:
   Open Cons throws one of the following runtime errors:

   (1) Illegal function call
      * filenumber was not free at the time. use FreeFile to ensure that 
        filenumber is free.

Example
   Dim a As String

   Open Cons For Input As #1
   Open Cons For Output As #2

   Print #2,"Please write something and press ENTER"
   Line Input #1,a
   Print #2, "You wrote : ";a

   Close
   Sleep

Differences from QB
   * In QB the syntax was OPEN "CON:" FOR INPUT|OUTPUT AS [#] filenumber

See also
   * Open
   * Open Scrn
   * Open Err
   * FreeFile



---------------------------------------------------------- KeyPgOpenErr ----
Open Err

Opens both the standard input (stdin) and standard error (stderr) streams 
for file operations.

Syntax
   Open Err [for mode] As [#]filenumber As Long

Usage
   Open Err [for mode] as [#]filenumber
      or
   result = Open Err( [for mode[,]] as [#]filenumber )

Parameters
   mode
      Ignored.
   filenumber
      An unused file number.

Return Value
   A 32 bit Long: a zero is returned if Open Err() completed successfully, 
   otherwise a non-zero value is returned to indicate failure.

Description
   This command opens stdin to read from and stderr to write to the console 
   allowing read and write operations with normal file commands.

   stderr is an output stream different from stdout allowing error messages 
   to be redirected separately from the main console output.

   The normal console commands, such as Color and Locate, do not work in 
   this mode, because they do not accept a file number.

   The [For Input|Output] mode is allowed for compatibility, but is 
   ignored.

   The error code returned by Open Err can be checked using Err in the next 
   line. The function version of  Open Err returns directly the error code 
   as a 32 bit Long.

Runtime errors:
   Open Err throws one of the following runtime errors:

   (1) Illegal function call
      * Filenumber was not free at the time. use FreeFile to ensure that 
        filenumber is free.

Example
   Dim a As String
   Open Err For Input  As #1
   Print #1,"Please write something and press ENTER"
   Line Input #1, a 
   Print #1, "You wrote"; a
   Close
   Sleep

Differences from QB
   * New to FreeBASIC

See also
   * Open



---------------------------------------------------------- KeyPgOpenLpt ----
Open Lpt

Open a printer device

Syntax
   Open Lpt ["[LPT[x]:][Printer_Name][,TITLE=Doc_Title][,EMU=TTY]"] [For 
   Input|Output] As #filenumber

Usage
   Open Lpt "LPT..." As [#]filenumber
      or
   result = Open Lpt( "LPT..."[,] As [#]filenumber )

Parameters
   x
      Specifies a port number.  If omitted, output is sent to the system 
      print spooler.
   Printer_Name
      Name of printer to open.  This parameter is ignored on DOS.
   TITLE=Doc_Title
      Title of the print job as seen by the printer spooler.  This 
      parameter is ignored on DOS.
   EMU=TTY
      Emulation of TTY output on a windows GDI printer, using driver text 
      imaging.  This parameter is ignored on DOS and Linux.
   For Input|Output
      clause is allowed for compatibility, but it is ignored.
   filenumber
      An unused file number to assign to the device.

Return Value
   A 32 bit Long: 0 is returned if Open Lpt() completed successfully, 
   otherwise a non-zero value is returned to indicate failure.

Description
   Open Lpt opens a connection to a printer device.  The connection is 
   treated like a file, so data may be written to the printer using Print 
   and Put # commands.  

   Any printer attached to the system may be opened with Open Lpt

   Open Lpt "LPT:" ... will try to open the default printer on Windows and 
   Linux, and "LPT1:" on DOS.

   LPrint will automatically try to open the default printer on Windows and 
   Linux, and "LPT1:" on DOS.

   The error code returned by Open Lpt can be checked using Err in the next 
   line. The function version of  Open Lpt returns directly the error code 
   as a 32 bit Long.

Platform specific notes:

   Windows
      The argument EMU=TTY assumes printable ASCII or Unicode text, and 
      applies printer driver text imaging to the input.  EMU=TTY also 
      allows the usage of CR, LF, BS, TAB, FF, etc., for virtual print-head 
      movement...even when the printer is a GDI printer and therefore 
      doesn't itself understand these special characters.  If ",EMU=TTY" is 
      omitted, the data must be sent in the printer's language (ESC/P, 
      HPGL, PostScript, etc...).  Other useful emulation modes aren't 
      supported yet.

   Linux
      A printer spooler available through lp must be installed to access 
      printers by name or a default printer.  Spooler access was tested 
      only with CUPS, but other spoolers may work that are invoked through 
      lp.  Port are zero-based on Linux. "LPT1:" corresponds with 
      "/dev/lp0".

      The data must be sent in the printer's language (ESC/P, HPGL, 
      PostScript, etc...). Emulation modes aren't supported yet.

   DOS
      FreeBASIC does not support print spoolers on DOS.  Printers must be 
      accessible through "LPTx:".

      The data must be sent in the printer's language (ESC/P, HPGL, 
      PostScript, etc...).  Emulation modes aren't supported yet.

Example
   ' Send some text to the Windows printer on LPT1:, using driver text imaging.
   Open Lpt "LPT1:EMU=TTY" For Output  As #1
   Print #1, "Testing!" 
   Close

   ' Sends contents of text file test.txt to Windows printer named "ReceiptPrinter"
   Dim RptInput As String
   Dim PrintFileNum As Integer, RptFileFileNum As Integer

   RptFileFileNum = FreeFile
   Open "test.txt" For Input As #RptFileFileNum

   PrintFileNum = FreeFile
   Open Lpt "LPT:ReceiptPrinter,TITLE=ReceiptWinTitle,EMU=TTY" As _
      #PrintFilenum

   While (EOF(RptFileFileNum) = 0)
         Line Input #RptFileFileNum, RptInput
         Print #PrintFileNum, RptInput
   Wend

   Close #PrintFileNum  ' Interestingly, does not require CHR(12).  But if pagination is desired, CHR(12) is the way.

   Close #RptFileFileNum

   Print "Press any key to end program..."
   GetKey

   End

   'This simple program will print a PostScript file to a PostScript compatible printer.
   Dim As UByte FFI, PPO
   Dim As String temp

   FFI = FreeFile()
   Open "sample.ps" For Input Access Read As #FFI
   PPO = FreeFile()
   Open Lpt "LPT1:" For Output As #PPO
   While (EOF(FFI) = 0)
   Line Input #FFI, temp
   Print #PPO, temp
   Wend

   Close #FFI
   Close #PPO

   Print "Printing Completed!"

Dialect Differences
   * In the -lang qb dialect the old syntax is supported OPEN "LPT:..." . 
     This syntax used in the other dialects will open a regular file.

See also
   * Open
   * LPrint



--------------------------------------------------------- KeyPgOpenPipe ----
Open Pipe

Opens an external process' standard input (stdin) or output (stdout) stream 
for file operations.

Syntax
   Open Pipe shell_command For Input As [#]filenumber
   Open Pipe shell_command For Output As [#]filenumber
   Open Pipe shell_command For Binary access_type [#]filenumber

Usage
   result = Open Pipe( command[,] For {Input|Output}[,] As filenumber )
      or,
   result = Open Pipe( command[,] For Binary[,] access_type[,] As 
   filenumber )
      (or in the QB-like syntax,)
   Open Pipe filename For {Input|Output} As filenumber
      (or,)
   Open Pipe filename For Binary access_type As filenumber

Parameters
   shell_command
      The external process to execute in the operating system command 
      shell. Relative file paths are relative to the current directory (see 
      CurDir).  When opening a pipe for a process that requires double 
      quotes in either its executable path, or its arguments, the entire 
      pipe string should be nested inside of double quotes.
   access_type
      The type of read or write access requested by the calling process.
         * Access {Read|Write} (either the stdin or stdout stream of the 
           external process can be opened)
   filenumber
      An available file number to bind to the external process' stdin or 
      stdout stream.

Return Value
   In the first usage, Open Pipe() returns a 32 bit Long: a zero (0) on 
   success and a non-zero error code otherwise.

Description
   Open Pipe executes another process in the command shell and opens either 
   its stdin or stdout streams for reading or writing. A file number is 
   bound to the stream, which is used in subsequent file operations, such 
   as Input #. An available filenumber can be retrieved with FreeFile. If 
   the external process does not exist, a runtime error is thrown.

   The Input and Output file modes open the external process' stdin and 
   stdout streams, respectively, for sequential text I/O, useful for 
   reading or writing plain text. Characters, words or whole lines can then 
   be read or written using text-mode file operations, such as Line Input # 
   and Print #.

   The Binary file mode opens the external process' stdin or stdout streams 
   - depending on the access type specified (see description of the 
   access_type parameter above) - for random-access reading or writing of 
   arbitrarily sized and interpreted raw data. Simple data type values, 
   like Byte and LongInt, and whole chunks of memory can be read from or 
   written to the streams with binary-mode file operations like Get # and 
   Put #.
   Bidirectional pipes are not supported by FB and must be implemented 
   using the OS' API functions.

   The error code returned by Open Pipe can be checked using Err in the 
   next line. The function version of  Open Pipe returns directly the error 
   code as a 32 bit Long.

Runtime errors:
   Open Pipe throws one of the following runtime errors:

   (1) Illegal function call
      * filenumber was not free at the time. use FreeFile to ensure that 
        filenumber is free.

Example
   '' This example uses Open Pipe to run a shell command and retrieve its output. 
   #ifdef __FB_UNIX__
   Const TEST_COMMAND = "ls *"
   #else
   Const TEST_COMMAND = "dir *.*"
   #endif

   Open Pipe TEST_COMMAND For Input As #1

   Dim As String ln
   Do Until EOF(1)
      Line Input #1, ln
      Print ln
   Loop

   Close #1

Platform Differences
   * The Binary file mode is not supported on all platforms; Open Pipe 
     will throw an error if it is unable to open the external process' 
     stdin or stdout streams in binary mode.

Differences from QB
   * New to FreeBASIC

See also
   * Shell
   * Open
   * Open Cons
   * Open Err
   * FreeFile



--------------------------------------------------------- KeyPgOpenScrn ----
Open Scrn

Opens the console directly for input and output as a file

Syntax
   Open Scrn [for mode] As [#]filenumber As Long

Usage
   Open Scrn [for mode] as [#]filenumber
      or
   result = Open Scrn( [for mode[,]] as [#]filenumber )

Parameters
   mode
      Either Input or Output.  If omitted, Output is assumed.
   filenumber
      An unused file number.

Return Value
   A 32 bit Long: a zero (0) is returned if Open Scrn() completed 
   successfully, otherwise a non-zero value is returned to indicate 
   failure.

Description
   This command opens the console for both input and output as a file, 
   allowing to read/write from/to it with normal file commands.

   This command may use direct access to the console for speed in some 
   implementations, so  it should not be used when the input / output is 
   required to be redirected or piped with OS commands.    

   The normal console commands, such as Color and Locate, do not work in 
   this mode, because they do not accept a file number.

   The [For Input|Output] clause is allowed for compatibility, but is 
   ignored.

   filenumber is an unused file number.

   An unused file number can be found using FreeFile.

   The error code returned by Open Scrn can be checked using Err in the 
   next line. The function version of  Open Scrn returns directly the error 
   code as a 32 bit Long.

Runtime errors:
   Open Scrn throws one of the following runtime errors:

   (1) Illegal function call
      * filenumber was not free at the time. use FreeFile to ensure that 
        filenumber is free.	

Example
   Dim a As String
   Open Scrn For Input  As #1
   Print #1,"Please write something and press ENTER"
   Line Input #1,a
   Print #1, "You wrote";a
   Close
   Sleep

Differences from QB
   * QB used OPEN "SCRN:" ...

See also
   * Open
   * Open Cons



--------------------------------------------------------- KeyPgOperator ----
Operator

Declares or defines an overloaded operator.

Syntax
   { Type | Class | Union } typename
      Declare Operator Cast () [ ByRef ] As datatype
      Declare Operator @ () [ ByRef ] As datatype Ptr
      Declare Operator assignment_op ( [ ByRef | ByVal ] rhs As datatype )
      Declare Operator [] ( index As datatype ) [ ByRef ] As datatype
      Declare Operator New ( size As UInteger ) As Any Ptr
      Declare Operator New[] ( size As UInteger ) As Any Ptr
      Declare Operator Delete ( buf  As Any Ptr )
      Declare Operator Delete[] ( buf  As Any Ptr )
   End { Type | Class | Union }

   { Type | Class | Union } typename
      Declare Operator For ()
      Declare Operator For ( [ ByRef | ByVal ] stp As typename )
      Declare Operator Step ()
      Declare Operator Step ( [ ByRef | ByVal ] stp As typename )
      Declare Operator Next ( [ ByRef | ByVal ] cond As typename ) As 
      Integer
      Declare Operator Next ( [ ByRef | ByVal ] cond As typename, [ ByRef | 
      ByVal ] stp As typename ) As Integer
   End { Type | Class | Union }

   Declare Operator unary_op ( [ ByRef | ByVal ] rhs As datatype ) As 
   datatype
   Declare Operator binary_op ( [ ByRef | ByVal ] lhs As datatype, [ ByRef 
   | ByVal ] rhs As datatype ) As datatype

   Operator typename.Cast () [ ByRef ] As datatype [ Export ]
   Operator typename.@ () [ ByRef ] As datatype Ptr [ Export ]
   Operator typename.assignment_op ( [ ByRef | ByVal ] rhs As datatype ) [ 
   Export ]
   Operator typename.[] ( index As datatype ) [ ByRef ] As datatype [ Export
   ]
   Operator unary_op ( [ ByRef | ByVal ] rhs As datatype ) As datatype [ 
   Export ]
   Operator binary_op ( [ ByRef | ByVal ] lhs As datatype, [ ByRef | ByVal 
   ] rhs As datatype ) As datatype [ Export ]
   Operator typename.New ( size as uinteger ) As Any Ptr [ Export ]
   Operator typename.New[] ( size As UInteger ) As Any Ptr [ Export ]
   Operator typename.Delete ( buf  As Any Ptr ) [ Export ]
   Operator typename.Delete[] ( buf  As Any Ptr ) [ Export ]

Parameters
   typename 
      Name of the Type, Class, Union, or Enum.
   assignment_op 
      let += -= *= &= /= \= mod= shl= shr= and= or= xor= imp= eqv= ^=
   unary_op
      - not * -> abs sgn fix frac int exp log sin asin cos acos tan atn len 
      sqr
   binary_op
      + - * & / \ mod shl shr and or xor imp eqv ^ = <> < > <= >=

Description
   The built in operators like =, +, and cast have predefined behaviors 
   when used in expressions.  These operators can be overloaded to do 
   something other than predefined operations when at least one of the 
   arguments to the operator is a Type, Class, Enum, or Union data type.

   Operators are just functions.  The operator '+' has functionality like 
   Function Plus( A as DataType, B as DataType ) as DataType.  See 
   Operator Overloading for more information.  Operators can be overloaded 
   to accept different data types as parameters.  The Cast Operator is the 
   only operator (or function) that can be declared multiple times when 
   only the return type differs, but not the same as the Type, Class, or 
   Union it is declared in (for not explicit usage, the compiler may decide 
   which cast overload to call based on how the object is used).

   Non-static operator members are declared inside the Type, Class, or Union
   .  Global operators are declared outside.  All operator definitions 
   (procedure bodies) must appear outside.

   Let, Cast, and other assignment operators must be declared inside the 
   Type, Class, or Union.  As all non-static member procedures, they have 
   passed a hidden This parameter.

   Unary operators must be declared outside the Type, Class, or Union and 
   have a return data type explicitly declared.  Unary operators can be 
   overloaded to return any valid data type, except for 
   Operator -> (Pointer To Member Access) which must return a Type, Class, 
   or Union data type.

   Binary operators must be declared outside the Type, Class, or Union and 
   have a return data type explicitly declared.  Binary operators can be 
   overloaded with valid data types, including for relational operators, 
   which can also return any valid data type.

   Let refers to the assignment operator, as in LET a=b. The Let keyword is 
   omitted in common practice, and is not allowed in the -lang fb dialect.  
   However, Let() can be used to assign the fields of a UDT to multiple 
   variables.

   See For, Step, and Next for more information on overloading the For..Next
   statement for use with user defined types.

   Although declared inside the Type, Class, or Union, the member operators 
   New, New[], Delete, and Delete[] are always static, even if not 
   explicitly declared (Static keyword is unnecessary but allowed).

Example
   '' operator1.bas

   Type Vector2D
     As Single x, y

     '' Return a string containing the vector data.
     Declare Operator Cast() As String

     '' Multiply the vector by a scalar.
     Declare Operator *= ( ByVal rhs As Single )
   End Type

   '' Allow two vectors to be able to be added together.
   Declare Operator + ( ByRef lhs As Vector2D, ByRef rhs As Vector2D ) As Vector2D

   '' Return the modulus (single) of the vector using the overloaded operator abs().
   Declare Operator Abs (  ByRef rhs As Vector2D ) As Single

   Operator Vector2D.cast () As String
     Return "(" + Str(x) + ", " + Str(y) + ")"
   End Operator

   Operator Vector2D.*= ( ByVal rhs As Single )
     This.x *= rhs
     This.y *= rhs
   End Operator

   Operator + ( ByRef lhs As Vector2D, ByRef rhs As Vector2D ) As Vector2D
     Return Type<Vector2D>( lhs.x + rhs.x, lhs.y + rhs.y )
   End Operator

   Operator Abs ( ByRef rhs As Vector2D ) As Single
     Return Sqr( rhs.x * rhs.x + rhs.y * rhs.y )
   End Operator

   Dim a As Vector2D = Type<Vector2D>( 1.2, 3.4 )
   Dim b As Vector2D = Type<Vector2D>( 8.9, 6.7 )
   Dim c As Vector2D = Type<Vector2D>( 4.3, 5.6 )

   Print "a = "; a, "abs(a) ="; Abs( a )
   Print "b = "; b, "abs(b) ="; Abs( b )
   Print "a + b = "; a + b, "abs(a+b) ="; Abs( a + b )
   Print "c = "; c, "abs(c) ="; Abs( c )
   Print "'c *= 3'"
   c *= 3
   Print "c = "; c, "abs(c) ="; Abs( c )

   Small use case of the operator "[]": simplest smart pointers for byte 
   buffers.
   '' operator3.bas

   '' A smart pointer is an object which behaves like a pointer but does more than a pointer:
   '' - This object is flexible as a pointer and has the advantage of being an object,
   ''   like constructor and destructor called automatically.
   '' - Therefore, the destructor of the smart pointer will be automatically called
   ''   when this object goes out of scope, and it will delete the user pointer.

   '' Example of simplest smart pointers for byte buffers:
   '' - Constructor and destructor allow to allocate, deallocate, and resize the byte buffer.
   '' - Pointer index operator allows to access buffer elements.
   '' - Copy-constructor and let-operator are just declared in private section,
   ''   in order to disallow copy construction and any assignment.

   Type smartByteBuffer
     Public:
      Declare Constructor (ByVal size As UInteger = 0)
      Declare Operator [] (ByVal index As UInteger) ByRef As Byte
      Declare Destructor ()
     Private:
      Declare Constructor (ByRef rhs As smartByteBuffer)
      Declare Operator Let (ByRef rhs As smartByteBuffer)
      Dim As Byte Ptr psbb
   End Type

   Constructor smartByteBuffer (ByVal size As UInteger = 0)
     This.destructor()
     If size > 0 Then
      This.psbb = New Byte[size]
      Print "Byte buffer allocated"
     End If
   End Constructor

   Operator smartByteBuffer.[] (ByVal index As UInteger) ByRef As Byte
     Return This.psbb[index]
   End Operator

   Destructor smartByteBuffer ()
     If This.psbb > 0 Then
      Delete[] This.psbb
      This.psbb = 0
      Print "Byte buffer deallocated"
     End If
   End Destructor

   Scope
     Dim As smartByteBuffer sbb = smartByteBuffer(256)
     For I As Integer = 0 To 255
      sbb[I] = I - 128
     Next I
     Print
     For I As Integer = 0 To 255
      Print Using "#####"; sbb[I];
     Next I
     Print
   End Scope

Dialect Differences
   * Only available in the -lang fb dialect.

See also
   * Class
   * Union
   * Type
   * Coercion and Conversion



----------------------------------------------------------- KeyPgOption ----
Option()

Specifies additional attributes and/or characteristics of symbols.

Syntax
   Option( "literal-text" )

Parameters
   literal-text
      The literal text specifying the option. See description.

Description
   Option() allows the programmer to specify additional attributes or 
   characteristics.  Enclosing the string into quotes and parentheses is 
   required in the syntax.  Unrecognized options are ignored.

   Option can also be used as a statement to specify other compile time 
   options.  See Compiler Switches.

   Individual options are explained below.

SSE
   Option("SSE") indicates that a floating point value (Single or Double) 
   returned from a function is stored in the xmm0 register.  Option("Sse") 
   is ignored unless the source is compiled with the -fpu SSE command line 
   option.  This option may be used immediately after the return type in a 
   function declaration or function definition.  This option is an 
   optimization only and not required to compile programs using the -fpu SSE
   command line option.

   Declare Function ValueInXmm0 () As Double Option("sse")

FPU
   Option("FPU") indicates that a floating point value (Single or Double) 
   returned from a function is stored in the st(0) register.  This option 
   may be used immediately after the return type in a function declaration 
   or function definition.

   Declare Function ValueInStZero () As Double Option("fpu")

Differences from QB
   * New to FreeBASIC

See also
   * Compiler Option: -fpu
   * Compiler Switches



------------------------------------------------------- KeyPgOptionbase ----
Option Base

Specifies a default lower bound for array declarations

Syntax
   Option Base base_subscript

Parameters
   base_subscript
      an numeric literal value

Description
   Option Base is a statement that sets the default lower bound for any 
   following array declarations. This default remains in effect for the 
   rest of the module in which Option Base is used, and can be overridden 
   by declaring arrays with an explicit lower bound, or with another Option 
   Base statement.

   Note: initially, the default base is 0.

Example
   '' Compile with the "-lang qb" or "-lang fblite" compiler switches

   #lang "fblite"

   Dim foo(10) As Integer      ' declares an array with indices 0-10

   Option Base 5

   Dim bar(15) As Integer      ' declares an array with indices 5-15
   Dim baz(0 To 4) As Integer  ' declares an array with indices 0-4

Dialect Differences
   * Only available in the -lang fblite and -lang qb dialects.
   * In -lang fb, Option Base is not allowed, and the default lower bound 
     is always 0.

Differences from QB
   * QBASIC only supported values of 0 or 1 for base_subscript.
   * In QBASIC the word Base was a reserved keyword, and couldn't be used 
     as a variable name.
   * Arrays must always be explicitly created in FreeBASIC.  QBASIC would 
     implicitly create an array from base_subscript to 10 if one was used 
     in code without being predefined.

See also
   * Dim
   * ReDim
   * LBound



------------------------------------------------------ KeyPgOptionbyval ----
Option ByVal

Specifies parameters are to be passed by value by default in procedure 
declarations

Syntax
   Option ByVal

Description
   Option ByVal is a statement that sets the default passing convention for 
   procedure parameters to by value, as if declared with ByVal. This 
   default remains in effect for the rest of the module in which Option 
   ByVal is used, and can be overridden by specifying ByRef in parameter 
   lists.

Example
   '' compile with the "-lang fblite" compiler switch

   #lang "fblite"

   Sub TestDefaultByref( a As Integer )
     '' change the value
     a = a * 2
   End Sub

   Option ByVal

   Sub TestDefaultByval( a As Integer )
     a = a * 2
   End Sub

   Dim a As Integer = 1

   Print "a = "; a
   TestDefaultByref( a )
   Print "After TestDefaultByref : a = "; a
   Print

   Print "a = "; a
   TestDefaultByval( a )
   Print "After TestDefaultByval : a = "; a
   Print

Dialect Differences
   * Only available in the -lang fblite and -lang qb dialects.

Differences from QB
   * New to FreeBASIC

See also
   * __FB_OPTION_BYVAL__



---------------------------------------------------- KeyPgOptiondynamic ----
Option Dynamic

Specifies variable-length array declarations

Syntax
   Option Dynamic

Description
   Option Dynamic is a statement that specifies that any following array 
   declarations are variable-length, whether they are declared with 
   constant subscript ranges or not. This remains in effect for the rest of 
   the module in which Option Dynamic is used, and can be overridden with 
   Option Static.  It is equivalent to the '$Dynamic metacommand.

Example
   '' Compile with "-lang fblite" compiler switch

   #lang "fblite"

   Dim foo(99) As Integer      ' declares a fixed-length array

   Option Dynamic

   Dim bar(99) As Integer      ' declares a variable-length array
   ' ...
   ReDim bar(199)              ' resize the array

Dialect Differences
   * Only available in the -lang fblite and -lang qb dialects.

Differences from QB
   * New to FreeBASIC

See also
   * __FB_OPTION_DYNAMIC__
   * '$Dynamic
   * '$Static
   * Option Static
   * Dim
   * ReDim



----------------------------------------------------- KeyPgOptionescape ----
Option Escape

Specifies that string literals should be processed for C-like escape 
sequences by default

Syntax
   Option Escape

Description
   Option Escape is a statement that causes string literals to be processed 
   for C-like escape sequences by default. Normally, escape sequences have 
   no effect in string literals unless the string is prefixed with the  
   ! Operator (Escaped String Literal). This default remains in effect for 
   the rest of the module in which Option Escape is used, and can be 
   overridden by prefixing string literals with the 
   $ Operator (Non-Escaped String Literal).

   See Literals in the Programmer's Guide to learn more about escape 
   sequences.

Example
   '' Compile with the "-lang fblite" compiler switch

   #lang "fblite"

   Option Escape

   Print "Warning \a\t The path is:\r\n c:\\Freebasic\\Examples"
   Print $"This string doesn't have expanded escape sequences: \r\n\t"

   #include "crt.bi"

   Dim As Integer a = 2, b = 3
   printf("%d * %d = %d\r\n", a, b, a * b)

Dialect Differences
   * Only available in the -lang fblite and -lang qb dialects.

Differences from QB
   * New to FreeBASIC

See also
   * __FB_OPTION_ESCAPE__
   * Operator ! (Escaped String Literal)
   * Operator $ (Non-Escaped String Literal)
   * Literals



--------------------------------------------------- KeyPgOptionexplicit ----
Option Explicit

Forces variables, objects and arrays to be declared before they are used

Syntax
   Option Explicit

Description
   Option Explicit is a statement that forces any following variable, 
   object or array usage to be preceded by a declaration, with, for 
   example, Dim or Static. This rule remains in effect for the rest of the 
   module in which Option Explicit is used, and cannot be overridden.

Example
   '' Compile with the "-lang qb" or "-lang fblite" compiler switches

   #lang "fblite"

   Option Explicit

   Dim a As Integer            ' 'a' must be declared..
   a = 1                       ' ..or this statement will fail to compile.

   Dialect Differences
   * Only available in the -lang fblite and -lang qb dialects.

Differences from QB
   *New to FreeBASIC

See also
   * __FB_OPTION_EXPLICIT__



------------------------------------------------------ KeyPgOptiongosub ----
Option Gosub

Enables support for GoSub and On Gosub.

Syntax
   Option Gosub

Description
   Option Gosub enables support for GoSub and Return (from gosub).

   Because Return could mean return-from-gosub or return-from-procedure, 
   Option Gosub and Option Nogosub can be used to enable and disable GoSub 
   support.  When GoSub support is disabled, Return is then recognized as 
   return-from-procedure.

Example
   '' Compile with the "-lang fblite" compiler switch

   #lang "fblite"

   '' turn on gosub support
   Option GoSub

   GoSub there
   backagain:
      Print "backagain"
      End

   there:
      Print "there"
      Return

Dialect Differences
   * Only available in the -lang fblite and -lang qb dialects.

Differences from QB
   * New to FreeBASIC

See also
   * __FB_OPTION_GOSUB__
   * Option Nogosub
   * GoSub
   * Return (From Gosub)
   * Return (From Procedure)



---------------------------------------------------- KeyPgOptionnogosub ----
Option Nogosub

Disables support for GoSub and On Gosub.

Syntax
   Option Nogosub

Description
   Option Nogosub disables support for GoSub and Return (from gosub).

   Because Return could mean return-from-gosub or return-from-procedure, 
   Option Gosub and Option Nogosub can be used to enable and disable GoSub 
   support.  When GoSub support is disabled, Return is then recognized as 
   return-from-procedure.

Example
   '' Compile with the "-lang qb" compiler switch

   '$lang: "qb"

   '' turn off gosub support
   Option nogosub

   Function foo() As Integer
      Return 1234
   End Function

   Print foo

Dialect Differences
   * Only available in the -lang fblite and -lang qb dialects.

Differences from QB
   * New to FreeBASIC

See also
   * __FB_OPTION_GOSUB__
   * Option Gosub
   * GoSub
   * Return (From Procedure)
   * Return (From Gosub)



-------------------------------------------------- KeyPgOptionnokeyword ----
Option NoKeyword

"Undefines" a reserved keyword

Syntax
   Option NoKeyword keyword

Parameters
   keyword
      the keyword to undefine

Description
   Option NoKeyword is a statement that undefines a FreeBASIC reserved 
   keyword, meaning it can be used as an identifier for a variable, object, 
   procedure or any other symbol. The keyword is undefined for the rest of 
   the module in which Option NoKeyword is used.

Example
   '' Compile with the "-lang fblite" compiler switch

   #lang "fblite"

   Option NoKeyword Int        ' remove the keyword 'int' from the internal
                        ' symbol table

   Dim Int As Integer          ' declare a variable with the name 'int'

Dialect Differences
   * Only available in the -lang fblite and -lang qb dialects.

Differences from QB
   * New to FreeBASIC

See also
   * #undef



---------------------------------------------------- KeyPgOptionprivate ----
Option Private

Specifies internal linkage by default for procedure declarations

Syntax
   Option Private

Description
   Option Private is a statement that gives any following procedure 
   declarations internal linkage by default, as if declared with Private. 
   This default remains in effect for the rest of the module in which 
   Option Private is used, and can be overridden by declaring procedures 
   with Public.

Example
   '' Compile with the "-lang fblite" compiler switch

   #lang "fblite"

   Sub ProcWithExternalLinkage()
      ' ...
   End Sub

   Option Private

   Sub ProcWithInternalLinkage()
      ' ...
   End Sub

   Public Sub AnotherProcWithExternalLinkage()
      ' ...
   End Sub

Dialect Differences
   * Only available in the -lang fblite and -lang qb dialects.

Differences from QB
   * New to FreeBASIC

See also
   * __FB_OPTION_PRIVATE__
   * Private
   * Public



----------------------------------------------------- KeyPgOptionstatic ----
Option Static

Reverts to default array declaration behavior

Syntax
   Option Static

Description
   Option Static is a statement that overrides the behavior of 
   Option Dynamic, that is, arrays declared with constant subscript ranges 
   are fixed-length. This remains in effect for the rest of the module in 
   which Option Static is used, and can be overridden with Option Dynamic.  
   It is equivalent to the '$Static metacommand.

Example
   '' Compile with the "-lang fblite" compiler switch

   #lang "fblite"

   Option Dynamic

   Dim foo(100) As Integer         ' declares a variable-length array

   Option Static

   Dim bar(100) As Integer         ' declares a fixed-length array

Dialect Differences 
   * Only available in the -lang fblite and -lang qb dialects.

Differences from QB
   * New to FreeBASIC

See also
   * '$Dynamic
   * '$Static
   * Dim
   * Erase
   * ReDim
   * Option Dynamic
   * Static



------------------------------------------------------------- KeyPgOpOr ----
Operator Or (Inclusive Disjunction)

Returns the bitwise-or (inclusive disjunction) of two numeric values

Syntax
   Declare Operator Or ( ByRef lhs As T1, ByRef rhs As T2 ) As Ret

Usage
   result = lhs Or rhs

Parameters
   lhs
      The left-hand side expression.
   T1
      Any numeric or boolean type.
   rhs
      The right-hand side expression.
   T2
      Any numeric or boolean type.
   Ret
      A numeric or boolean type (varies with T1 and T2).

Return Value
   Returns the bitwise-disjunction of the two operands.

Description
   This operator returns the bitwise-disjunction of its operands, a logical 
   operation that results in a value with bits set depending on the bits of 
   the operands (for conversion of a boolean to an integer, false or true 
   boolean value becomes 0 or -1 integer value).

   The truth table below demonstrates all combinations of a 
   boolean-disjunction operation:

      +-------+-------+------+
      |Lhs Bit|Rhs Bit|Result|
      |0      |0      |0     |
      |1      |0      |1     |
      |0      |1      |1     |
      |1      |1      |1     |
      +-------+-------+------+

   No short-circuiting is performed - both expressions are always 
   evaluated.

   The return type depends on the types of values passed. Byte, UByte and 
   floating-point type values are first converted to Integer. If the left 
   and right-hand side types differ only in signedness, then the return 
   type is the same as the left-hand side type (T1), otherwise, the larger 
   of the two types is returned. Only if the left and right-hand side types 
   are both Boolean, the return type is also Boolean.

   This operator can be overloaded for user-defined types.

Example
   ' Using the OR operator on two numeric values
   Dim As UByte numeric_value1, numeric_value2
   numeric_value1 = 15 '00001111
   numeric_value2 = 30 '00011110

   'Result =  31  =     00011111       
   Print numeric_value1 Or numeric_value2
   Sleep

   ' Using the OR operator on two conditional expressions
   Dim As UByte numeric_value
   numeric_value = 10

   If numeric_value = 5 Or numeric_value = 10 Then Print "Numeric_Value equals 5 or 10"
   Sleep

   ' This will output "Numeric_Value equals 5 or 10" because
   ' while the first condition of the first IF statement is false, the second is true

Dialect Differences
   * In the -lang qb dialect, this operator cannot be overloaded.

Differences from QB
   * None

See also
   * OrElse
   * Operator Truth Tables



------------------------------------------------------------ KeyPgOrGfx ----
Or

Parameter to the Put graphics statement which uses a bit-wise Or as the 
blitting method

Syntax
   Put [ target, ] [ STEP ] ( x,y ), source [ ,( x1,y1 )-( x2,y2 ) ], Or

Parameters
   Or
      Required.

Description
   The Or method combines each source pixel with the corresponding 
   destination pixel, using the bit-wise Or function.  The result of this 
   is output as the destination pixel.
   This method works in all graphics modes.  There is no mask color, 
   although color values of 0 (RGBA(0, 0, 0, 0) in full-color modes) will 
   have no effect, because of the behavior of Or.

   In full-color modes, each component (red, green, blue and alpha) is kept 
   in a discrete set of bits, so the operation can be made to only affect 
   some of the channels, by making sure the all the values of the other 
   channels are set to 0.

Example
   ''open a graphics window
   ScreenRes 320, 200, 16

   ''create 3 sprites containing red, green and blue circles
   Const As Integer r = 32
   Dim As Any Ptr cr, cg, cb
   cr = ImageCreate(r * 2 + 1, r * 2 + 1, RGBA(0, 0, 0, 0))
   cg = ImageCreate(r * 2 + 1, r * 2 + 1, RGBA(0, 0, 0, 0))
   cb = ImageCreate(r * 2 + 1, r * 2 + 1, RGBA(0, 0, 0, 0))
   Circle cr, (r, r), r, RGB(255, 0, 0), , , 1, f
   Circle cg, (r, r), r, RGB(0, 255, 0), , , 1, f
   Circle cb, (r, r), r, RGB(0, 0, 255), , , 1, f

   ''put the sprite at three different multipier
   ''levels, overlapping each other in the middle
   Put (146 - r, 108 - r), cr, Or
   Put (174 - r, 108 - r), cg, Or
   Put (160 - r,  84 - r), cb, Or

   ''free the memory used by the sprites
   ImageDestroy cr
   ImageDestroy cg
   ImageDestroy cb

   ''pause the program before closing
   Sleep

Differences from QB
   * None

See also
   * Or
   * Put (Graphics)



--------------------------------------------------------- KeyPgOpOrElse ----
Operator Orelse (Short Circuit Inclusive Disjunction)

Returns the short circuit-or (Inclusive Disjunction) of two numeric values

Syntax
   Declare Operator OrElse ( ByRef lhs As T1, ByRef rhs As T2 ) As Ret

Usage
   result = lhs OrElse rhs

Parameters
   lhs
      The left-hand side expression.
   T1
      Any numeric or boolean type.
   rhs
      The right-hand side expression.
   T2
      Any numeric or boolean type.
   Ret
      A numeric or boolean type (varies with T1 and T2).

Return Value
   Returns the short circuit-or (inclusive disjunction) of the two 
   operands.

Description
   This operator evaluates the left hand side expression.  If the result is 
   nonzero, then -1 (true) is immediately returned.  If the result is zero 
   then the right hand side is evaluated, and the logical result from that 
   is returned, returning -1 (true) for a nonzero value or 0 (false) for 
   zero.
   (for conversion of a boolean to an integer, false or true boolean value 
   becomes 0 or -1 integer value)

   The truth table below demonstrates all combinations of a short 
   circuit-or operation, the '-' denotes that the operand is not evaluated.

      +---------+---------+------+
      |Lhs Value|Rhs Value|Result|
      |0        |0        |0     |
      |0        |nonzero  |-1    |
      |nonzero  |-        |-1    |
      +---------+---------+------+

   Short-circuiting is performed - only expressions needed to calculate the 
   result are evaluated.  The left hand side lhs is evaluated first, and 
   only if it evaluates to zero (false) is the right hand side rhs also 
   evaluated. If the left hand side evaluation lhs returns non-zero (true), 
   it is known that at that point that the overall condition is true, so 
   the right hand side rhs is not evaluated (skipped).

   The return type is almost always an Integer, of the value 0 or -1, 
   denoting false and true respectively. Except if the left and right-hand 
   side types are both Boolean, then the return type is also Boolean.

   This operator cannot be overloaded for user-defined types.

Example
   ' Using the ORELSE operator on two numeric values
   Dim As Integer numeric_value1, numeric_value2
   numeric_value1 = 15
   numeric_value2 = 30

   'Result = -1
   Print numeric_value1 OrElse numeric_value2
   Sleep

Differences from QB
   * This operator was not available in QB.

See also
   * AndAlso
   * Or
   * Operator Truth Tables



-------------------------------------------------------------- KeyPgOut ----
Out

Outputs a value to a hardware port.

Syntax
   Declare Function Out ( ByVal port As UShort , ByVal data As UByte ) As 
   Long

Usage
   Out port,value

Parameters
   port
      Hardware port to write to.
   data
      Data value to write.

Description
   This function sends value to port and returns immediately.

Example
   'speakersound.bas 
   Sub Sound(ByVal freq As UInteger, dur As UInteger)
     Dim t As Double,f1 As Unsigned Short
      f1 = 1193181 \ freq
      Out &h61,Inp(&h61) Or 3
      Out &h43,&hb6
      Out &h42,LoByte(f1)
      Out &h42,HiByte(f1)
      t=Timer 
      While ((Timer - t) * 1000) < dur
        Sleep 0,1
      Wend
      Out &h61,Inp(&h61) And &hfc
   End Sub

   Sound(523, 60)  'C5
   Sound(587, 60)  'D5
   Sound(659, 60)  'E5
   Sound(698, 60)  'F5
   Sound(784, 60)  'G5
   Sound(880, 60)  'A5
   Sound(988, 60)  'B5
   Sound(1046, 60) 'C6 

	

Platform Differences
   * In the Windows and Linux versions three port numbers (&H3C7, &H3C8, 
     &H3C9) are hooked by the graphics library when a graphics mode is in 
     use to emulate QB's VGA palette handling. This use  is deprecated; use 
     Palette to retrieve and set palette colors.

   * Using true port access in the Windows version requires the program to 
     install a device driver for the present session. For that reason, 
     Windows executables using hardware port access should be run with 
     administrator permits each time the computer is restarted. Further 
     runs don't require admin rights as they just use the already installed 
     driver. The driver is only 3K in size and is embedded in the 
     executable.

See also
   * Inp
   * Wait
   * Palette

   


----------------------------------------------------------- KeyPgOutput ----
Output

Specifies text file to be opened for output mode

Syntax
   Open filename for Output [Encoding encoding_type] [Lock lock_type] as 
   [#]filenum 

Parameters
   filename
      file name to open for output
   encoding_type
      indicates encoding type for the file
   lock_type
      locking to be used while the file is open
   filenum
      unused file number to associate with the open file

Description
   A file mode used with Open to open a text file for writing.

   This mode is used to write text with Print #, or comma separated values 
   with Write #. 

   Text files can't be simultaneously read and written in FreeBASIC, so if 
   both functions are required on the same file, it must be opened twice.

   filename must be a string expression resulting in a legal file name in 
   the target OS, without wildcards. The file will be sought for in the 
   present directory, unless the filename contains a path . If the file 
   does not exist, it is created. The pointer is set at the first character 
   of the file.

   Encoding_type indicates the Unicode Encoding of the file, so characters 
   are correctly read. If omitted, "ascii" encoding is defaulted. Only 
   little endian character encodings are supported at the moment. 
      *"utf8"
      *"utf16"
      *"utf32" 
      *"ascii" (the default)

   Lock_type indicates the way the file is locked  for other processes, it 
   is one of:
      * Read - the file can be opened simultaneously by other processes, 
        but not for reading
      * Write - the file can be opened simultaneously by other processes, 
        but not for writing
      * Read Write - the file cannot be opened simultaneously by other 
        processes (the default)

   filenum Is a valid FreeBASIC file number (in the range 1..255) not being 
   used for any other file presently open. The file number identifies the 
   file for the rest of file operations. A free file number can be found 
   using the FreeFile function.

Example
   Dim ff As UByte
   Dim randomvar As Integer
   Dim name_str As String
   Dim age_ubyte As UByte

   ff = FreeFile
   Input "What is your name? ",name_str
   Input "What is your age? ",age_ubyte
   Open "testfile" For Output As #ff
   Write #ff, Int(Rnd(0)*42),name_str,age_ubyte
   Close #ff
   randomvar=0
   name_str=""
   age_ubyte=0

   Open "testfile" For Input As #ff
   Input #ff, randomvar,name_str,age_ubyte
   Close #ff

   Print "Random Number was: ", randomvar
   Print "Your name is: " + name_str
   Print "Your age is: " + Str(age_ubyte)

   'File outputted by this sample will look like this,
   'minus the comment of course:
   '23,"Your Name",19 

Differences from QB

See also
   * Append
   * Input (File Mode)
   * Open



--------------------------------------------------------- KeyPgOverload ----
Overload

Specifies that a procedure name can be overloaded

Syntax
   Declare [Static] Sub procedure_name [cdecl|stdcall|pascal] Overload [
   Alias "external_name"] [([parameter_list])] [Constructor [priority]] [
   Static] [Export]

   Declare [Static] Function procedure_name [cdecl|stdcall|pascal] Overload 
   [Alias "external_name"] [([parameter_list])] [ ByRef ] As return_type [
   Static] [Export]

   [Public|Private] Sub procedure_name [cdecl|stdcall|pascal] Overload [
   Alias "external_name"] [([parameter_list])] [Constructor [priority]] [
   Static] [Export]
      ..procedure body..
   End Sub

   [Public|Private] Function procedure_name [cdecl|stdcall|pascal] Overload 
   [Alias "external_name"] [([parameter_list])] [ ByRef ] As return_type  [
   Static] [Export]
      ..procedure body..
   End Function

Description
   In procedure declarations, Overload allows procedure names to be 
   overloaded, that is, other procedures (regardless of whether to be subs 
   or functions) can then be declared with the same name if their parameter 
   lists are unique. Two parameter lists are unique if they contain a 
   different number of parameters, or have parameters of different types. 
   Note that this means that two or more procedures cannot be declared with 
   the same name if they differ in return type alone.
   A variadic procedure name can never be overloaded.

   Once a procedure name has been declared overloaded, further declarations 
   using the name need not specify Overload, but it is allowed.

   Overload is not necessary in member procedure declarations, as they are 
   always implicitly overloaded.

   When calling an overloaded procedure name, a match score is calculated 
   comparing the call argument types with the parameter types for each 
   candidate procedure (major resolution on datatypes themselves, minor 
   resolution on datatype sizes).
   The highest matching score wins. If this highest score is too low, or if 
   several overloaded procedures have the same highest score, the compiler 
   then generates an error at compile time (no matching procedure, or 
   ambiguous call).

Example
   Declare Function SUM Overload (A As Integer,B As Integer) As Integer
   Declare Function SUM Overload (A As Single,B As Single) As Single
   Function SUM  (A As Integer,B As Integer) As Integer
      Function=A+B
   End Function   
   Function SUM  (A As Single,B As Single) As Single
      Function=A+B
   End Function   
   Dim As Integer A,B
   Dim As Single A1,B1
   A=2
   B=3
   A1=2.
   b1=3.
   Print SUM(A,B)
   Print SUM (A1,B1)
   Sleep

Differences from QB
   * New to FreeBASIC

See also
   * Declare
   * Sub, Function



--------------------------------------------------------- KeyPgOverride ----
Override

Method attribute; specifies that a method must override a virtual

Syntax
   Type typename Extends basename
      ...
      Declare Sub|Function|Operator|Property|Destructor ... ( [
      parameterlist] ) [[ ByRef ] As datatype] Override
      ...
   End Type

Description
   In method declarations, Override can be used to indicate that this 
   method is expected to override a Virtual or Abstract method from the 
   base class. Then the compiler will show an error if the method does not 
   override anything (only a non-static method can override a virtual or 
   abstract method).

   Use of Override is not mandatory to override a virtual or abstract 
   method, it is highly recommended, as it will help prevent inadvertent 
   errors (name/signature not matching).

   Override can only be specified on the method declaration in the UDT 
   block, but not on the method body, because it is just a compile-time 
   check in the context of the inheritance hierarchy, and does not affect 
   the method in any way.

   Override is only recognized as a keyword at the end of member procedure 
   declarations. It can still be used as identifier elsewhere.

Example
   Type A Extends Object
      Declare Virtual Sub f1( )
      Declare Virtual Function f2( ) As Integer
   End Type

   Type B Extends A
      Declare Sub f1( ) Override
      Declare Function f2( ) As Integer Override
   End Type

   Sub A.f1( )
   End Sub

   Function A.f2( ) As Integer
      Function = 0
   End Function

   Sub B.f1( )
   End Sub

   Function B.f2( ) As Integer
      Function = 0
   End Function

Differences from QB
   * New to FreeBASIC

See also
   * Virtual, Abstract




============================================================================
    P

------------------------------------------------------------ KeyPgPaint ----
Paint

Fills an area delimited by a border of a specified color

Syntax
   Paint [target,] [STEP] (x, y)[, [paint][, [border_color]]]

Parameters
   target
      specifies buffer to draw on.  
   STEP
      indicates that coordinates are relative
   (x, y)
      coordinates of the pixel on which to start the flood fill (paint)
   paint
      the color attribute or fill pattern
      a numeric value indicates a color, while a string indicates a fill 
      pattern
   border_color
      boundary color for the fill

Description
   Graphics command to fill an area delimited by a border of specified 
   color. Also known as 'flood-fill' or 'paint bucket'.

   Paint can operate on the current work page as set by the ScreenSet 
   statement or on the target Get/Put buffer, if specified.

   Filling starts at specified (x,y) coordinates; if STEP is specified, 
   these are relative to the last graphics cursor position. Coordinates are 
   also affected by custom coordinates system set up by Window and/or 
   View (Graphics) statements; clipping set by View also applies.

   If the paint argument is a number, it is assumed a color in the same 
   format used by the Color statement, and the region is flood-filled using 
   that color. If paint is a String, the region will be filled using a 
   pattern; the pattern is always 8*8 pixels, and the passed string must 
   hold pixels data in a format dependent on the current color depth. The 
   string holds pattern pixels row by row, and its size should be as 
   follows:

   For color depths 1, 2, 4 and 8:
   size = 8 * 8 = 64
   For color depths 15 and 16:
   size = (8 * 8) * 2 = 128
   For color depths 24 and 32:
   size = (8 * 8) * 4 = 256

   If the passed string is smaller, missing pixels will be 0. If the paint 
   argument is omitted, normal filling is performed using the current 
   foreground color set by Color. Flood-filling continues until pixels of 
   the specified border color are found; if border_color is omitted, the 
   current background color is assumed.

   Warning: If the border is drawn with a transparent color (in conjunction 
   with the GFX_ALPHA_PRIMITIVES option flag) and some pixels are overdrawn 
   on it, the resultant (blended) color of these overdrawn pixels can cause 
   a leak point through which the fill color escapes outside the border. So 
   drawing a border with a transparent color is not recommended.

Example
   ' draws a white circle painted blue inside
   Screen 13
   Circle (160, 100), 30, 15
   Paint (160, 100), 1, 15
   Sleep

   ' draws a circle and fills it with a checkered pattern

   '' choose the bit depth for the Screen
   '' try setting this to other values: 8, 16 or 32

   Const bit_depth = 8

   '' function for returning a pixel color, represented as a string
   '' returns a the string in the appropriate format for the current bit depth
   Function paint_pixel( ByVal c As ULong, ByVal bit_depth_ As Integer ) As String
      
      If bit_depth_ <= 8 Then '' 8-bit:
         Function =  Chr( CUByte(c) )
         
      ElseIf bit_depth_ <= 16 Then '' 16-bit:
         Function = MKShort( c Shr 3 And &h1f Or _
                        c Shr 5 And &h7e0 Or _
                        c Shr 8 And &hf800 )
         
      ElseIf bit_depth_ <= 32 Then '' 32-bit:
         Function = MKL(c)
         
      End If
      
   End Function

   '' open a graphics window at the chosen bit depth
   ScreenRes 320, 200, bit_depth

   '' declare variables for holding colors
   Dim As ULong c, c1, c2, cb

   '' declare string variable for holding the pattern used in Paint
   Dim As String paint_pattern = ""

   '' set colors
   If bit_depth <= 8 Then
      c1 = 7  ''pattern color 1
      c2 = 8  ''pattern color 2
      cb = 15 ''border color
   Else
      c1 = RGB(192, 192, 192) '' pattern color 1
      c2 = RGB(128, 128, 128) '' pattern color 2
      cb = RGB(255, 255, 255) '' border color
   End If

   '' make the pattern to be used in Paint
   For y As UInteger = 0 To 7
      For x As UInteger = 0 To 7
         
         '' choose the color of the pixel (c)
         If (x \ 4 + y \ 4) Mod 2 > 0 Then
            c = c1
         Else
            c = c2
         End If
         
         '' add the pixel to the pattern
         paint_pattern = paint_pattern + paint_pixel(c, bit_depth)
         
         '' the following line can be used if you want to draw the 
         '' pattern tile in the top left hand corner of the screen:
         
         ' pset (x, y), c
         
      Next x
   Next y

   '' draw a circle with the border color
   Circle (160, 100), 50, cb, , , 1.0

   '' paint the circle region with paint_pattern, stopping at the border color
   Paint (160, 100), paint_pattern, cb

   '' pause before ending the program
   Sleep

Differences from QB
   * target is new to FreeBASIC
   * In QB, the fill pattern was always 8-bits wide, and the height was 
     the length of the string (up to 64). In FreeBASIC, the fill pattern is 
     8 pixels wide, independent of the color depth, and the height is 
     always 8
   * The background color parameter supported by QB is not supported by 
     the FreeBASIC version

See also
   * Screen



---------------------------------------------------------- KeyPgPalette ----
Palette

Customizes colors in modes with paletted colors

Syntax
   Palette [Get] [index, color]
   Palette [Get] [index, r, g, b]
   Palette [Get] Using arrayname(idx)

Parameters
   Get
      indicates getting palette information rather than setting palette 
      information
   index
      palette index
   color
      color attribute
   r
      red color component
   g
      green color component
   b
      blue color component
   Using
      indicates using array of color values
   arrayname(idx)
      array and index to get/set color attributes

Description
   The Palette statement is used to retrieve or customize the current 
   palette for graphics modes with a color depth of up to 8bpp; using 
   Palette while in a mode with a higher color depth will have no effect. 
   Calling Palette with no argument restores the default palette for 
   current graphics mode, as set by the Screen (Graphics) statement.
   The GfxLib sets a default palette when a Screen mode is initialized.

   First form
      If you specify index and color, these are dependent on the current 
      mode:
         +-----------+-----------+-----------+
         |Screen mode|index range|color range|
         |1          |0-3        |0-15       |
         |2          |0-1        |0-15       |
         |7,8        |0-15       |0-15       |
         |9          |0-15       |0-63       |
         |11         |0-1        |see below  |
         |12         |0-15       |see below  |
         |13 to 21   |0-255      | see below |
         +-----------+-----------+-----------+

      In screen modes 1, 2, 7, 8 and 9 you can assign to each color index 
      one of the colors in the available range. In other screen modes, the 
      color must be specified in the form &hBBGGRR, where BB, GG and RR are 
      the blue, green and red components ranging &h0-&h3F in hexadecimal (0
      -63 in decimal). If you don't like hexadecimal form, you can use the 
      following formula to compute the integer value to pass to this 
      parameter:
      color = red Or (green Shl 8) Or (blue Shl 16)
      Where red, green and blue must range 0-63. Please note that color 
      values accepted by Palette are not the in the same form as returned 
      by the RGB macro (the red and blue fields are inverted, and the range 
      is different); this is for backward compatibility with QB.

   Second form
      In the second form, you specify the red, green and blue components 
      for a palette entry directly, by calling Palette with 4 parameters. 
      In this case r, g and b must be in the range 0-255.

   Third form
      Calling Palette Using allows to set a list of color values all at 
      once; you should pass an array holding enough elements as the color 
      indices available for your current graphics mode color depth (2 for 
      1bpp, 4 for 2bpp, 16 for 4bpp or 256 for 8bpp). The array elements 
      must be integer color values in the form described above. The colors 
      stored into arrayname starting with given idx index are then assigned 
      to each palette index, starting with index 0.

   Form 1 and 3 are for backward compatibility with QB; form 2 is meant to 
   ease palette handling. Any change to the palette is immediately visible 
   on screen.

   If the Get option is specified, Palette retrieves instead of setting 
   color values for the current palette. The parameters have the same 
   meaning as specified for the form being used, but in this case color, r, 
   g and b must be variables passed by reference that will hold the color 
   RGB values on function exit.

Example
   ' Setting a single color, form 1.
   Screen 15
   Locate 1,1: Color 15
   Print "Press any key to change my color!"
   Sleep
   ' Now change color 15 hues to bright red
   Palette 15, &h00003F
   Sleep

   ' Getting a single color, form 2.
   Dim As Integer r, g, b
   Screen 13
   Palette Get 32, r, g, b
   Print "Color 32 hues:"
   Print Using "Red:### Green:### Blue:###"; r; g; b
   Sleep

   ' Getting whole palette, form 3.
   Dim pal(0 To 255) As Integer
   Screen 13
   Palette Get Using pal
   For i As Integer = 0 To 15
      Print Using "Color ## = &"; i; Hex(pal(i), 6)
   Next i
   Sleep

Differences from QB
   * QBasic did not support PALETTE GET to retrieve a palette.
   * QBasic did not allow passing individual red/green/blue values.

See also
   * Screen (Graphics)
   * Color
   * Using
   * Internal Pixel Formats
   * Default Palettes



----------------------------------------------------------- KeyPgPascal ----
pascal

Specifies a Pascal-style calling convention in a procedure declaration

Syntax
   Sub name pascal [Overload] [Alias "alias"] ( parameters )
   Function name pascal [Overload] [Alias "alias"] ( parameters ) [ ByRef ] 
   As return_type

Description
   In procedure declarations, pascal specifies that a procedure will use 
   the pascal calling convention. In the Pascal calling convention, any 
   parameters are to be passed (pushed onto the stack) in the same order in 
   which they are listed, that is, from left to right. The procedures need 
   not preserve the EAX, ECX or EDX registers, and must clean up the stack 
   (pop any parameters) before it returns.

   pascal is not allowed to be used with variadic procedure declarations 
   (those with the last parameter listed as "...").

   pascal is the default calling convention for procedures in Microsoft 
   QuickBASIC, and is the standard convention used in the Windows 3.1 API.

Example
   Declare Function MyFunc pascal Alias "MyFunc" (MyParm As Integer) As Integer

Differences from QB
   * New to FreeBASIC

See also
   * cdecl, stdcall
   * Declare
   * Sub, Function



------------------------------------------------------------ KeyPgPcopy ----
PCopy

Copies one graphical or text page onto another

Syntax
   Declare Function PCopy ( ByVal source As Long = -1, ByVal destination As 
   Long = -1 ) As Long

Usage
   PCopy [ source ] [, destination ]

Parameters
   source
      page to copy from
   destination
      page to copy to

Return Value
   Returns zero (0) if successful, or a non-zero error code to indicate a 
   failure.

Description
   Copies one graphical or text video page to another. Useful for drawing 
   all graphics on one invisible page and copying it to the active visible 
   page - creating smooth graphics and animation. Known as 'double 
   buffering' or 'page flipping'.

   source and destination refer to page numbers. The 'source' page is 
   copied over the 'destination' page when pcopy is called.

   If the source argument is omitted, the current working page is assumed.  
   If the destination page is omitted, the current visible page is assumed.

   PCopy is inactive if the destination page is locked.

   The error code returned by PCopy can be checked using Err in the next 
   line. The function version of  PCopy returns directly the error code as 
   a 32 bit Long.

Example

   'Sets up the screen to be 320x200 in 8-bit color with 2 video pages.
   ScreenRes 320, 200, 8, 2

   'Sets the working page to 1 and the displayed page to 0
   ScreenSet 1, 0

   'Draws a circle moving across the top of the screen
   For x As Integer = 50 To 269
      Cls                    'Clears the screen so we can start fresh
      Circle (x, 50), 50, 14 'Draws a yellow circle with a 50 pixel radius on page 1
      PCopy 1, 0             'Copies our image from page 1 to page 0
      Sleep 25               'Waits for 25 milliseconds.
   Next x

   'Wait for a keypress before the screen closes
   Sleep

   '' Compile with -lang fblite or qb

   #lang "fblite"

   '' Console mode example:

   '' Set the working page number to 0, and the visible page number to 1
   #if __FB_LANG__ = "QB"
   Screen ,, 0, 1
   #else
   Screen , 0, 1
   #endif

   Dim As Integer i, frames, fps
   Dim As Double t

   t = Timer

   Do
      '' Fill working page with a certain color and character
      Cls
      Locate 1, 1
      Color (i And 15), 0
      Print String$(80 * 25, Hex$(i, 1));
      i += 1

      '' Show frames per second
      Color 15, 0
      Locate 1, 1
      Print "fps: " & fps,
      If Int(t) <> Int(Timer) Then
         t = Timer
         fps = frames
         frames = 0
      End If
      frames += 1

      '' Copy working page to visible page
      PCopy

      '' Sleep 50ms per frame to free up cpu time
      Sleep 50, 1

      '' Run loop until the user presses a key
   Loop Until Len(Inkey$)

Platform Differences
   * Maximum number of text pages in Windows is 4.
   * Maximum number of text pages in DOS is 8.
   * Maximum number of text pages in all other targets is 1.
   * Maximum number of graphics pages depends on what was specified when 
     the Screen or ScreenRes statement was called.

Differences from QB
   * None

See also
   * ScreenCopy
   * Flip
   * Screen



------------------------------------------------------------- KeyPgPeek ----
Peek

Gets the value of an arbitrary type at an address in memory

Syntax
   Declare Function Peek ( ByVal address As Any Ptr ) ByRef As UByte
   Declare Function Peek ( datatype, ByVal address As Any Ptr ) ByRef As 
   datatype

Usage
   Peek( [ datatype, ] address )

Parameters
   address
      The address in memory to get the value from.
   datatype
      The type of value to get. If omitted, UByte is assumed.

Description
   This procedure returns a reference to the value in memory given by a 
   memory address, and is equivalent to:
      *cast(ubyte ptr, address)
         or
      *cast(datatype ptr, address)
   thus this keyword can also be used to assign a value to a memory 
   location, similarly to Poke.

   Note: When using Peek, the -exx compiler option does not add code for 
   null-pointer checking (no nullity test on the value of address).

Example
   Dim i As Integer, p As Integer Ptr
   p = @i

   Poke Integer, p, 420
   Print Peek(Integer, p)

   will produce the output:

   420

Differences from QB
   * Peek did not support the datatype parameter in QB, and could only 
     return individual bytes.
   * Peek returns a reference in FB, so can be used to set the memory 
     contents of the address, like with Operator * (Value Of).
   * DEF SEG isn't needed anymore because the address space is 32-bit flat 
     in FreeBASIC.

See also
   * Poke
   * Operator * (Value Of)


------------------------------------------------------------- KeyPgPmap ----
PMap

Maps coordinates between view and physical mapping.

Syntax
   Declare Function PMap ( ByVal coord As Single, ByVal func As Long ) As 
   Single

Usage
   result = PMap( coord, func )

Parameters
   coord
      An expression indicating the coordinate to be mapped.
   func
      The mapping function number to be applied to given coordinate.

Return Value
   The mapped coordinate value.

Description
   This function converts a coordinate between view (as defined by the 
   Window statement) and physical (as set by the View (Graphics) statement) 
   mappings. Depending on the value of func, expr is used to compute a 
   different mapping to be returned by PMap:

         +-----------+---------------------------------------------------------------------------------+
         |func value:|return value:                                                                    |
         |0          |Treats expr as x view coordinate and returns corresponding x physical coordinate.|
         |1          |Treats expr as y view coordinate and returns corresponding y physical coordinate.|
         |2          |Treats expr as x physical coordinate and returns corresponding x view coordinate.|
         |3          |Treats expr as y physical coordinate and returns corresponding y view coordinate.|
         +-----------+---------------------------------------------------------------------------------+

Example
   ScreenRes 640, 480
   Window Screen (0, 0)-(100, 100)
   Print "Logical x=50, Physical x="; PMap(50, 0)   '' 320
   Print "Logical y=50, Physical y="; PMap(50, 1)   '' 240
   Print "Physical x=160, Logical x="; PMap(160, 2) '' 25
   Print "Physical y=60, Logical y="; PMap(60, 3)   '' 12.5
   Sleep

Differences from QB
   * None

See also
   * Window
   * View (Graphics)



------------------------------------------------------------ KeyPgPoint ----
Point

Returns the color attribute of a specified pixel coordinate

Syntax
   result = Point( coord_x, coord_y [,buffer] )
   or
   result = Point( function_index )

Usage
   coord_x
      x coordinate of the pixel
   coord_y
      y coordinate of the pixel
   buffer
      the image buffer to read from
   function_index
      the type of screen coordinate to return: one of the values 0, 1, 2, 3

Return Value
   The return datatype is a ULong.

   If the x, y coordinates of a pixel are provided Point returns the color 
   attribute at the specified coordinates, as an 8-bit palette index in 8 
   bpp indexed modes, a 24-bit RGB value in 16 bpp modes (upper 8 bits 
   unused, limited precision of R,G,B), and a 32-bit RGB or RGBA value in 
   32 bpp modes (upper 8 bits unused or holding Alpha). Note that it does 
   NOT return a 16-bit value (5 bits R + 6 bits G + 5 bits B).

   If the argument is a function index, Point returns one of the graphics 
   cursor coordinates set by the last graphics command.

      +--------+------------------------------------------------------------------------------------------------------------------------------+
      |Argument| Value Returned                                                                                                               |
      | 0      |The current physical x coordinate.                                                                                            |
      |1       |The current physical y coordinate.                                                                                            |
      | 2      |The current view x coordinate. This returns the same value as the POINT(0) function if the WINDOW statement has not been used.|
      |3       |The current view y coordinate. This returns the same value as the POINT(1) function if the WINDOW statement has not been used.|
      +--------+------------------------------------------------------------------------------------------------------------------------------+

Description
   GfxLib Function with two different uses.
   If supplied with two coordinates it reads the color of the pixel at the 
   coordinate coord_x, coord_y of the screen, or of the buffer, if 
   supplied.
   The value return is a color index in a 256 or less color Screen, and an 
   RGB value in true color modes. If the coordinates are off-screen or 
   off-buffer, -1 is returned

   If supplied with a single value it returns the one of the coordinates of 
   the graphics cursor as set by the last graphics command executed. If the 
   last command was executed in a buffer, the values returned will be 
   coordinates in the buffer. Arguments out of the range 0-3 will return 0.

   The function Point does not work in text modes.

   Speed note: while Point provides valid results, it is quite slow to call 
   repeatedly due to the overhead of additional calculations and checks. 
   Much better performance can be achieved by using direct memory access 
   using the results obtained from ImageInfo and ScreenInfo/ScreenPtr.

Example
   ' Set an appropriate screen mode - 320 x 240 x 8bpp indexed color
   ScreenRes 320, 240, 8

   ' Draw a line using color 12 (light red)
   Line (20,20)-(100,100), 12

   ' Print the color of a point on the line
   Print Point(20,20)

   ' Sleep before the program closes
   Sleep
      

   Output:

   12
   		

Version
   Before fbc 1.08.0, the return datatype was an Integer.

Differences from QB
   * buffer is new to FreeBASIC
   * In 16 bpp and 32 bpp modes, a 32-bit value is returned instead of an 
     8-bit palette index

See also
   * PSet - write pixels
   * PMap
   * Color
   * View (Graphics)
   * Window
   * Internal pixel formats



------------------------------------------------------- KeyPgPointCoord ----
PointCoord

Queries Draw's pen position in graphics mode

Syntax
   Declare Function PointCoord( ByVal func As Long ) As Single

Usage
   result = PointCoord( func )

Description
   The PointCoord function can be used to query x and y position of the Draw
   pen in graphics mode. The result value depends on the passed func value:

      +-----------+---------------------------------------------------------+
      |func value:|return value:                                            |
      |0          |x physical coordinate, same as PMap( PointCoord( 2 ), 0 )|
      |1          |y physical coordinate, same as PMap( PointCoord( 3 ), 1 )|
      |2          |x view coordinate                                        |
      |3          |y view coordinate                                        |
      +-----------+---------------------------------------------------------+

Example
   Screen 12

   Print "--- Default window coordinate mapping ---"
   Print "DRAW pen position, at the default (0,0):"
   Print "Physical:", PointCoord( 0 ), PointCoord( 1 )
   Print "View:", PointCoord( 2 ), PointCoord( 3 )

   Draw "BM 50,50"
   Print "DRAW pen position, after being moved to (50,50):"
   Print "Physical:", PointCoord( 0 ), PointCoord( 1 )
   Print "View:", PointCoord( 2 ), PointCoord( 3 )

   Print "--- Changing window coordinate mapping ---"
   Window Screen (-100, -100) - (100, 100)

   Draw "BM 0,0"
   Print "DRAW pen position, after being moved to (0,0):"
   Print "Physical:", PointCoord( 0 ), PointCoord( 1 )
   Print "View:", PointCoord( 2 ), PointCoord( 3 )

   Draw "BM 50,50"
   Print "DRAW pen position, after being moved to (50,50):"
   Print "Physical:", PointCoord( 0 ), PointCoord( 1 )
   Print "View:", PointCoord( 2 ), PointCoord( 3 )

   Sleep

Differences from QB
   * New to FreeBASIC

See also
   * PMap
   * Window



-------------------------------------------------------------- KeyPgPtr ----
(Pointer | Ptr)

A variable declaration type modifier

Syntax
   ... As DataType {Pointer | Ptr}

Description
   Declares a pointer variable.
   The variable type can be a predefined type or a user-defined type.

   Operator @ (Address Of) operator or VarPtr are used to take the address 
   of a variable. The Operator * (Value Of) operator is used to dereference 
   the pointer, that is, access the actual value stored in the memory 
   location the pointer is pointing at.

Example
   ' Create the pointer.
   Dim p As Integer Ptr

   ' Create an integer value that we will point to using pointer "p"
   Dim num As Integer = 98845

   ' Point p towards the memory address that variable "num" occupies.
   p = @num

   ' Print the value stored in memory pointed to by pointer "p"
   Print "Pointer 'p' ="; *p
   Print 

   ' Print the actual location in memory that pointer "p" points at.
   Print "Pointer 'p' points to memory location:"
   Print p

   Dim p As ZString Pointer
   Dim text As String
   text = "Hello World!"
   p = StrPtr(text) + 6
   Print text
   Print *p

   '' Output:
   '' Hello World!
   '' World!

   Type mytype
      a As Integer = 12345
   End Type

   Dim As mytype mt

   Dim As mytype Ptr pmt
   pmt = @mt

   Print (*pmt).a  '' or Print pmt->a

   '' Output:
   '' 12345

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Pointer or __Ptr.

Differences from QB
   * New to FreeBASIC

See also
   * Allocate



------------------------------------------------------------- KeyPgPoke ----
Poke

Assigns a value to a location in memory.

Syntax
   Declare Sub Poke ( ByVal address As Any Ptr, ByRef value As UByte )
   Declare Sub Poke ( datatype, ByVal address As Any Ptr, ByRef value As 
   datatype )

Usage
   Poke [ datatype, ] address, value

Parameters
   datatype
      The type of data at the specified address. If omitted, UByte is 
      assumed.
   address
      The location in memory to assign to.
   value
      The value to assign.

Description
   Poke assigns a value to a location in memory. It is equivalent to
      *cast(ubyte ptr, address) = value
         or
      *cast(datatype ptr, address) = value

   When datatype is a user-defined type, Poke assigns value using the 
   type's Operator Let.

   Note: When using Poke, the -exx compiler option does not add code for 
   null-pointer checking (no nullity test on the value of address).

Example
   Dim i As Integer, p As Integer Ptr
   p = @i

   Poke Integer, p, 420
   Print Peek(Integer, p)

   Will produce the output:

   420

Differences from QB
   * Only the byte form were supported in QB.
   * DEF SEG isn't needed anymore because the address space is 32-bit flat 
     in FreeBASIC.

See also
   * Peek



-------------------------------------------------------------- KeyPgPos ----
Pos

Returns the horizontal (left to right) position of the text cursor

Syntax
   Declare Function Pos ( ) As Long
   Declare Function Pos ( ByVal dummy As Long ) As Long

Usage
   result = Pos[ ( dummy ) ]

Parameters
   dummy
      An unused parameter retained for backward compatibility with QBASIC.

Return Value
   Returns the horizontal position of the text cursor.

Description
   Returns the horizontal (left to right) position of the text cursor. The 
   leftmost column is number 1.

Example
   Dim As Integer p

   '' print starting column position
   p = Pos()
   Print "position: "; p

   '' print a string, without a new-line
   Print "ABCDEF";

   '' print new column position:
   p = Pos()
   Print: Print "position: "; p
   Print

   ''position changes after each Print:
   Print "Column numbers: "
   Print Pos(), Pos(), Pos(), Pos(), Pos()

Differences from QB
   * The dummy parameter was not optional in QBASIC.

See also
   * CsrLin
   * Tab
   * Locate



--------------------------------------------------------- KeyPgPreserve ----
Preserve

Used with ReDim to preserve contents will resizing an array

Syntax
   ReDim Preserve array(...) [As datatype]

Description
   Used with ReDim so that when an array is resized, data is not reset but 
   is preserved. This means when the array is enlarged that only new data 
   is reset, while the old data remains the same (but not necessarily at 
   the same absolute addresses in memory).

   NOTE: ReDim Preserve may not work as expected in all cases:
      Preserve's current behavior is to keep the original data contiguous 
      in memory, and only expand or truncate the size of the memory (if 
      resizing is not possible, the whole original data block is first 
      shifted to another memory location).
      Its behavior (with a single dimension) is well-defined only when the 
      upper bound is changed.  If the lower bound is changed, the current 
      result is that the data is in effect shifted to start at the new 
      lower bound.
      If there are multiple dimensions, only the upper bound of only the 
      first dimension may be changed safely.  If the first dimension is 
      reduced, the existing mappable data may be lost.  If lower-order 
      dimensions are resized at all, the effects can be hard to predict 
      (because multidimensional arrays are stored in row-major order : 
      values differing only in the last index are contiguous).

Example
   ReDim array(1 To 3) As Integer
   Dim i As Integer

   array(1) = 10
   array(2) = 5
   array(3) = 8

   ReDim Preserve array(1 To 10)

   For i = 1 To 10
      Print "array("; i; ") = "; array(i)
   Next

Differences from QB
   * Preserve wasn't supported until PDS 7.1

See also
   * Dim
   * LBound
   * ReDim
   * UBound



----------------------------------------------------------- KeyPgPreset ----
PReset

Plots a single pixel

Syntax
   PReset [target ,] [STEP] (x, y) [,color]

Parameters
   target
      specifies buffer to draw on.  
   STEP
      indicates that coordinates are relative
   (x, y)
      coordinates of the pixel.
   color
      the color attribute.

Description
   target specifies buffer to draw on.  target may be an image created with 
   ImageCreate or Get (Graphics).  If omitted, target defaults to the 
   screen's current work page.

   (x, y) are the coordinates of the pixel.  STEP if present, indicates 
   that (x, y) coordinates are relative to the graphics cursor position.  
   If omitted, (x, y) are relative to the upper left-hand corner of target. 
   The x and y coordinates are affected by the last call to the 
   View (Graphics) and Window statements, and respect the current clipping 
   region as set by the View (Graphics) statement.

   color specifies the color attribute.  If omitted, color defaults to the 
   current background color.  See Color.  color is graphics mode specific, 
   see Color and Screen (Graphics) for details.

Example
   Screen 13

   'Set background color to 15
   Color , 15

   'Draw a pixel with the background color at 10, 10
   PReset (10,10)

   'Draw a pixel with the background color at Last x cord +10, Last y cord +10
   PReset Step (10,10)
   Sleep

Differences from QB
   * target is new to FreeBASIC

See also
   * PSet



------------------------------------------------------------ KeyPgPrint ----
(Print | ?)

Writes text to the screen

Syntax
   (Print | ?) [ expressionlist ] [ , | ; ]

Parameters
   expressionlist
      list of items to print

Description
   Print outputs a list of values to the screen. Numeric values are 
   converted to their string representation, with left padding for the 
   sign. Objects of user-defined types must overload Operator Cast () As 
   String.

   Consecutive values in the expression list are separated either by a 
   comma (,) or semicolon (;). A comma indicates printing should take place 
   at the next 14 column boundary, while a semicolon indicates values are 
   printed with no space between them.  This has a similar effect to 
   concatenating expressions using + or &.

   Print also supports the special expressions, Spc() and Tab().  These can 
   be used to space out expressions, or to align the printing to a specific 
   column.

   A new-line character is printed after the values in the expression list 
   unless the expression list is followed by a comma or semicolon.  A Print 
   without any expressions or separators following it will just print a 
   new-line.

   NOTE: Print resets the Err value after each expression is printed.

   NOTE: In graphics mode, Draw String provides a flexible alternative to 
   Print: it prints a string to the screen with pixel positioning, 
   transparent background, and can use a user-supplied font.

Example
   '' print "Hello World!", and a new-line
   Print "Hello World!"

   '' print several strings on one line, then print a new-line
   Print "Hello";
   Print "World"; "!";
   Print

   '' column separator
   Print "Hello!", "World!"

   '' printing variables/expressions
   Dim As Double pi = Atn(1) * 4
   Dim As String s = "FreeBASIC"

   Print "3 * 4 ="; 3 * 4

   Print "Pi is approximately"; pi
   Print s; " is great!"

Dialect Differences
   * In the -lang qb dialect, an extra space is printed after numbers.

Differences from QB
   * None, when using QBASIC's variable types in -lang qb.
   * Unsigned numbers are printed without a space before them.
   * QB did not support casting for UDTs, so didn't allow them to be Print
     ed.

See also
   * Spc
   * Tab
   * Print #
   * ? #
   * Print Using
   * ? Using
   * Write
   * Draw String
   * Input



---------------------------------------------------------- KeyPgPrintPp ----
(Print | ?) #

Writes a list of values to a file or device

Syntax
   (Print | ?) # filenum, [ expressionlist ] [ , | ; ]

Parameters
   filenum
      The file number of a file or device opened for Output or Append.
   expressionlist
      List of values to write.

Description
   Print # outputs a list of values to a text file or device. Numeric 
   values are converted to their string representation, with left padding 
   for the sign. Objects of user-defined types must overload Operator Cast 
   () As String.

   Consecutive values in the expression list are separated either by a 
   comma (,) or semicolon (;). A comma indicates printing should take place 
   at the next 14 column boundary, while a semicolon indicates values are 
   printed with no space between them.

   A new-line character is printed after the values in the expression list 
   unless the expression list is followed by a comma or semicolon.

   Note that the comma (,) immediately following the file number is still 
   necessary, even the expression list is empty.  In this case a new-line 
   is printed, just as with a normal expression list that doesn't have a 
   comma or semicolon at the end.

Example
   Open "bleh.dat"  For Output As #1
      
      Print #1, "abc def"
      Print #1, 1234, 5678.901, "xyz zzz"
      
      Close #1

Dialect Differences
   * In the -lang qb dialect, an extra space is printed after numbers.

Differences from QB
   * None, when using QBASIC's variable types in -lang qb.
   * Unsigned numbers are printed without a space before them.
   * QB did not support casting for UDTs, so didn't allow them to be Print
     ed.

See also
   * Print Using
   * ? Using
   * Print
   * ?
   * Write #
   * Open



------------------------------------------------------- KeyPgPrintusing ----
(Print | ?) Using

Outputs formatted text to the screen or output device

Syntax
   (Print | ?) [# filenum ,] [ printexpressionlist {,|;} ] Using 
   formatstring ; [ expressionlist [ ; ] ]

Parameters
   filenum
      The file number of a file or device opened for Output or Append.  
      (Alternatively LPrint may be used where appropriate, instead of 
      Print #)
   printexpressionlist
      Optional preceding list of items to print, separated by commas (,) or 
      semi-colons (;) (see Print for more details).
   formatstring
      Format string to use.
   expressionlist
      List of items to format, separated by semi-colons (;).

Description
   Print to screen various expressions using a format determined by the 
   formatstring parameter. Internally, Print Using uses a buffer size of 
   2048 bytes: while it is highly unlikely that this buffer would be 
   filled, it should be noted that output would be truncated should this 
   limit be reached.

   If no expression list is given, the format string will be printed up to 
   the first special marker.  Note that the semi-colon after formatstring 
   is still necessary, even if no expression list is given.

   The format string dictates how the expressions are to be formatted when 
   output to the screen, indicated by the use of special marker characters. 
   There are markers for formatting both string and numeric output:

   String formatting

         +------+----------------------------------------------------------------------+
         |Marker|Formatting                                                            |
         |!     |prints the first character of a string                                |
         |\   \ |prints as many characters of a string as occupied between the pair \ \|
         |&     |prints the entire string                                              |
         +------+----------------------------------------------------------------------+

   Numeric formatting

         +------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+
         |Marker|Formatting                                                                                                                                                            |
         |#     |placeholder for either an integer digit, or a decimal digit if a decimal point precedes it                                                                            |
         |,     |placed after integer digit indicates groups of 3 digits should be separated by commas in fixed-point notation                                                         |
         |.     |placed near # indicates place for the decimal point                                                                                                                   |
         |^^^   |uses exponential notation (E+/-#) when placed after the digit characters                                                                                              |
         |^^^^  |uses exponential notation (E+/-##) when placed after the digit characters                                                                                             |
         |^^^^^ |uses exponential notation (E+/-###) when placed after the digit characters                                                                                            |
         |+     |placed before/after the format string, controls whether the sign of a number is prepended/appended, and causes an explicit '+' sign to be printed for positive numbers|
         |-     |placed after the format string, causes the sign of the number to be appended rather than prepended, appending a space/negative sign for positive/negative numbers     |
         |$$    |placed at the start of integer digits, causes a dollar sign to be prepended to the number (after the sign if one is prepended)                                        |
         |**    |placed at the start of integer digits, causes any padding on the left to be changed from spaces to asterisks                                                          |
         |**$   |placed at the start of integer digits, pads on the left with asterisks, and prepends a dollar sign after the asterisks                                                |
         |&     |prints a number intelligently, using the exact number of digits required (new to version 0.21.0b)                                                                     |
         +------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+

   All of the special marker characters can be escaped by preceding them 
   with the underscore character "_", allowing them to be printed directly. 
   For example, "_!" is printed as "!", and "__" is printed as "_".

   If a numerical value cannot fit in the number of digits indicated by the 
   format string, the formatting is adapted to fit the number, possibly 
   switching to scientific notation, and the number is printed preceded by 
   the percent "%" character. E.g., the number 1234 with a formatstring of 
   "##.##" would be printed as "%1234.00".

   All other characters within the format string are printed as they 
   appear.

   A new-line character is printed after the values in the expression list 
   unless the expression list is followed by a semicolon (;).

Example

   Print Using "The value is #.## seconds"; 1.019
   Print Using "The ASCII code for the pound sign (_#) is ###"; Asc("#")
   Print Using "The last day in the year is & \ \"; 31; "December"

   will produce the output:

   The value Is 1.02 seconds
   The ASCII code For the pound sign (#) Is  35
   The last Day in the Year Is 31 Dec

Differences from QB
   * QB didn't allow "&" to be used for printing numbers.

See also
   * Print
   * ?
   * Print #
   * ? #
   * Format
   * Using
   * Palette Using



---------------------------------------------------------- KeyPgPrivate ----
Private

Specifies a procedure having internal linkage

Syntax
   Private Sub procedure_name [cdecl|stdcall|pascal] [Overload] [Alias 
   "external_name"] [([parameter_list])] [Constructor [priority]] [Static] 
   [Export]
      ..procedure body..
   End Sub

   Private Function procedure_name [cdecl|stdcall|pascal] [Overload] [Alias 
   "external_name"] [([parameter_list])] [ ByRef ] As return_type  [Static] 
   [Export]
      ..procedure body..
   End Function

Description
   In procedure definitions (forbidden at declaration line level), Private 
   specifies that a procedure has internal linkage, meaning its name is not 
   visible to external modules.
   Therefore among the compiled modules, two procedures with the same 
   identifier, but defined inside different modules, may exist if both are 
   Private.

   The compiler removes the Private procedures that are not called, but 
   this does not currently work for Private procedures that are only called 
   by other Private procedures that are not called themselves, because the 
   first one appears as being called.

   The Option Private statement allows procedures to be defined with 
   internal linkage by default.

Example
   'e.g.

   Private Sub i_am_private
   End Sub

   Sub i_am_public
   End Sub

Differences from QB
   * New to FreeBASIC

See also
   * Private: (Access Control)
   * Public
   * Option Private
   * Sub
   * Function



------------------------------------------------------- KeyPgVisPrivate ----
Private: (Access Control)

Specifies private member access control in a Type or Class

Syntax
   Type typename
      Private:
         member declarations
   End Type

Parameters
   typename
      name of the Type or Class
   member declarations
      declarations for fields, functions, or enumerations

Description
   Private: indicates that member declarations following it have private 
   access.  Private members are accessible only from inside a member 
   function for the Type or Class (so not accessible from inside a member 
   function for types or classes which are derived from the Type or Class).

   member declarations following Private: are private until a different 
   access control specifier is given, like Public: or Protected:.

   Members in a Type declaration are Public: by default if no member access 
   control specifier is given.

Example
   Type testing
     number As Integer
     Private:
      nome As String
     Declare Sub setNome( ByRef newnome As String )
   End Type

   Sub testing.setnome( ByRef newnome As String )
     '' This is OK. We're inside a member function for the type
     this.nome = newnome
   End Sub

   Dim As testing myVariable

   '' This is OK, number is public
   myVariable.number = 69

   '' this would generate a compile error 
   '' - nome is private and we're trying to access it outside any of this TYPE's member functions 
   '' myVariable.nome = "FreeBASIC"

Dialect Differences
   * Available only in the -lang fb dialect.

Differences from QB
   * New to FreeBASIC

See also
   * Private
   * Public: (Access Control)
   * Protected: (Access Control)
   * Type



-------------------------------------------------------- KeyPgOpProcptr ----
Operator Procptr (Procedure Pointer)

Returns the address of a procedure

Syntax
   Declare Operator ProcPtr ( ByRef identifier As proctype [, proctype ] ) 
   As proctype Ptr

Usage
   result = ProcPtr ( identifier [, proctype ] )

Parameters
   identifier
      A procedure identifier.
   proctype
      Any type of procedure (sub/function).

Return Value
   Returns the address of the procedure.

Description
   This operator returns the address of a Sub or Function procedure.

   When using the two arguments PROCPTR( identifier, type ) syntax, this 
   allows of getting procedure pointer for based on sub/function type.
   This makes it possible to explicitly specify the 'type' of the 
   sub/function, to resolve procedure overloads or make a check for 
   compatible sub/function on non-overloaded procedures.

   Operator @ (Address Of), when used with procedures, behaves the same as 
   ProcPtr without its optional argument (the second).

Example
   ' This example uses ProcPtr to demonstrate function pointers
   Declare Function Subtract( x As Integer, y As Integer) As Integer
   Declare Function Add( x As Integer, y As Integer) As Integer
   Dim myFunction As Function( x As Integer, y As Integer) As Integer

   ' myFunction will now be assigned to Add
   myFunction = ProcPtr( Add )
   Print myFunction(2, 3)

   ' myFunction will now be assigned to Subtract.  Notice the different output.
   myFunction = ProcPtr( Subtract )
   Print myFunction(2, 3)

   Function Add( x As Integer, y As Integer) As Integer
      Return x + y
   End Function

   Function Subtract( x As Integer, y As Integer) As Integer
      Return x - y
   End Function

   Sub s Overload()
   End Sub

   Sub s( ByVal i As Integer )
   End Sub

   '----- since fbc 1.09.0, ProcPtr supports a second parameter (optional):
   Var s1 = ProcPtr( s, Sub() )
   Var s2 = ProcPtr( s, Sub( ByVal i As Integer ) )

   '----- before fbc 1.09.0, it was only possible with:
   'Dim s1 As Sub()
   's1 = ProcPtr( s )
   'Dim s2 As Sub( Byval i As Integer)
   's2 = ProcPtr( s )

Version
   * Before fbc 1.09.0, the second argument (the optional) was not 
     supported.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Procptr.

Differences from QB
   * New to FreeBASIC

See also
   * Sub
   * VarPtr
   * StrPtr
   * Pointers



--------------------------------------------------------- KeyPgProperty ----
Property

Declares or defines a property in a type or class

Syntax
   { Type | Class } typename
      Declare Property fieldname () [ ByRef ] As datatype
      Declare Property fieldname ( [ ByRef | ByVal ] new_value As datatype 
      )
      Declare Property fieldname ( [ ByRef | ByVal ] index As datatype ) [ 
      ByRef ] As datatype
      Declare Property fieldname ( [ ByRef | ByVal ] index As datatype, [ 
      ByRef | ByVal ] new_value As datatype )
   End { Type | Class }

   Property typename.fieldname () [ ByRef ] As datatype [ Export ]
      statements
   End Property

   Property typename.fieldname ( [ ByRef | ByVal ] new_value As datatype ) 
   [ Export ]
      statements
   End Property

   Property typename.fieldname (  [ ByRef | ByVal ] index As datatype ) [ 
   ByRef ] As datatype [ Export ]
      statements
   End Property

   Property typename.fieldname (  [ ByRef | ByVal ] index As datatype, [ 
   ByRef | ByVal ] new_value As datatype ) [ Export ]
      statements
   End Property

Parameters
   typename 
      name of the Type or Class
   fieldname 
      name of the property
   new_value 
      the value passed to property to be assigned
   index 
      the property index value

Description
   Property fields are used to get and set values of a Type or Class in the 
   same way as other data fields except instead of a simple assignment to a 
   field or a value retrieved from field, a procedure is executed.

   typename is the name of the type for which the Property method is 
   declared and defined.  Name resolution for typename follows the same 
   rules as procedures when used in a Namespace.

   A Property may optionally have one index parameter.  When indexed, 
   properties are accessed as fieldname(Index) [ = value ].
   A Property without index parameter must always be used without empty 
   parentheses after fieldname.
   A get-Property can also return a reference by specifying ByRef As 
   return_type.

   A hidden This parameter having the same type as typename is passed to 
   the property procedure.  This is used to access the fields of the Type 
   or Class.

   Note: A standard Property (get & set) does not work with combination 
   operators (as "+="). But a result byref get-Property (as more generally 
   any result byref function) works with combination operators.

   Note: When a get-Property is defined with one index parameter, the 
   fieldname= syntax can not be used to return a value. For such a get-
   Property, the property= syntax (in addition to the Return syntax) is 
   only the one allowed.

Example
   Type Vector2D
     As Single x, y
     Declare Operator Cast() As String
     Declare Property Length() As Single
     Declare Property Length( ByVal new_length As Single )
   End Type

   Operator Vector2D.cast () As String
     Return "(" + Str(x) + ", " + Str(y) + ")"
   End Operator

   Property Vector2D.Length() As Single
     Length = Sqr( x * x + y * y )
   End Property

   Property Vector2D.Length( ByVal new_length As Single )
     Dim m As Single = Length
     If m <> 0 Then
      '' new vector = old / length * new_length
      x *= new_length / m
      y *= new_length / m
     End If
   End Property

   Dim a As Vector2D = ( 3, 4 )

   Print "a = "; a
   Print "a.length = "; a.length
   Print

   a.length = 10

   Print "a = "; a
   Print "a.length = "; a.length

Output:

   a = (3, 4)
   a.length =  5

   a = (6, 8)
   a.length =  10

Property Indexing:
     '' True/False
   Namespace BOOL
     Const False = 0
     Const True = Not False
   End Namespace

   Type BitNum
     Num As UInteger
     
      '' Get/Set Properties each with an Index.
     Declare Property NumBit( ByVal Index As Integer ) As Integer
     Declare Property NumBit( ByVal Index As Integer, ByVal Value As Byte )
   End Type

     '' Get a bit by it's index.
   Property BitNum.NumBit( ByVal Index As Integer ) As Integer
     Return Bit( This.Num, Index )
   End Property

     '' Set a bit by it's index.
   Property BitNum.NumBit( ByVal Index As Integer, ByVal Value As Byte )

      '' Make sure index is in Integer range.
     If Index >= ( SizeOf(This.Num) * 8 ) Then
      Print "Out of uInteger Range!"
      Exit Property
     Else
      If Index < 0 Then Exit Property
     End If
     
     If Value = BOOL.FALSE Then
      This.Num = BitReset( This.Num, Index )
     End If
     
     If Value = BOOL.TRUE Then
      This.Num = BitSet( This.Num, Index )
     End If
     
   End Property

   Dim As BitNum Foo

   Print "Testing property indexing with data types:"
   Print "FOO Number's Value: " & Foo.Num

     '' Set the bit in the number as true.
   Foo.NumBit(31) = BOOL.TRUE
   Print "Set the 31st bit of FOO"

     '' Print to see if our bit has been changed.
   Print "FOO Number's Value: " & Foo.Num
   Print "FOO 31st Bit Set? " & Foo.NumBit(31)
   Sleep
   Print ""

Output:

   Testing Property indexing With Data types:
   FOO Number's Value: 0
   Set the 31st Bit of FOO
   FOO Number's Value: 2147483648
   FOO 31st Bit Set? -1

See also
   * Class
   * Type



----------------------------------------------------- KeyPgVisProtected ----
Protected: (Access Control)

Specifies protected member access control in a Type or Class

Syntax
   Type typename
      Protected:
         member declarations
   End Type

Parameters
   typename
      name of the Type or Class
   member declarations
      declarations for fields, functions, or enumerations

Description
   Protected: indicates that member declarations following it have 
   protected access.  Protected members are accessible only from inside a 
   member function for the Type or Class, and classes which are derived 
   from the Type or Class.

   member declarations following Protected: are protected until a different 
   access control specifier is given, like Private: or Public:.

   Members in a Type declaration are Public: by default if no member access 
   control specifier is given.

Example
   Type animal
     Dim As String animalName
     Protected:
      Dim As Integer serialNumber
   End Type

   Type dog Extends animal
     Dim As String masterName
     Declare Sub setSerialNumber ( ByVal number As Integer )
   End Type

   Sub dog.setSerialNumber ( ByVal number As Integer )
     '' This is OK. We're inside a member function of the derived type
     This.serialNumber = number
   End Sub

   Dim As dog d

   '' This is OK, animalName is public
   d.animalName = "Buddy"

   '' this would generate a compile error: 
   '' - serialNumber is protected and we're trying to access it outside its type and the derived type
   '' d.serialNumber = 123456789

   ' Example to illustrate the access control 'Protected' with a token provided by an admin right for an user right:
   '    - The 'admin_right' type extends the 'user_right' type.
   '    - Create directly an 'user_right' object is forbidden.
   '         ('default user_right.constructor' access and 'copy user_right.constructor' access are 'Protected')
   '    - The 'user_right' type has only the access right to get the token.
   '         ('user_right.token' get-property access is 'Public' and 'user_right.token' set-property access is 'protected')
   '    - The 'admin_right' type has the access rights to set and to get the token.
   '         ('admin_right.token' get-property access and 'admin_right.token' set-property access are 'Public')
   '
   ' An 'admin_right' object is created, and then a reference of type 'user_right' to this object is defined.
   '    (create directly an 'user_right' object is forbidden)

   Type user_right
     Public:
      Declare Property token () As String          '' 'Public' to authorize user_right token get
     Protected:
      Declare Constructor ()                       '' 'Protected' to forbid user_right object default-construction
      Declare Constructor (ByRef u As user_right)  '' 'Protected' to forbid user_right object copy-construction
      Declare Property token (ByRef s As String)   '' 'Protected' to forbid user_right token set
     Private:
      Dim As String user_right_token               '' 'Private' to forbid access from outside user_right
   End Type

   Constructor user_right ()  '' Default-constructor
   End Constructor

   Constructor user_right (ByRef u As user_right)  '' Protected copy-constructor
     This.user_right_token = u.user_right_token
   End Constructor

   Property user_right.token () As String  '' Public property user_right token get
     Return This.user_right_token
   End Property

   Property user_right.token (ByRef s As String)  '' Protected property user_right token set
     This.user_right_token = s
   End Property

   Type admin_right Extends user_right
     Public:
      Declare Property token () As String         '' 'Public' to authorize admin_right token get
      Declare Property token (ByRef s As String)  '' 'Public' to authorize admin_right token set
   End Type

   Property admin_right.token () As String  '' Public property admin_right token get
     Return Base.token                      '' 'Base.' to access to the base type property shadowed by this property name
   End Property

   Property admin_right.token (ByRef s As String)  '' Public property admin_right token set
     Base.token = s                                '' 'Base.' to access to the base type property shadowed by this property name
   End Property

   Dim As admin_right ar       '' Create an admin_right type object 'ar'
   ar.token = "fxm123456789"   '' admin_right set the token for user_right
   Print "'" & ar.token & "'"  '' admin_right get the user_right token
   Print

   Dim ByRef As user_right ur = ar  '' Create a user_right type reference 'ur' to the 'ar' instance of admin_right type
   Print "'" & ur.token & "'"       '' user_right get its token
   'ur.token = "fxm0"               '' Error: Illegal member access, USER_RIGHT.TOKEN.property.set (user_right cannot set its token)

   'Dim As user_right ur1       '' Error: The default constructor has no public access
   'Dim As user_right ur2 = ar  '' Error: Constructor has no public access

   Sleep

Dialect Differences
   * Available only in the -lang fb dialect.

Differences from QB
   * New to FreeBASIC

See also
   * Class
   * Private: (Access Control)
   * Public: (Access Control)
   * Type



------------------------------------------------------------- KeyPgPset ----
PSet

Plots a single pixel

Syntax
   PSet [target ,] [STEP] (x, y) [,color]

Parameters
   target
      specifies buffer to draw on.  
   STEP
      indicates that coordinates are relative
   (x, y)
      coordinates of the pixel.
   color
      the color attribute.

Description
   target specifies buffer to draw on.  target may be an image created with 
   ImageCreate or Get (Graphics).  If omitted, target defaults to the 
   screen's current work page.

   (x, y) are the coordinates of the pixel.  STEP if present, indicates 
   that (x, y) coordinates are relative to the graphics cursor position.  
   If omitted, (x, y) are relative to the upper left-hand corner of target. 
   The x and y coordinates are affected by the last call to the 
   View (Graphics) and Window statements, and respect the current clipping 
   region as set by the View (Graphics) statement.

   color specifies the color attribute, as an 8-bit palette index in 8 bpp 
   indexed modes, a 24-bit RGB value in 16 bpp modes (upper 8 bits of the 
   integer unused, limited precision of R,G,B), and a 32-bit RGB or RGBA 
   value in 32 bpp modes (upper 8 bits unused or holding Alpha). Note that 
   it does NOT accept a 16-bit value (5 bits R + 6 bits G + 5 bits B).  If 
   omitted, color defaults to the current foreground color.

   Speed note: while PSet provides valid results, it is quite slow to call 
   repeatedly due to the overhead of additional calculations and checks. 
   Much better performance can be achieved by using direct memory access 
   using the results obtained from ImageInfo and ScreenInfo/ScreenPtr.

Example
   ' Set an appropriate screen mode - 320 x 240 x 8bpp indexed color
   ScreenRes 320, 240, 8

   ' Plot a pixel at the coordinates 100, 100, Color 15. (white)
   PSet (100, 100), 15
   ' Confirm the operation.
   Locate 1: Print "Pixel plotted at 100, 100"
   ' Wait for a keypress.
   Sleep
    
   ' Plot another pixel at the coordinates 150, 150, Color 4. (red) 
   PSet (150, 150), 4
   ' Confirm the operation.
   Locate 1: Print "Pixel plotted at 150, 150"
   ' Wait for a keypress.
   Sleep
    
   ' Plot a third pixel relative to the second, Color 15. (white)
   ' This pixel is given the coordinates 60, 60. It will be placed
   ' at 60, 60 plus the previous coordinates (150, 150), thus plotting at 210, 210.
   PSet Step (60, 60), 15
   ' Confirm the operation.
   Locate 1: Print "Pixel plotted at 150 + 60, 150 + 60"
   ' Wait for a keypress
   Sleep

   ' Explicit end of program
   End

Differences from QB
   * target is new to FreeBASIC
   * In 16 bpp and 32 bpp modes, a 32-bit value is required instead of an 
     8-bit palette index

See also
   * Point - read out pixels
   * PReset
   * View (Graphics)
   * Window
   * Internal pixel formats



---------------------------------------------------------- KeyPgPsetGfx ----
PSet

Parameter to the Put graphics statement which selects PSet as the blitting 
method

Syntax
   Put [ target, ] [ STEP ] ( x,y ), source [ ,( x1,y1 )-( x2,y2 ) ], PSet

Parameters
   PSet
      Required.

Description
   The PSet method copies the source pixel values onto the destination 
   pixels.

   This is the simplest Put method. The pixels in the destination buffer 
   are directly overwritten with the pixels in the source buffer.  No 
   additional operations are done, and there are no color values that are 
   treated as transparent.  It has the same effect as PSetting each pixel 
   individually.

Example
   '' set up a screen: 320 * 200, 16 bits per pixel
   ScreenRes 320, 200, 16
   Line (0, 0)-(319, 199), RGB(0, 128, 255), bf

   '' set up an image with the mask color as the background.
   Dim img As Any Ptr = ImageCreate( 33, 33, RGB(255, 0, 255) )
   Circle img, (16, 16), 15, RGB(255, 255, 0),     ,     , 1, f
   Circle img, (10, 10), 3,  RGB(  0,   0, 0),     ,     , 2, f
   Circle img, (23, 10), 3,  RGB(  0,   0, 0),     ,     , 2, f
   Circle img, (16, 18), 10, RGB(  0,   0, 0), 3.14, 6.28

   Dim As Integer x = 160 - 16, y = 100 - 16

   '' Put the image with PSET
   Put (x, y), img, PSet

   '' free the image memory
   ImageDestroy img

   '' wait for a keypress
   Sleep

Differences from QB
   * None

See also
   * PSet
   * Put (Graphics)



-------------------------------------------------------------- KeyPgPtr ----
(Pointer | Ptr)

A variable declaration type modifier

Syntax
   ... As DataType {Pointer | Ptr}

Description
   Declares a pointer variable.
   The variable type can be a predefined type or a user-defined type.

   Operator @ (Address Of) operator or VarPtr are used to take the address 
   of a variable. The Operator * (Value Of) operator is used to dereference 
   the pointer, that is, access the actual value stored in the memory 
   location the pointer is pointing at.

Example
   ' Create the pointer.
   Dim p As Integer Ptr

   ' Create an integer value that we will point to using pointer "p"
   Dim num As Integer = 98845

   ' Point p towards the memory address that variable "num" occupies.
   p = @num

   ' Print the value stored in memory pointed to by pointer "p"
   Print "Pointer 'p' ="; *p
   Print 

   ' Print the actual location in memory that pointer "p" points at.
   Print "Pointer 'p' points to memory location:"
   Print p

   Dim p As ZString Pointer
   Dim text As String
   text = "Hello World!"
   p = StrPtr(text) + 6
   Print text
   Print *p

   '' Output:
   '' Hello World!
   '' World!

   Type mytype
      a As Integer = 12345
   End Type

   Dim As mytype mt

   Dim As mytype Ptr pmt
   pmt = @mt

   Print (*pmt).a  '' or Print pmt->a

   '' Output:
   '' 12345

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Pointer or __Ptr.

Differences from QB
   * New to FreeBASIC

See also
   * Allocate



----------------------------------------------------------- KeyPgPublic ----
Public

Specifies a procedure having external linkage.

Syntax
   Public Sub procedure_name [cdecl|stdcall|pascal] [Overload] [Alias 
   "external_name"] [([parameter_list])] [Constructor [priority]] [Static] 
   [Export]
      ..procedure body..
   End Sub

   Public Function procedure_name [cdecl|stdcall|pascal] [Overload] [Alias 
   "external_name"] [([parameter_list])] [ ByRef ] As return_type  [Static] 
   [Export]
      ..procedure body..
   End Function

Description
   In procedure definitions (forbidden at declaration line level), Public 
   specifies that a procedure has external linkage, meaning its name is 
   visible to external modules. If Public or Private is not specified, a 
   procedure is defined as if Public was specified.

Example
   Private Sub i_am_private
   End Sub

   Public Sub i_am_public
   End Sub

Differences from QB
   * New to FreeBASIC

See also
   * Public: (Access Control)
   * Private
   * Option Private
   * Sub
   * Function



-------------------------------------------------------- KeyPgVisPublic ----
Public: (Access Control)

Specifies public member access control in a Type or Class

Syntax
   Type typename
      Public:
         member declarations
   End Type

Parameters
   typename
      name of the Type or Class
   member declarations
      declarations for fields, functions, or enumerations

Description
   Public: indicates that member declarations following it have public 
   access.  Public members are accessible with any usage of the Type or 
   Class.

   member declarations following Public: are public until a different 
   access control specifier is given, like Private: or Protected:

   Members in a Type declaration are Public: by default if no member access 
   control specifier is given.

Example
   Type testing
     Private:
      nome As String
     Public:
      number As Integer
     Declare Sub setNome( ByRef newnome As String )
   End Type

   Sub testing.setnome( ByRef newnome As String )
     this.nome = newnome 
   End Sub

   Dim As testing myVariable

   '' We can access these members anywhere since
   '' they're public
   myVariable.number = 69 ''
   myVariable.setNome( "FreeBASIC" )

Dialect Differences
   * Available only in the -lang fb dialect.

Differences from QB
   * New to FreeBASIC

See also
   * Class
   * Private: (Access Control)
   * Protected: (Access Control)
   * Public
   * Type



------------------------------------------------------ KeyPgPutgraphics ----
Put (Graphics)

Copies an image on to another image or screen

Syntax
   Put [target, ] [ [STEP](x, y), source [, (x1, y1)-[STEP](x2, y2) ] [, 
   method [, ( alphaval|value|blender [, param]) ] ]

Parameters
   target
      is the address of the buffer where the image is to be drawn. If it's 
      omitted, the image gets blitted to screen. See below.
   [STEP](x, y)
      specify offsets from the upper-left corner of the destination buffer, 
      or screen, that the image gets drawn to.  STEP indicates that (x, y) 
      offsets are relative to the current graphics cursor position.
   source
      is the address of the buffer of the image to be drawn. See below.
   (x1, y1)-[STEP](x2, y2)
      specify a rectangular area in the source buffer to draw. If omitted, 
      the entire buffer is drawn. STEP indicates that x2 and y2 are 
      relative to x1 and y1, respectively.
   method
      specifies the method used to draw the image to the destination 
      buffer, and can be any one of the following (the default method is 
      XOR):

      Background-independent methods
         PSet : Source pixel values are copied without modification.
         PRESET : Source pixel values are 1's-complement negated before 
         being copied.
         Trans : Source pixel values are copied without modification. Does 
         not draw source pixels of mask color. See below.
      Background-dependent methods
         And : Destination pixels are bitwise Anded with source pixels. See 
         below.
         Or : Destination pixels are bitwise Ored with source pixels. See 
         below.
         Xor : Destination pixels are bitwise Xored with source pixels. See 
         below.
         Alpha : Source is blended with a transparency factor specified 
         either in the value parameter, or in the image's individual 
         pixels.  See below.
         Add: Source is multiplied by a value and added with saturation to 
         the destination. See below.
         Custom : Uses a user-defined function to perform blending the 
         source with the destination. See below.

   value
      is a 0..255 value specifying the transparency value for an ADD or 
      ALPHA method blit.
   blender 
      specifies the address of a user-defined function to be called in a 
      CUSTOM method blit. See below.
   param 
      specifies a parameter to pass to the custom blender.

Description
   The Put statement can be used to draw an image onto another image or 
   screen. The x and y coordinates are affected by the last call to the View
   and Window statements, and plotted image respects the current clipping 
   region set by last call to the View statement. The source image can 
   overflow the destination buffer or screen (then the copied image is 
   clipped accordingly).

   Valid Image Buffers
      The source and target image buffers must be valid image buffers. 
      Valid image buffers are created using the Get or ImageCreate 
      statements. Valid image buffers can be specified in a Put statement 
      using an array name with optional index (but never with empty 
      parentheses), or a pointer with optional index.

   Drawing methods
      Depending on the method used, the existing pixel values in the 
      destination buffer are used to calculate the pixel values that are 
      actually drawn. The PSET, PRESET and TRANS methods do not use the 
      destination buffer for calculating final pixel values, while the AND, 
      OR, XOR, ALPHA and ADD methods do. Images that are drawn with these 
      latter methods will look differently depending on the content of the 
      destination buffer.

   Different pixel formats
      The pixel format of an image buffer must be compatible with the 
      current graphics mode color depth; that is, if you acquire an image 
      using Get and you later change screen mode via the Screen statement, 
      the image data may not be valid in the new graphics mode, and you may 
      not be able to draw it on the screen. You should note however that 
      you will always be able to draw image buffers onto other image 
      buffers via Put as long as these buffers were created with the same 
      depth.

      The AND, OR and XOR methods produce different results depending on 
      the current color depth, as pixels are stored in different formats; 
      see Internal pixel formats for details.

   Mask Color
      The TRANS, ALPHA and ADD methods do not draw pixels in the source 
      image that use the mask color. The mask color depends on target 
      (being it an image buffer or the screen) depth: in depths up to 8 bpp 
      (paletted modes) it is equal to color index 0, while in hi/truecolor 
      depths (16 and 32 bpp) it is equal to magenta, which is RGB(255, 0, 
      255). Note that in 32 bpp modes the alpha value of a color does not 
      affect the identification of the transparent color; only the lower 24 
      bits are used to identify it. See Internal pixel formats for details. 
      

   Alpha drawing
      The ALPHA method can be used in two modes. If the value parameter is 
      specified, this is used to specify the level of transparency for the 
      whole image to be drawn; a value of 0 will draw a completely 
      transparent image, whereas a value of 255 will draw a completely 
      solid one. This mode works only when drawing onto hi/truecolor 
      targets (16 and 32 bpp).
      If the value parameter is omitted, the ALPHA method will take the 
      alpha level value on a per-pixel basis, allowing to draw images with 
      an alpha channel (certain parts of the image can be made more or less 
      transparent than others). This mode works only with 32 bpp image 
      buffers, as this is the only color depth that allows for an embedded 
      alpha value in each pixel.

   Dealing with the alpha channel
      Normally Put only allows to draw image buffers onto targets with the 
      same depth, but there is an exception. When drawing an 8 bpp image 
      buffer onto a 32 bpp target and the ALPHA method is used, the 8 bpp 
      source image is drawn into the alpha channel of the 32 bpp target. 
      This allows to easily set the whole alpha channel of an image without 
      having to deal with low level access of its pixel data.

   Custom Blend Function
      The CUSTOM method uses a user-defined function to calculate the final 
      pixel values to be drawn to the destination buffer. This function 
      will be called once for every pixel of the source image, and will 
      receive the source and destination pixel values, and a data pointer 
      passed by the Put function. The pixel value returned will be the 
      value used to draw to the destination buffer. The function has the 
      form:

      Declare Function identifier ( ByVal source_pixel As ULong, ByVal 
      destination_pixel As ULong, ByVal parameter As Any Ptr ) As ULong
         identifier is the name of the function. Can be anything.
         source_pixel is the current pixel value of the source image.
         destination_pixel is the current pixel value of the destination 
         image.
         parameter is the parameter that is passed by the Put command.  It 
         should be a data Pointer.  If omitted, its value will be zero.

Example
   The following program gives a simple example of how to Put an image to 
   the screen, including setting up an image buffer, and freeing its memory 
   after.
   '' set up the screen and fill the background with a color
   ScreenRes 320, 200, 32
   Paint (0, 0), RGB(64, 128, 255)

   '' set up an image and draw something in it
   Dim img As Any Ptr = ImageCreate( 32, 32, RGB(255, 0, 255) )
   Circle img, (16, 16), 15, RGB(255, 255, 0),     ,     , 1, f
   Circle img, (10, 10), 3,  RGB(  0,   0, 0),     ,     , 2, f
   Circle img, (23, 10), 3,  RGB(  0,   0, 0),     ,     , 2, f
   Circle img, (16, 18), 10, RGB(  0,   0, 0), 3.14, 6.28

   '' PUT the image in the center of the screen
   Put (160 - 16, 100 - 16), img, Trans

   '' free the image memory
   ImageDestroy img

   '' wait for a keypress
   Sleep

   The following example shows how to allocate memory for an image, draw 
   that image using various methods, including a custom blender, and free 
   the memory for the image:
   Declare Function checkered_blend( ByVal src As ULong, ByVal dest As ULong, ByVal param As Any Ptr ) As ULong

      Screen 14, 32                                   '' set 320*240*32 gfx mode
      
      Dim As Any Ptr sprite
      Dim As Integer counter = 0
      
      sprite = ImageCreate( 32, 32 )                  '' allocate memory for 32x32 sprite
      
      Line sprite, ( 0, 0 )-( 31, 31 ), RGBA(255, 0, 0, 64), bf  '' draw a sprite ...
      Line sprite, ( 4, 4 )-( 27, 27 ), RGBA(255, 0, 0, 192), bf
      Line sprite, ( 0, 0 )-( 31, 31 ), RGB(0, 255, 0), b
      Line sprite, ( 8, 8 )-( 23, 23 ), RGBA(255, 0, 255, 64), bf
      Line sprite, ( 1, 1 )-( 30, 30 ), RGBA(0, 0, 255, 192)
      Line sprite, ( 30, 1 )-( 1, 30 ), RGBA(0, 0, 255, 192)
      
      Cls
      Dim As Integer i : For i = 0 To 63              '' draw the background
        Line( i,0 )-( i,240 ), RGB( i * 4, i * 4, i * 4 )
      Next i
      
      '' demonstrate all drawing methods ...
      Put( 8,14 ), sprite, PSet
      Put Step( 16,20 ), sprite, PReset
      Put Step( -16,20 ), sprite, And
      Put Step( 16,20 ), sprite, Or
      Put Step( -16,20 ), sprite, Xor
      Put Step( 16,20 ), sprite, Trans
      Put Step( -16,20 ), sprite, Alpha, 96
      Put Step( 16,20 ), sprite, Alpha
      Put Step( -16,20 ), sprite, Add, 192
      Put Step( 16,20 ), sprite, Custom, @checkered_blend, @counter
      
      '' print a description near each demo
      Draw String (100, 26), "<- pset"
      Draw String Step (0, 20), "<- preset"
      Draw String Step (0, 20), "<- and"
      Draw String Step (0, 20), "<- or"
      Draw String Step (0, 20), "<- xor"
      Draw String Step (0, 20), "<- trans"
      Draw String Step (0, 20), "<- alpha (uniform)"
      Draw String Step (0, 20), "<- alpha (per pixel)"
      Draw String Step (0, 20), "<- add"
      Draw String Step (0, 20), "<- custom"
      
      ImageDestroy( sprite )                          '' free allocated memory for sprite
      Sleep : End 0

   '' custom blender function: chequered put
   Function checkered_blend( ByVal src As ULong, ByVal dest As ULong, ByVal param As Any Ptr ) As ULong
      Dim As Integer Ptr counter
      Dim As ULong pixel
      
      counter = Cast(Integer Ptr, param)
      pixel = IIf(((*counter And 4) Shr 2) Xor ((*counter And 128) Shr 7), src, dest)
      *counter += 1
      Return pixel
   End Function

Differences from QB
   * target is new to FreeBASIC
   * The TRANS, ALPHA, ADD and CUSTOM methods are new to FreeBASIC
   * FB uses a different image format internally, which is unsupported by 
     QB
   * QB throws a run-time error instead of clipping out-of-bounds images
   * In QB, only arrays can be specified as source images

See also
   * Custom (Graphics Put)
   * Put (File I/O)
   * Get (Graphics)
   * ImageCreate
   * Alpha
   * Internal pixel formats



-------------------------------------------------------- KeyPgPutfileio ----
Put (File I/O)

Writes data from a buffer to a file

Syntax
   Put #filenum As Long, [position As LongInt], data As Any [, amount As 
   UInteger]
   Put #filenum As Long, [position As LongInt], data As String
   Put #filenum As Long, [position As LongInt], data() As Any

Usage
   Put #filenum, position, data [, amount]
   varres = Put (#filenum, position, data [, amount])

Parameters
   filenum
      The value passed to Open when the file was opened.
   position
      Is the position where Put must start in the file. If the file was 
      opened For Random, the position is in records, else it is given in 
      bytes. If omitted, writing starts at the present file pointer 
      position.  The position is 1-based: i.e. the first record or byte of 
      a file is at position 1.
      If position is omitted or zero (0), file writing will start from the 
      current file position.
   data
      Is the buffer where data is written from. It can be a numeric 
      variable, a string, an array or a user-defined type. The operation 
      will try to transfer to disk the complete variable, unless amount is 
      given.
      When putting arrays, data should be followed by an empty pair of 
      brackets: '()'.  Put will write all of the data in the array.  amount 
      is not allowed.
      When putting Strings, the number of bytes written is the same as the 
      number of bytes in the string data.  amount is not allowed.
      Note: If you want to write values from a buffer, you should NOT pass 
      a pointer to the buffer; instead you should pass the first variable 
      in the buffer (this can be done by dereferencing the pointer with 
      Operator * (Value Of)). If you pass a pointer directly, then Put will 
      put the memory from the pointer variable, not the memory it points 
      to.
   amount
      Makes Put write to file amount consecutive variables to the file - 
      i.e. it writes ( amount * SizeOf(data) ) bytes of data, starting at 
      data's location in memory, into the file.  If amount is omitted it 
      defaults to 1, meaning that Put just writes a single variable.

Return Value
   Put() returns a 32 bit Long: 0 on success; nonzero on error. "disk full" 
   is considered as an error, and results in return code 3. An "exact" 
   amount of data written before is not available, and wouldn't be really 
   useful anyway. 

Description
   Writes binary data from a buffer variable to a file opened in Binary or 
   Random mode.

   Put can be used as a function, and will return 0 on success or an error 
   code on failure.	

   For files opened in Random mode, the size in bytes of the data to write 
   must match the specified record size.

   Note:
      - If a real [w/z]string variable is passed to Put, the amount 
      parameter should be forbidden as it is when passing a string. Do not 
      use. Otherwise, it is dangerously used to multiply the string length 
      to be written to the file, but possibly by overflowing outside the 
      provided [w/z]string buffer.
      - If a dereferenced [w/z]string pointer is passed to Put, the amount 
      parameter is not taken into account as it is when passing a 
      dereferenced numeric pointer. Do not use. But instead of respecting 
      the amount parameter, the pointed buffer is written to the file up to 
      the zero element (terminal element which is excluded).
      - For finer granularity, any [w/z]string variable can be safely 
      passed to Put as numeric buffer by providing the first numeric 
      element (an indexed [w/z]string variable, or a dereferenced 
      [w/z]string pointer then indexed) and the number of numeric elements 
      to be processed.

Example
   ' Create variables for the file number, and the number to put
   Dim As Integer f
   Dim As Long value

   ' Find the first free file number
   f = FreeFile()

   ' Open the file "file.ext" for binary usage, using the file number "f"
   Open "file.ext" For Binary As #f

     value= 10

     ' Write the bytes of the integer 'value' into the file, using file number "f"
     ' starting at the beginning of the file (position 1)
     Put #f, 1, value

   ' Close the file
   Close #f

   ' Create an integer array
   Dim buffer(1 To 10) As Integer
   For i As Integer = 1 To 10
      buffer(i) = i
   Next

   ' Find the first free file file number
   Dim f As Integer
   f = FreeFile()

   ' Open the file "file.ext" for binary usage, using the file number "f"
   Open "file.ext" For Binary As #f
   ' Write the array into the file, using file number "f"
   ' starting at the beginning of the file (position 1)
   Put #f, 1, buffer()

   ' Close the file
   Close #f

   Dim As Byte Ptr lpBuffer
   Dim As Integer hFile, Counter, Size

   Size = 256

   lpBuffer = Allocate(Size)
   For Counter = 0 To Size-1
     lpBuffer[Counter] = (Counter And &HFF)
   Next

   ' Get free file file number
   hFile = FreeFile()

   ' Open the file "test.bin" in binary writing mode
   Open "test.bin" For Binary Access Write As #hFile

     ' Write 256 bytes from the memory pointed to by lpBuffer
     Put #hFile, , lpBuffer[0], Size

   ' Close the file
   Close #hFile

   ' Free the allocated memory
   Deallocate lpBuffer

Differences from QB
   * Put can write full arrays as in VB or, alternatively, write a 
     multiple of the data size from buffer's memory location.
   * Put can be used as a function in FB, to find the success/error code 
     returned without having to use error handling procedures.

See also
   * Put (Graphics) different usage of same keyword 
   * Get (File I/O)
   * Open
   * Close
   * Random
   * Binary
   * FreeFile




============================================================================
    R

----------------------------------------------------------- KeyPgRandom ----
Random

Specifies file or device to be opened for random access mode

Syntax
   Open filename for Random [Access access_type] [Lock lock_type] as [#]
   filenum [Len = record_length]

Parameters
   filename
      file name to open
   access_type
      indicates whether the file may be read from, written to or both
   lock_type
      locking to be used while the file is open
   filenum
      unused file number to associate with the open file
   record_length
      the size of the record used for the file

Description
   Opens a file or device for reading and/or writing binary data in the 
   given file filenum, with records of size record_length.
   If the file does not exist, a new file will be created, otherwise any 
   data existing in the file is preserved by Open.  The file pointer is 
   initialized by Open at the start of the file, at record number 1. File 
   operations move the file position in steps of record_length bytes.
   This file mode uses an user-defined Type buffer variable to read/write 
   full records in a file. The buffer variable uses to include several 
   fields.
   The data is saved in binary mode, in the same internal format FreeBASIC 
   uses, by means of Get # and Put #.

   filename must be string expression resulting in a legal file name in the 
   target OS, without wildcards. The file will be sought for in the present 
   directory, unless a path is given.

   Access_type - By default Random mode allows to both read and write the 
   file, unless an Access type is specified, it must be one of:
      * Read - the file is opened for input only
      * Write - the file is opened for output only
      * Read Write - the file is opened for input and output (the default)

   Lock_type indicates the way the file is locked for other processes 
   (users or threads), it is one of:
      * Shared - The file can be freely accessed by other processes     
      * Lock Read - The file can't be opened simultaneously for reading
      * Lock Write - The file can't be opened simultaneously for writing
      * Lock Read Write - The file cannot be opened simultaneously by 
        other processes.
      If no lock type is stated, the file will be Shared for other threads 
      of the program and Lock Read Write for other programs.
      Lock and Unlock can be used to restrict temporally access to parts of 
      a file.

   filenum is a valid FreeBASIC file number (in the range 1..255) not being 
   used for any other file presently open. This number identifies the file 
   for the rest of file operations. A free file number can be found using 
   the FreeFile function.

   record_length is the amount of bytes the file pointer will move for each 
   individual Get and Put, it must match the size of the buffer variable 
   used when Getting and Putting data. If omitted, it defaults to 128.

Example
   '' This example generates a test file and then lets you view random records
   '' that are read live from the file.

   Type Entry
      slen As Byte
      sdata As String * 10
   End Type

   Dim u As Entry
   Dim s As String

   Open "testfile" For Random As #1 Len = SizeOf(Entry)

   '' Write out 9 records with predefined data
   For i As Integer = 1 To 9
      Read s
      u = Type( Len(s), s )
      Put #1, i, u
   Next

   Data ".,-?!'@:", "abc",      "def"
   Data "ghi",      "jkl",      "mno"
   Data "pqrs",     "tuv",      "wxyz"

   '' Let the user view records by specifying their index number
   Do
      Dim i As Integer
      Input "Record number: ", i
      If i < 1 Or i > 9 Then Exit Do

      Get #1, i, u
      Print i & ": " & Left( u.sdata, u.slen )
      Print
   Loop

   Close #1

   Type ScoreEntry Field = 1
      As String * 20 Name
      As Single score
   End Type

   Dim As ScoreEntry entry

   '' Generate a fake boring highscore file
   Open "scores.dat" For Random Access Write As #1 Len = SizeOf(entry)
   For i As Integer = 1 To 10
      entry.name = "Player " & i
      entry.score = i
      Put #1, i, entry
   Next
   Close #1

   '' Read out and display the entries
   Open "scores.dat" For Random Access Read As #1 Len = SizeOf(entry)
   For i As Integer = 1 To 10
      Get #1, i, entry
      Print i & ":", entry.name, Str(entry.score), entry.score
   Next
   Close #1

Differences from QB
   * Care must be taken with dynamic or fixed length strings inside user 
     defined types (UDT), see the warning at Type.
   * The keyword Field can only be used with Type to specify the packing 
     of the UDT. 

See also
   * Open
   * Binary
   * Get #
   * Put #



-------------------------------------------------------- KeyPgRandomize ----
Randomize

Seeds the random number generator

Syntax
   Declare Sub Randomize ( ByVal seed As Double = -1.0, ByVal algorithm As 
   Long = 0 )

Usage
   Randomize [ seed ][, algorithm ]

Parameters
   seed
      A Double seed value for the random number generator, but the 
      fractional part is clipped for all algorithms except algorithm #4 
      (see below). If omitted, a value based on Timer will be used instead.
   algorithm
      An integer value to select the algorithm (see the standard header 
      "fbmath.bi" for available algorithms). If omitted, the default 
      algorithm for the current language dialect is used.

Description
   Sets the random seed that helps Rnd generate random numbers, and selects 
   the algorithm to use.
   The constants for algorithm are defined in fbmath.bi. In the -lang fb 
   dialect, these constants are part of the FB Namespace.
   Valid values for algorithm are:
      FB_RND_AUTO (0) - Default for current language dialect. This is 
      algorithm FB_RND_MTWIST (3) in the -lang fb dialect, FB_RND_QB (4) in 
      the -lang qb dialect and FB_RND_CRT (1) in the -lang fblite dialect.
      FB_RND_CRT (1) - Uses the C runtime library's rand() function. This 
      will give different results depending on the platform.
      FB_RND_FAST (2) - Uses a fast implementation. This should be stable 
      across all platforms, and provides 32-bit granularity, reasonable 
      degree of randomness.
      FB_RND_MTWIST (3) - Uses the Mersenne Twister. This should be stable 
      across all platforms, provides 32-bit granularity, and gives a high 
      degree of randomness.
      FB_RND_QB (4) - Uses a function that is designed to give the same 
      random number sequences as QBASIC. This should be stable across all 
      platforms, and provides 24-bit precision, with a low degree of 
      randomness.
      FB_RND_REAL (5) - Available on Win32 and Linux, using system features 
      (Win32 Crypto API, Linux /dev/urandom) to provide cryptographically 
      random numbers. If those system APIs are unavailable, algorithm 
      FB_RND_MTWIST (3) will be used instead.

      For any given seed, each algorithm will produce a specific, 
      deterministic sequence of numbers for that seed. If you want each 
      call to Randomize to produce a different sequence of numbers, a seed 
      that is not quite predictable should be used - for example, the value 
      returned from Timer. Omitting the seed parameter will use a value 
      based on this.

      Note: for all algorithms except algorithm #4, because the fractional 
      part of the seed is clipped, the using the Timer value directly as a 
      parameter will produce the same seed if used more than once in the 
      same second. However, it is generally not worth calling Randomize 
      twice with unpredictable seeds anyway, because the second sequence 
      will be no more random than the first, or even possibly worse by 
      inducing sequence overlapping. In most cases, the Mersenne twister 
      should provide a sufficiently random sequence of numbers, without 
      requiring reseeding between Rnd calls.

      When you call Randomize with the QB compatible algorithm, part of the 
      old seed is retained. This means that if you call Randomize several 
      times with the same seed, you will not get the same sequence each 
      time. To get a specific sequence in QB compatible mode, set the seed 
      by calling Rnd with a negative parameter.

      Note:
            Randomize is thread-safe (by using an internal mutex), but not 
            thread specific.
            Structures for other random number generators are also 
            available in the standard header "fbmath.bi".

Example
   '' Seed the RNG to the method using C's rand()
   Randomize , 1

   '' Print a sequence of random numbers
   For i As Integer = 1 To 10
      Print Rnd
   Next
      

Version
   * Before fbc 1.08.0:
      The standard "fbmath.bi" header for available algorithms did not 
      exist.
      Randomize was not thread-safe.

Dialect Differences
   The default algorithm used depends on the current dialect in use:
      * With the -lang fb dialect, a 32 bit Mersenne Twister function with 
        a granularity of 32 bits is used.
      * With the -lang qb dialect, a function giving the same output as Rnd
        in QB is used. The granularity is 24 bits.
      * With the -lang deprecated and -lang fblite dialects, the function 
        in the C runtime available in the system is used. The function has 
        a granularity of 15 bits in Win32, and 32 bits in Linux and DOS.

Differences from QB
   * The algorithm parameter is new to FreeBASIC.
   * QBASIC only had one algorithm (replicated in FB in algorithm number 4
     , and set as the default in the -lang qb dialect).

See also
   * Rnd
   * Language dialects



------------------------------------------------------------- KeyPgRead ----
Read

Reads values stored with the Data statement.

Syntax
   Read variable_list

Description
   Reads data stored in the application with the Data command. 

   The elements of the variable_list must be of basic types, numeric, 
   strings or elements of arrays and user defined types.

   All the Data statements in the program behave as a single list, after 
   the last element of one Data statement is read, the first element of the 
   following Data statement will be read.
   The program should not attempt to Read after the last Data element.  The 
   results are (in all dialects) undefined,  and the program may crash 
   (Page Fault).

   Data constants can only be of simple types (numeric or string).  A 
   string read into a numeric variable will be evaluated by the Val 
   function.

   The "Restore label" statement makes the first Data item after label the 
   next item to be read, allowing the user to choose specific sections of 
   data to be read.

Example
   ' Create an array of 5 integers and a string to hold the data.
   Dim As Integer h(4)
   Dim As String hs
   Dim As Integer readindex

   ' Set up to loop 5 times (for 5 numbers... check the data)
   For readindex = 0 To 4

     ' Read in an integer.
     Read h(readindex)

     ' Display it.
     Print "Number" ; readindex ; " = " ; h(readindex)

   Next readindex

   ' Spacer.
   Print

   ' Read in a string.
   Read hs

   ' Print it.
   Print  "String = " + hs

   ' Await a keypress.
   Sleep

   ' Exit program.
   End

   ' Block of data.
   Data 3, 234, 4354, 23433, 87643, "Bye!"

Dialect Differences
   * None in syntax and usage of Read
   * See the Data page for more information on differences in storing the 
     data

Differences from QB
   * None in syntax and usage of Read
   * See the Data page for more information on differences in storing the 
     data

See also
   * Data
   * Restore



--------------------------------------------------------- KeyPgReadFile ----
Read (File Access)

File access specifier

Syntax
   Open filename As String For Binary Access Read As #filenum As Integer

Description
   Specifier for the Access clause in the Open statement.  Read specifies 
   that the file is accessible for input.

Example
   See example at Access

Differences from QB
   * None known.

See also
   * Access
   * Open



---------------------------------------------------- KeyPgReadWriteFile ----
Read Write (File Access)

File access specifier

Syntax
   Open filename As String For Binary Access Read Write As #filenum As 
   Integer

Description
   Specifier for the Access clause in the Open statement.  Read Write 
   specifies that the file is accessible for both input and output.

Example
   See example at Access

Differences from QB
   * None known.

See also
   * Access
   * Open



------------------------------------------------------- KeyPgReallocate ----
Reallocate

Reallocates storage for an existing reserved block of memory

Syntax
   Declare Function Reallocate cdecl ( ByVal pointer As Any Ptr, ByVal 
   count As UInteger ) As Any Ptr

Usage
      result = Reallocate( pointer, count )

Parameters
   pointer
      The address of allocated memory to be reallocated.
   count
      The number of bytes, in total, to be reallocated.

Return Value
   The address of the reallocated memory. A null (0) pointer is returned if 
   reallocation was unsuccessful, and the original memory pointed to by 
   pointer remains unchanged.

Description
   Attempts to reallocate, or resize, memory previously allocated with 
   Allocate or CAllocate. The contents of the buffer are preserved, 
   although if count is less than the original size of the memory block, 
   the buffer will be truncated.  If the size is increased, the added 
   memory range is not initialized to anything.

   When using Reallocate, the result pointer must be saved to prevent a 
   potential memory leak, because the original pointer may no longer be 
   valid after reallocation.  The value of the new pointer should be 
   checked - if it is 0, the reallocation has failed - the original pointer 
   remains valid, and the amount of memory allocated to it has not changed.

   Reallocated memory must be freed with Deallocate when no longer needed.

   If pointer is null (0), then ReAllocate behaves identically to Allocate. 
   If pointer is valid and count is null (0), then ReAllocate behaves 
   similar to Deallocate and a null (0) pointer is returned.

   If the memory has previously been deallocated by a call to Deallocate or 
   ReAllocate, the behavior is undefined.

   When manually allocating memory for String descriptors (or Udts that 
   contain one), if count is larger than the original size of the memory 
   block, the new extra memory range must be explicitly cleared to zeroes 
   before the first string use (for example, using Clear).  Otherwise 
   accessing the string will cause undefined results (trying to write or 
   read at a random place in memory, or trying to deallocate a random 
   pointer).

   NOTE: Reallocating a pointer inside an object function, when that 
   pointer contains the parent object of the function, is undefined, and 
   will likely result in horrible crashes.

Example
   Dim a As Integer Ptr, b As Integer Ptr, i As Integer

   a = Allocate( 5 * SizeOf(Integer) )   ' Allocate memory for 5 integers

   If a = 0 Then Print "Error Allocating a": End

   For i = 0 To 4
     a[i] = (i + 1) * 2   ' Assign integers to the buffer
   Next i

   b = Reallocate( a, 10 * SizeOf(Integer) )   ' Reallocate memory for 5 additional integers

   If b <> 0 Then

      a = b   ' Discard the old pointer and use the new one

      For i = 5 To 9
        a[i] = (i + 1) * 2   ' Assign more integers to the buffer
      Next i

      For i = 0 To 9   ' Print the integers
        Print i, a[i]
      Next i
      Print

   Else '' Reallocate failed, memory unchanged

      Print "Error Reallocating a"

      For i = 0 To 4   ' Print the integers
        Print i, a[i]
      Next i
      Print

   End If

   Deallocate a   ' Clean up
      

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Reallocate.

Differences from QB
   * New to FreeBASIC

See also
   * Allocate
   * CAllocate
   * Deallocate



------------------------------------------------------------ KeyPgRedim ----
ReDim

Defines or resizes a variable-length array

Syntax
   Declaring a Dynamic Array:
      ReDim [ Shared ] symbolname([subscript [, ...]]) As datatype [, ...]
      ReDim [ Shared ] As datatype symbolname([subscript [, ...]]) [, ...]

   Resizing a Dynamic Array:
      ReDim [ Preserve ] symbolname([subscript [, ...]]) [, ...]
   or:
      ReDim [ Preserve ] [ ( ] expression [ ) ] ([subscript [, ...]]) [, 
      ...]

Parameters
   Shared
      Specifies shared (file-scope) access to the array throughout the 
      module.
   Preserve
      When used with an existing array, the contents of the array will be 
      preserved during the resize. Note that in some cases Preserve will 
      not preserve data at its original index, see below.
   symbolname
      A new or existing array identifier.
   expression or (expression)
      An expression referring to an existing array. This can be used to 
      resize arrays which are members of user-defined types. In some cases, 
      it is necessary to specify parentheses around the expression 
      (especially if the array expression itself contains parentheses) - 
      see the examples below.
   subscript: [ lowerbound To ] upperbound
      The lower and upper bound range for a dimension of the array. Lower 
      bound defaults to zero (0), or the default Base, if not specified.
   datatype
      The type of elements contained in the array.

Description
   ReDim can be used to define new variable-length arrays, or resize 
   existing variable-length arrays while keeping the same number of 
   dimensions. ReDim always produces variable-length arrays, so, unlike Dim
   , variable-length arrays can be defined with constant subscripts.

   When defining a new variable-length array, its elements are default 
   constructed. For simple data types like Integer or Double, the elements 
   are initialized to zero (0). For user-defined types with a default 
   constructor, that will be called.

   When used with in a user-defined type, ReDim creates variable-length 
   arrays while being able to pre-size them with constant subscripts.

   NOTES: 
      * ReDim Preserve may not work as expected in all cases:
         * Preserve's current behavior is to keep the original data 
           contiguous in memory, and only expand or truncate the size of 
           the memory (if resizing is not possible, the whole original data 
           block is first shifted to another memory location).
         * Its behavior (with a single dimension) is well-defined only 
           when the upper bound is changed.  If the lower bound is changed, 
           the current result is that the data is in effect shifted to 
           start at the new lower bound.
         * With multiple dimensions, only the upper bound of only the 
           first dimension may be safely increased.  If the first dimension 
           is reduced, the existing mappable data may be lost. If 
           lower-order dimensions are resized at all, the effects can be 
           hard to predict (because multidimensional arrays are stored in 
           row-major order : values differing only in the last index are 
           contiguous).
      * ReDim cannot be used on fixed-size arrays - i.e. arrays with 
        constant bounds made with Dim:
         * This includes the fixed-size arrays contained in UDTs 
           (user-defined Types).
         * This also includes fixed-length arrays passed as parameters in 
           a procedure: FreeBASIC cannot prevent you trying this at 
           compile-time, but generates an error at run-time.
      * ReDim cannot be used inside a member procedure if the array 
        contains as element the instance itself of the object, because that 
        could cause horrible crashes:
         * If the array data are moved into memory by ReDim, the passed 
           This reference becomes inconsistent, in the same way as a 
           dangling pointer.
         * In that case, all subsequent accesses to any non-static member 
           data from this member procedure will be erroneous, except if the 
           passed This reference would be readjusted (by means of @This = 
           @array(...)) immediately after executing ReDim in the body of 
           this member procedure.

Example
   '' Define a variable-length array with 5 elements
   ReDim array(0 To 4) As Integer

   For index As Integer = LBound(array) To UBound(array)
      array(index) = index
   Next

   '' Resize a variable-length array with 10 elements 
   '' (the lower bound should be kept the same)
   ReDim Preserve array(0 To 9)

   Print "index", "value"
   For index As Integer = LBound(array) To UBound(array)
      Print index, array(index)
   Next

   This program will produce the following output:

   index         value
    0             0
    1             1
    2             2
    3             3
    4             4
    5             0
    6             0
    7             0
    8             0
    9             0

   '' Define a variable-length array
   Dim array() As Integer

   '' ReDim array to have 3*4 elements
   ReDim array(1 To 3, 1 To 4)

   Dim As Integer n = 1, i, j

   Print "3 * 4:"
   Print
   For i = LBound(array, 1) To UBound(array, 1)
      For j = LBound(array, 2) To UBound(array, 2)
         array(i, j) = n
         Print Using "##  "; array(i, j);
         n += 1
      Next
      Print
   Next
   Print

   '' ReDim Preserve array to have 4*4 elements, preserving the contents
   '' (only the first upper bound should be changed)
   ReDim Preserve array(1 To 4, 1 To 4)

   Print "4 * 4:"
   Print
   For i = LBound(array, 1) To UBound(array, 1)
      For j = LBound(array, 2) To UBound(array, 2)
         Print Using "##  "; array(i, j);
      Next
      Print
   Next
   Print

   '' ReDim Preserve array to have 2*4 elements, preserving but trancating the contents
   '' (only the first upper bound should be changed)
   ReDim Preserve array(1 To 2, 1 To 4)

   Print "2 * 4:"
   Print
   For i = LBound(array, 1) To UBound(array, 1)
      For j = LBound(array, 2) To UBound(array, 2)
         Print Using "##  "; array(i, j);
      Next
      Print
   Next
   Print

   This program will produce the following output:

   3 * 4:

    1   2   3   4
    5   6   7   8
    9  10  11  12

   4 * 4:

    1   2   3   4
    5   6   7   8
    9  10  11  12
    0   0   0   0

   2 * 4:

    1   2   3   4
    5   6   7   8

   '' Define a variable-length array as UDT field
   Type UDT
      Dim As Integer array(Any)
   End Type

   Dim As UDT u(0 To 3)

   '' For use of Redim with a complex array expression
   '' (especially if the array expression itself contains parentheses),
   '' the array expression must be enclosed in parentheses
   '' in order to solve the parsing ambiguity:
   ''    Redim u(0).array(0 To 9)
   ''    induces error 4: Duplicated definition, u in 'Redim u(0).array(0 To 9)'
   ReDim (u(0).array)(0 To 9)

Differences from QB
   * Preserve was in Visual Basic, but not in QBASIC.
   * Multi-dimensional arrays in FreeBASIC are in row-major order, rather 
     than column-major order.

See also
   * Common
   * Dim
   * Erase
   * Extern
   * LBound
   * Preserve
   * Shared
   * Static
   * UBound
   * Var



-------------------------------------------------------------- KeyPgRem ----
Rem

Indicates comments in the source code.

Syntax
   Rem comment

   ' Comment

   /' Multi-line
      comment '/

Description
   A source code line beginning with Rem indicates that the line is a 
   comment and will not be compiled.  

   The single quote character (') may also be used to indicate a comment 
   and may appear after other keywords on a source line.

   Multi-line comments are marked with the tokens /' and '/.  All text 
   between the two markers is considered comment text and is not compiled.

Example
   /' this is a multi line 
   comment as a header of
   this example '/

   Rem This Is a Single Line comment

   ' this is a single line comment

   ? "Hello" : Rem comment following a statement

   Dim a As Integer ' comment following a statement

   ? "FreeBASIC" : ' also acceptable 

   Dim b As /' can comment in here also '/    Integer

   #if 0
      This way of commenting Out code was
      required before version 0.16
   #endif

Differences from QB
   * Rem may also appear after other keywords on a source line in 
     FreeBASIC
   * Multiline comments are new to FreeBASIC

See also
   * #if



------------------------------------------------------------ KeyPgReset ----
Reset

Closes all open files, or resets standard I/O handles.

Syntax
   Declare Sub Reset ( )
   Declare Sub Reset ( ByVal streamno As Long )

Usage
   Reset
or
   Reset( streamno )

Parameters
   streamno
      The stream number to reset, 0 for stdin or 1 for stdout.

Description
   Reset, when called with no arguments, closes all disk files.

   Reset, when called with the streamno argument, will reset the redirected 
   or piped streams associated with stdin (0), or stdout (1).

Runtime errors:
   Reset(streamno) can set one of the following runtime errors:

   (1) Illegal function call
      * streamno was neither 0 nor 1

   (3) File I/O error
      * Resetting of stdin or stdout failed

Example
   Open "test.txt" For Output As #1
   Print #1, "testing 123"
   Reset

   Dim x As String

   '' Read from STDIN from piped input
   Open Cons For Input As #1
   While EOF(1) = 0
     Input #1, x
     Print """"; x; """"
   Wend
   Close #1

   '' Reset to read from the keyboard
   Reset(0)

   Print "Enter some text:"
   Input x

   '' Read from STDIN (now from keyboard)
   Open Cons For Input As #1
   While EOF(1) = 0
     Input #1, x
     Print """"; x; """"
   Wend
   Close #1

      Note: Under Windows, to specify to the program that data entry is 
      completed (transfer EOF), you can press CTRL+Z then press ENTER.

Differences from QB
   * None for Reset().
   * The Reset(streamno) usage is new to FreeBASIC.

See also
   * Close
   * Open
   * Open Cons
   * IsRedirected



---------------------------------------------------------- KeyPgRestore ----
Restore

Changes the next read location for values stored with the Data statement.

Syntax
   Restore [label]

Description
   Sets the next-data-to-read pointer to the first element of the first Data
   statement after the label.  The label must be contained in the same 
   module as the currently-executing code.  Restore alters the normal top 
   to bottom order in which Data are Read. It allows re-reading some Data 
   or using multiple sets of Data in a single module.	
   If label is omitted, the next-data-to-read pointer is set to the first 
   Data statement found in the module.

Example
   ' Create an 2 arrays of integers and a 2 strings to hold the data.
   Dim h(4) As Integer
   Dim h2(4) As Integer
   Dim hs As String
   Dim hs2 As String
   Dim read_data1 As Integer
   Dim read_data2 As Integer

   ' Set the data read to the label 'dat2:'
   Restore dat2

   ' Set up to loop 5 times (for 5 numbers... check the data)
   For read_data1 = 0 To 4

     ' Read in an integer.
     Read h(read_data1)

     ' Display it.
     Print "Bloc 1, number"; read_data1;" = "; h(read_data1)

   Next

   ' Spacer.
   Print

   ' Read in a string.
   Read hs

   ' Print it.
   Print  "Bloc 1 string = " + hs

   ' Spacers.
   Print
   Print

   ' Set the data read to the label 'dat1:'
   Restore dat1

   ' Set up to loop 5 times (for 5 numbers... check the data)
   For read_data2 = 0 To 4

     ' Read in an integer.
     Read h2(read_data2)

     ' Display it.
     Print "Bloc 2, number"; read_data2;" = "; h2(read_data2)

   Next

   ' Spacer.
   Print

   ' Read in a string.
   Read hs2

   ' Print it.
   Print  "Bloc 2 string = " + hs2

   ' Await a keypress.
   Sleep

   ' Exit program.
   End

   ' First block of data.
   dat1:
   Data 3, 234, 4354, 23433, 87643, "Bye!"

   ' Second block of data.
   dat2:
   Data 546, 7894, 4589, 64657, 34554, "Hi!"

Differences from QB
   * None

See also
   * Data
   * Read
   * Labels



----------------------------------------------------------- KeyPgResume ----
Resume

Error handling statement to resume execution after a jump to an error 
handler

Syntax
   Resume

Description
   Resume is used in the traditional QB error handling mechanism within an 
   error handler (called by On Error) to return execution to the line that 
   caused the error.  Usually this is used after the error has been handled 
   gracefully in order to try the previously erroneous operation again with 
   corrected data.

   Resume resets the Err value to 0

Example
   '' Compile with -lang fblite or qb

   #lang "fblite"

   Dim As Single i, j

   On Error Goto ErrHandler

   i = 0
   j = 1 / i ' this line causes a divide-by-zero error on the first try; execution jumps to ErrHandler label

   Print j ' after the value of i is corrected, prints 0.5

   End ' end the program so that execution does not fall through to the error handler again

   ErrHandler:

   i = 2
   Resume ' execution jumps back to 'j = 1 / i' line, which does not cause an error this time

Dialect Differences
   *  RESUME is not supported in the -lang fb dialect. Statements can be 
     used in its function form to return an error code
   If Open( "text" For Input As #1 ) <> 0 Then
     Print "Unable to open file"
   End If

 

Differences from QB
   * Does not accept line numbers or labels
   * Must compile with -ex or -exx option

See also
   * Err
   * Resume Next
   * Error Handling



------------------------------------------------------- KeyPgResumenext ----
Resume Next

Error handling statement to resume execution after a jump to an error 
handler

Syntax
   Resume Next

Description
   Resume Next is used in the traditional QB error handling mechanism 
   within an error handler (called by On Error) to return execution to the 
   line after the one that caused the error.  Usually this is used to avoid 
   executing the same line and causing the error again.

   Resume Next resets the Err value to 0

Example
   '' Compile with -lang fblite or qb

   #lang "fblite"

   Dim As Single i, j

   On Error Goto ErrHandler

   i = 0
   j = 5
   j = 1 / i ' this line causes a divide-by-zero error; execution jumps to ErrHandler label

   Print "ending..."

   End ' end the program so that execution does not fall through to the error handler again

   ErrHandler:

   Resume Next ' execution jumps to 'Print "ending..."' line, but j is now in an undefined state

Dialect Differences
   *  RESUME NEXT is not supported in the -lang fb dialect. Statements can 
     be used in its function form to return an error code
   If Open( "text" For Input As #1 ) <> 0 Then
     Print "Unable to open file"
   End If

 

Differences from QB
   * Must compile with -ex or -exx option

See also
   * Err
   * Resume
   * Error Handling



----------------------------------------------------------- KeyPgReturn ----
Return (From Procedure)

Control flow statement to return from a procedure or GoSub.

Syntax
   Return expression

Description
   Return is used to return from a procedure.

   Because Return could mean return-from-gosub or return-from-procedure, 
   Option Gosub and Option Nogosub can be used to enable and disable GoSub 
   support.  When GoSub support is disabled, Return is then recognized as 
   return-from-procedure.  When GoSub support is enabled, Return is then 
   recognized as return-from-gosub.

   Return (from procedure) is used inside a procedure to exit the procedure 
   possibly with a return value:
      * A Sub cannot specify a return return value. Return is roughly 
        equivalent to the Exit Sub idiom.
      * In a Function, Return must specify its return value.  Return 
        expression is roughly equivalent to the Function = expression : Exit
        Function idiom.
            Warning: Whatever the output branch used, the return value must 
            be always defined, otherwise an unexpected behavior may occur.

Example
   '' Return from function

   Type rational              '' simple rational number type
      numerator As Integer
      denominator As Integer
   End Type

   '' multiplies two rational types
   Function rational_multiply( r1 As rational, r2 As rational ) As rational

      Dim r As rational
      '' multiply the divisors ...
      r.numerator   = r1.numerator   * r2.numerator
      r.denominator = r1.denominator * r2.denominator

      '' ... and return the result
      Return r

   End Function

   Dim As rational r1 = ( 6, 105 )   '' define some rationals r1 and r2
   Dim As rational r2 = ( 70, 4 )
   Dim As rational r3

   r3 = rational_multiply( r1, r2 )  '' multiply and store the result in r3

   '' display the expression
   Print r1.numerator & "/" & r1.denominator; " * ";
   Print r2.numerator & "/" & r2.denominator; " = ";
   Print r3.numerator & "/" & r3.denominator

Dialect Differences
   * In the -lang fb dialect Return always means return-from-procedure.
   * In the -lang qb dialect, Return means return-from-gosub by default 
     unless changed with Option Nogosub, in which case the compiler will 
     recognize Return as return-from-procedure.
   * In the -lang fblite dialect, Return means return-from-procedure by 
     default unless changed with Option Gosub, in which case the compiler 
     will recognize Return as return-from-gosub.

Differences from QB
   * None when using the -lang qb dialect.

See also
   * Sub
   * Function
   * GoSub
   * Option Gosub
   * Option Nogosub
   * Labels
   * Return (From Gosub)



------------------------------------------------------ KeyPgReturnGosub ----
Return (From Gosub)

Control flow statement to return from a procedure or GoSub.

Syntax
   Return [ label ]

Description
   Return is used to return from a gosub GoSub.

   Because Return could mean return-from-gosub or return-from-procedure, 
   Option Gosub and Option Nogosub can be used to enable and disable GoSub 
   support.  When GoSub support is disabled, Return is then recognized as 
   return-from-procedure.  When GoSub support is enabled, Return is then 
   recognized as return-from-gosub.

   Return (from gosub) is used to return control back to the statement 
   immediately following a previous GoSub call. When used in combination 
   with GoSub, no return value can be specified.  If the optional label is 
   specified, execution continues at the specified label.  If no GoSub was 
   made, a runtime error is generated, and execution continues immediately 
   after Return.

   A GoSub should always have a matching Return statement.  However, if 
   Return (from gosub) is used where no GoSub was made, a run-time error is 
   generated.

Example
   '' GOSUB & RETURN example, compile with "-lang qb" or use "$lang" as below

   '$lang: "qb"

   Print "Let's Gosub!"
   GoSub MyGosub
   Print "Back from Gosub!"
   Sleep
   End

   MyGosub:
   Print "In Gosub!"
   Return

Dialect Differences
   * In the -lang fb dialect Return always means return-from-procedure.
   * In the -lang qb dialect, Return means return-from-gosub by default 
     unless changed with Option Nogosub, in which case the compiler will 
     recognize Return as return-from-procedure.
   * In the -lang fblite dialect, Return means return-from-procedure by 
     default unless changed with Option Gosub, in which case the compiler 
     will recognize Return as return-from-gosub.

Differences from QB
   * None when using the -lang qb dialect.

See also
   * Sub
   * Function
   * GoSub
   * Option Gosub
   * Option Nogosub
   * Labels
   * Return (From Procedure)



-------------------------------------------------------------- KeyPgRgb ----
RGB

Computes a valid color value for hi/truecolor modes

Syntax
   #define RGB(r,g,b) CULng((CUByte(r) Shl 16) Or (CUByte(g) Shl 8) Or 
   CUByte(b) Or (&hFF000000ul))

Usage
   result = RGB(red, green, blue)

Parameters
   red
      red color component value
   green
      green color component value
   blue
      blue color component value

Return Value
   The combined color.

Description
   red, green and blue are components ranging 0-255.

   The RGB function can be used to compute a valid color value for use 
   while in hi/truecolor modes. It returns an unsigned long, in the format 
   &hAARRGGBB, where RR, GG and BB equal the values passed to this 
   function, in hexadecimal format. AA is the implicit alpha value and is 
   automatically set to &hFF (opaque).
   It is possible to retrieve the red, green, blue and alpha values from a 
   color value, by using a combination of And and Shr.  The second example 
   below shows how to #define and use macros to do this.

   Note for Windows API programmers: The macro named RGB in the Windows 
   references has been renamed BGR in the FB headers for Windows to avoid 
   collisions. 

Example
   See Put (Graphics) example in addition.

   ScreenRes 640,480,32  '32 bit color
   Line(0,0)-(319,479), RGB(255,0,0) 'draws a bright red box on the left side of the window
   Line(639,0)-(320,479), RGB(0,0,255) 'draws a bright blue box on the right side of the window

   Sleep 'wait before exiting
      

   '' setting and retrieving Red, Green, Blue and Alpha values

   #define RGBA_R( c ) ( CULng( c ) Shr 16 And 255 )
   #define RGBA_G( c ) ( CULng( c ) Shr  8 And 255 )
   #define RGBA_B( c ) ( CULng( c )        And 255 )
   #define RGBA_A( c ) ( CULng( c ) Shr 24         )

   Dim As UByte r, g, b, a

   Dim As ULong col = RGB(128, 192, 64)

   Print Using "Color: _&H\      \"; Hex(col, 8)

   r = RGBA_R( col )
   g = RGBA_G( col )
   b = RGBA_B( col )
   a = RGBA_A( col )

   Print
   Print Using "Red:         _&H\\ = ###"; Hex(r, 2); r
   Print Using "Green:       _&H\\ = ###"; Hex(g, 2); g
   Print Using "Blue:        _&H\\ = ###"; Hex(b, 2); b
   Print Using "Alpha:       _&H\\ = ###"; Hex(a, 2); a
      

Version
   * Before fbc 1.08.0:
         Syntax:
            #define RGB(r,g,b) ((CULng(r) Shl 16) Or (CULng(g) Shl 8) Or 
            CULng(b) Or &hFF000000)
         RGB function returned an unsigned integer.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Rgb.

Differences from QB
   * New to FreeBASIC

See also
   * RGBA
   * Color
   * #define

   

   


------------------------------------------------------------- KeyPgRgba ----
RGBA

Computes a valid color value including alpha (transparency) for 
hi/truecolor modes

Syntax
   #define RGBA(r,g,b,a) CULng((CUByte(r) Shl 16) Or (CUByte(g) Shl 8) Or 
   CUByte(b) Or (CUByte(a) Shl 24))

Usage
   result = RGBA(red, green, blue, alpha)

Parameters
   red
      red color component value
   green
      green color component value
   blue
      blue color component value
   alpha
      alpha component value

Return Value
   the combined color

Description
   red, green, blue and alpha are components ranging 0-255.

   The RGBA function can be used to compute a valid color value including 
   an alpha channel for use while in hi/truecolor modes. It returns an 
   unsigned long, in the format &hAARRGGBB, where RR, GG, BB, AA equal the 
   values passed to this function, in hexadecimal format.
   It is possible to retrieve the red, green, blue  and alpha values from a 
   color value, by using a combination of And and Shr.  The second example 
   below shows how to #define and use macros to do this.

Example
   'open a graphics screen (320 * 240, 32-bit)
   ScreenRes 320, 240, 32

   Dim As Any Ptr img
   Dim As Integer x, y

   'make an image that varies in transparency and color
   img = ImageCreate(64, 64)
   For x = 0 To 63
     For y = 0 To 63
      PSet img, (x, y), RGBA(x * 4, 0, y * 4, (x + y) * 2)
     Next y
   Next x
   Circle img, (31, 31), 25,      RGBA(0, 127, 192, 192), ,,, F 'semi-transparent blue circle
   Line   img, (26, 20)-(38, 44), RGBA(255, 255, 255, 0),    BF 'transparent white rectangle

   'draw a background (diagonal white lines)
   For x = -240 To 319 Step 10
     Line (x, 0)-Step(240, 240), RGB(255, 255, 255)
   Next

   Line (10,  10)-(310,  37), RGB(127, 0, 0), BF 'red box for text
   Line (10, 146)-(310, 229), RGB(0, 127, 0), BF 'green box for Putting onto

   'draw the image and some text with PSET
   Draw String(64, 20), "PSet"
   Put(48,  48), img, PSet
   Put(48, 156), img, PSet

   'draw the image and some text with ALPHA
   Draw String (220, 20), "Alpha"
   Put(208,  48), img, Alpha
   Put(208, 156), img, Alpha

   'Free the image memory
   ImageDestroy img

   'Keep the window open until the user presses a key
   Sleep
      

   '' setting and retrieving Red, Green, Blue and Alpha values

   #define RGBA_R( c ) ( CULng( c ) Shr 16 And 255 )
   #define RGBA_G( c ) ( CULng( c ) Shr  8 And 255 )
   #define RGBA_B( c ) ( CULng( c )        And 255 )
   #define RGBA_A( c ) ( CULng( c ) Shr 24         )

   Dim As UByte r, g, b, a

   Dim As ULong col = RGBA(255, 192, 64, 128)

   Print Using "Color: _&H\      \"; Hex(col, 8)

   r = RGBA_R( col )
   g = RGBA_G( col )
   b = RGBA_B( col )
   a = RGBA_A( col )

   Print
   Print Using "Red:         _&H\\ = ###"; Hex(r, 2); r
   Print Using "Green:       _&H\\ = ###"; Hex(g, 2); g
   Print Using "Blue:        _&H\\ = ###"; Hex(b, 2); b
   Print Using "Alpha:       _&H\\ = ###"; Hex(a, 2); a
      

Version
   * Before fbc 1.08.0:
         Syntax:
            #define RGBA(r,g,b,a) ((CULng(r) Shl 16) Or (CULng(g) Shl 8) Or 
            CULng(b) Or (CULng(a) Shl 24))
         RGBA function returned an unsigned integer.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Rgba.

Differences from QB
   * New to FreeBASIC

See also
   * RGB
   * Color
   * #define



------------------------------------------------------------ KeyPgRight ----
Right

Returns the rightmost substring of a string

Syntax
   Declare Function Right ( ByRef str As Const String, ByVal n As Integer ) 
   As String
   Declare Function Right ( ByRef str As Const WString, ByVal n As Integer 
   ) As WString

Usage
   result = Right[$]( str, n )

Parameters
   str
      The source string.
   n
      The substring length, in characters.

Return Value
   Returns the rightmost substring from str.

Description
   Returns the rightmost n characters starting from the right (end) of str. 
   If str is empty, then the null string ("") is returned. If n <= 0 then 
   the null string ("") is returned. If n > len(str) then the entire source 
   string is returned.

Example
   Dim text As String = "hello world"
   Print Right(text, 5)

   will produce the output:

   world

An Unicode example:

dim text as wstring*20
text = "&#1055;&#1088;&#1080;&#1074;&#1077;&#1090;, &#1084;&#1080;&#1088;!"
print right(text, 5) 'displays " &#1084;&#1080;&#1088;!"

Platform Differences
   * DOS does not support the wide-character string version of Right.

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * QB does not support Unicode.

See also
   * Left
   * Mid (Function)



------------------------------------------------------------ KeyPgRmdir ----
RmDir

Removes a folder/directory from the file system

Syntax
   Declare Function RmDir ( ByRef folder As Const String ) As Long

Usage
   result = RmDir( folder )

Parameters
   folder
      The folder/directory to be removed.

Return Value
   Returns zero (0) on success, and negative one (-1) on failure.

Description
   Removes a folder from the file system. The function will fail if the 
   folder is not empty.

Example
   Dim pathname As String = "foo\bar\baz"
   Dim result As Integer = RmDir( pathname )

   If 0 <> result Then Print "error: unable to remove folder " & pathname & " in the current path."

Platform Differences
   * Linux requires the folder case matches the real name of the file. 
     Windows and DOS are case insensitive. 
   * Path separators in Linux are forward slashes / . Windows uses 
     backward slashes \ but it allows for forward slashes .  DOS uses 
     backward  \ slashes. 

Differences from QB
   * None

See also
   * Shell
   * CurDir
   * ChDir
   * MkDir
   * Kill



-------------------------------------------------------------- KeyPgRnd ----
Rnd

Returns a random Double precision number in the range [0, 1)

Syntax
   Declare Function Rnd ( ByVal seed As Single = 1.0 ) As Double

Usage
   result = Rnd( seed )

Parameters
   seed
      Optional Single argument. If seed has a value of zero (0.0), the last 
      random number generated is repeate.  For any other number a new 
      random number is returned. With the QB-compatible algorithm, a 
      negative number fully reseeds the generator.  The default for no 
      argument is to return a new random number.

Return Value
   Returns the random number generated.

Description
   Returns a number of type Double in the range [0, 1) (i.e. 0 <= Rnd < 1), 
   based on a random seed (see Randomize).

   Rnd can use a variety of different algorithms - see Randomize for 
   details of the default and selectable algorithms.

   Rnd will return the same sequence of numbers every time a program is 
   run.  This sequence can be changed by reseeding the generator.

   Note:
      Rnd is thread-safe (by using an internal mutex), but not thread 
      specific. Used in the context of a multi-threaded program, only the 
      execution speed is significantly slowed down compared to a single 
      thread call context.
      Structures for other random number generators are also available in 
      the standard header "fbmath.bi".

Example
   '' Function to a random number in the range [first, last), or {first <= x < last}.
   Function rnd_range (first As Double, last As Double) As Double
      Function = Rnd * (last - first) + first
   End Function

   '' seed the random number generator, so the sequence is not the same each time
   Randomize

   '' prints a random number in the range [0, 1), or {0 <= x < 1}.
   Print Rnd

   '' prints a random number in the range [0, 10), or  {0 <= x < 10}.
   Print Rnd * 10

   '' prints a random integral number in the range  [1, 10], or {1 <= n <= 10}.
   ''     (because: 0 <= Rnd * 10 < 10)
   Print Int(Rnd * 10) + 1

   '' prints a random integral number in the range [69, 420], or {69 <= n <= 420}.
   ''     (because: 69 <= rnd_range(69, 421) < 421)
   Print Int(rnd_range(69, 421))
      

Version
   * Before fbc 1.08.0:
         Rnd was not thread-safe (many values temporarily returned in 
         duplicate for a same thread).
         The standard "fbmath.bi" header for available algorithms did not 
         exist.

Dialect Differences
   The default algorithm used depends on the current dialect in use:
      * With the -lang fb dialect, a 32 bit Mersenne Twister function with 
        a granularity of 32 bits is used.
      * With the -lang qb dialect, a function giving the same output as 
        Rnd in QB is used. The granularity is 24 bits.
      * With the -lang deprecated and -lang fblite dialects, the function 
        in the C runtime available in the system is used. The function 
        available in Win32 has a granularity of 15 bits, and 32 bits in 
        Linux and DOS.

Differences from QB
   * None, if compiled in the -lang qb dialect.  Other dialects can also 
     use the same seeding and generating algorithms by calling Randomize 
     with the appropriate parameter.
   * For the non-QB-compatible algorithms, if the optional argument is 
     less than 0, it has the same meaning as passing an argument of 1.

See also
   * Randomize
   * Timer
   * Int



------------------------------------------------------------- KeyPgRset ----
RSet

Right justifies a string in a string buffer

Syntax
   Declare Sub RSet ( ByRef dst As String, ByRef src As Const String )
   Declare Sub RSet ( ByVal dst As WString Ptr, ByVal src As Const WString 
   Ptr )

Usage
   RSet dst, src

Parameters
   dst
      A String or WString buffer to copy the text into.
   src
      The source String or WString to be right justified.

Description
   RSet right justifies text into the string buffer dst, filling the right 
   part of the string with src and the left part with spaces.  The string 
   buffer size is not modified.

   If text is too long for the string buffer size, RSet truncates 
   characters from the right.

Example
   Dim buffer As String
   buffer = Space(10)
   RSet buffer, "91.5"
   Print "-[" & buffer & "]-"

The example above outputs:
   -[      91.5]-

Differences from QB
   * In QBasic the syntax was RSet dst = src. That syntax is also 
     supported by FB.

See also
   * LSet
   * Space
   * Put (File I/O)
   * MKD
   * MKI
   * MKL
   * MKS

   


------------------------------------------------------------ KeyPgRtrim ----
RTrim

Removes surrounding substrings or characters on the right side of a string

Syntax
   Declare Function RTrim ( ByRef str As Const String, [ Any ] ByRef 
   trimset As Const String = " " ) As String
   Declare Function RTrim ( ByRef str As Const WString, [ Any ] ByRef 
   trimset As Const WString = WStr(" ") ) As WString

Usage
   result = RTrim[$]( str [, [ Any ] trimset ] )

Parameters
   str
      The source string.
   trimset
      The substring to trim.

Return Value
   Returns the trimmed string.

Description
   This procedure trims surrounding characters from the right (end) of a 
   source string. Substrings matching trimset will be trimmed if specified, 
   otherwise spaces (ASCII code 32) are trimmed.

   If the Any keyword is used, any character matching a character in 
   trimset will be trimmed.

   All comparisons are case-sensitive.

Example
   Dim s1 As String = "Article 101  "
   Print "'" + RTrim(s1) + "'"
   Print "'" + RTrim(s1, " 01") + "'"
   Print "'" + RTrim(s1, Any " 10") + "'"

   Dim s2 As String = "Test Pattern aaBBaaBaa"
   Print "'" + RTrim(s2, "Baa") + "'"
   Print "'" + RTrim(s2, Any "Ba") + "'"

   will produce the output:


   'Article 101'
   'Article 101  '
   'Article'
   'Test Pattern aaB'
   'Test Pattern '

Platform Differences
   * DOS version/target of FreeBASIC does not support the wide-character 
     version of RTrim.

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * QB does not support specifying a trimset string or the ANY clause.

See also
   * LTrim
   * Trim



-------------------------------------------------------------- KeyPgRun ----
Run

Transfers execution to an external program

Syntax
   Declare Function Run ( ByRef program As Const String, ByRef arguments As 
   Const String = "" ) As Long

Usage
   result = Run( program [, arguments ] )

Parameters
   program
      The file name (including file path) of the program (executable) to 
      transfer control to.
   arguments
      The command-line arguments to be passed to the program.

Return Value
   Returns negative one (-1) if the program could not be executed.

Description
   Transfers control over to an external program. When the program exits, 
   execution will return to the system.

Example
   '' Attempt to transfer control to "program.exe" in the current directory.
   Dim result As Integer = Run("program.exe")

   '' at this point, "program.exe" has failed to execute, and
   '' result will be set to -1.

Platform Differences
   * Linux requires the program case matches the real name of the file. 
     Windows and DOS  are case insensitive. The program being run may be 
     case sensitive for its command line parameters.
   * Path separators in Linux are forward slashes ("/"). Windows uses 
     backward slashes ("\") although some versions of Windows allow forward 
     slashes.  DOS uses backward slashes. 

Differences from QB
   * Run needs the full executable name, including extension (.exe) on 
     platforms that have one (Win32, DOS).
   * Returning an error code is new to FreeBASIC.

See also
   * Exec transfer temporarily, with arguments  
   * Chain transfer temporarily, without arguments
   * Command pick arguments




============================================================================
    S

------------------------------------------------------------- KeyPgSadd ----
SAdd

Returns a pointer to a string variable's data

Syntax
   Declare Function SAdd ( ByRef str As String ) As ZString Ptr
   Declare Function SAdd ( ByRef str As WString ) As WString Ptr
   Declare Function SAdd ( ByRef str As ZString ) As ZString Ptr

Usage
   result = SAdd( str )

Parameters
   str
      the string expression or variable to get the address of

Return Value
   A pointer to the data associated with str.

Description
   Returns the memory offset of the string data in the string variable.

Example
   Dim s As String

   Print SAdd(s)
   s = "hello"
   Print SAdd(s)
   s = "abcdefg, 1234567, 54321"
   Print SAdd(s)

Differences from QB
   * QB returned an integer instead of a pointer.

See also
   * StrPtr
   * VarPtr
   * ProcPtr



------------------------------------------------------------ KeyPgScope ----
Scope...End Scope

Statement to begin a new scope block

Syntax
   Scope
      [statements]
   End Scope

Description
   The Scope block allows variables to be (re)defined and used locally in a 
   program.

   When a variable is (re)defined with Dim within a scope structure, this 
   local working variable can be used from its (re)definition until the end 
   of the scope.  During this time, any variables outside the scope that 
   have the same name will be ignored, and will not be accessible by that 
   name. Any statements in the Scope block before the variable is redefined 
   will use the variable as defined outside the Scope.

   The local variables are reserved on stack at granularity level of each 
   procedure (including the main part of the program), not at granularity 
   level of each individual scope block. So a same memory space can be used 
   by local variables belonging to different scope blocks.

   To access duplicated symbols defined as global outside the scope block, 
   add one or preferably two dot(s) as prefix: .SomeSymbol or preferably ..
   SomeSymbol (or only ..SomeSymbol if inside a With..End With block).

   Scope..End Scope is not permitted when compiling with in the -lang qb 
   dialect.

Example
   Dim As Integer x = 5, y = 2
   Print "x ="; x; ", "; "y ="; y
   Scope
      Dim x As Integer = 3
      Print "x ="; x; ", "; "y ="; y
      Scope
         Dim y As Integer = 4
         Print "x ="; x; ", "; "y ="; y
      End Scope
   End Scope
   Print "x ="; x; ", "; "y ="; y

Dialect Differences
   * Explicit Scope..End Scope blocks are available only in the -lang fb 
     and -lang deprecated dialects.
   * Explicit Scope..End Scope blocks are not available in the -lang fblite
     and -lang qb dialects.

Differences from QB
   * New to FreeBASIC

See also
   * Dim
   * ReDim
   * Static
   * Var
   * Byref (Variables)



--------------------------------------------------- KeyPgScreengraphics ----
Screen (Graphics)

Initializes a graphics mode using QB-like mode numbers

Syntax
   -lang fb|fblite dialects:
      Screen mode [, [ depth ] [, [ num_pages ] [, [ flags ] [, [ 
      refresh_rate ]]]]]
      Screen , [ active_page ] [, [ visible_page ]]
   -lang qb dialect:
      Screen [ mode ] [, [ colormode ] [, [ active_page ] [, [ visible_page 
      ]]]]
 
Parameters
   mode 
      is a QB style graphics screen mode number (see below).  If mode is 0, 
      then any currently set graphics mode is closed, and all functions 
      resume their normal console-mode functionality.  See below for 
      available modes.
   depth
      is the color depth in bits per pixel.  This only has an effect for 
      modes 14 and higher.  Values of 8, 16 and 32 are allowed.  15 and 24 
      are also allowed as aliases for 16 and 32, respectively.  If omitted, 
      it defaults to 8.
   num_pages
      is the number of video pages you want, see below.  If omitted, it 
      defaults to 1.
   flags
      Are used to select several things as graphics driver priority, 
      fullscreen mode. There are constants predefined in the fbgfx.bi file 
      ready to use.  See the page ScreenRes for available flags.
   refresh_rate
      requests a refresh rate.  If it is not available in the present card 
      or the parameter is omitted, FreeBASIC chooses the rate 
      automatically.
   active_page
      Used to set the active page, where printing/drawing commands take 
      effect
   visible_page
      Used to set the visible page, which is shown to the user
   colormode
      Unused - allowed for compatibility with the QB syntax

Description
   Screen tells the compiler to link the GfxLib and initializes a QB-only, 
   QB-on-GUI or OpenGL graphics mode, depending on the flags setting.

   In QB-only modes a dumb window or fullscreen resolution is set, one or 
   more buffers in standard memory are created, console commands are 
   redirected to their graphic versions, a default palette is set and an 
   automatic screen refresh thread is started.  QB-like graphics and 
   console statements can be used.

   In QB-on-GUI modes one or more buffers in standard memory are created, 
   console commands are redirected to their graphic versions and a 
   default palette is set.  QB-like graphics and console statements can be 
   used.  It is up to the user to create a window and to refresh it with 
   the contents of the graphics buffers.

   In OpenGL modes a dumb window or fullscreen resolution is set, one or 
   more buffers in standard memory are created, and the OS's OpenGL library 
   is initialized.  From here only OpenGL commands can be used; QB-like and 
   console commands are forbidden.  This allows to initialize OpenGL in a 
   portable way; you can then also use ScreenControl to properly customize 
   the GL pixel format to be used before Screen is called or to retrieve 
   the list of supported OpenGL extensions after a mode has been set, and 
   ScreenGLProc to obtain extension function pointers.

   Any buffer that is created in standard memory uses one of three 
   supported internal pixel formats, depending on the desired color depth; 
   see Internal pixel formats for details.

   If Screen fails to set the required mode, an "Illegal function call" 
   error is issued and the screen pointer is set to 0. Thus Screen failures 
   can be detected using standard On Error processing or retrieving the 
   screen pointer with ScreenPtr.

   Before setting a fullscreen mode the program should check if that mode 
   is available in the graphics card using ScreenList.

mode details
   Available modes list:
   QB compatibility modes:
   +-------+----------+---------+--------------+-----------+----------------------------------------+
   |Mode nr|Resolution|Emulation|Text          |char size  |colors on screen                        |
   |1      |320x200   |CGA      |40X25         |8x8        |16 background, 1 of four sets foreground|
   |2      |640x200   |CGA      |80x25         |8x8        |16 colors to 2 attributes               |
   |7      |320x200   |EGA      |40x25         |8x8        |16 colors to 16 attributes              |
   |8      |640x200   |EGA      |80x25         |8x8        |16 colors to 16 attributes              |
   |9      |640x350   |EGA      |80x25 0r 80x43|8x14 or 8x8|16 colors to 16 attributes              |
   |11     |640x480   |VGA      |80x30 or 80x60|8x16 or 8x8|256K colors to 2 attributes             |
   |12     |640x480   |VGA      |80x30 or 80x60|8x16 or 8x8|256K colors to 16 attributes            |
   |13     |320x200   |MCGA     |40X25         |8X8        |256K colors to 256 attributes           |
   +-------+----------+---------+--------------+-----------+----------------------------------------+

   New FreeBASIC modes:
   +-------+----------+---------+-----------------+-----------+---------------------------------------------+
   |Mode nr|Resolution|Emulation|Text             |char size  |colors on screen                             |
   |14     |320x240   |         |40x30            |8x8        |256K colors to 256 attributes or direct color|
   | 15    |400x300   |         |50x37            |8x8        |256K colors to 256 attributes or direct color|
   | 16    |512x384   |         |64x24 or 64x48   |8x16 or 8x8|256K colors to 256 attributes or direct color|
   |17     |640x400   |         |80x25 or 80x50   |8x16 or 8x8|256K colors to 256 attributes or direct color|
   |18     |640x480   |         |80x30 or 80x60   |8x16 or 8x8|256K colors to 256 attributes or direct color|
   | 19    |800x600   |         |100x37 or 100x75 |8x16 or 8x8|256K colors to 256 attributes or direct color|
   |20     |1024x768  |         |128x48 or 128x96 |8x16 or 8x8|256K colors to 256 attributes or direct color|
   | 21    |1280x1024 |         |160x64 or 160x128|8x16 or 8x8|256K colors to 256 attributes or direct color|
   +-------+----------+---------+-----------------+-----------+---------------------------------------------+
 

depth details
   For modes 14 and up, the depth parameter changes the color depth to the 
   specified new one; if depth is not specified, these modes run in 8bpp.  
   For modes 13 and below, depth has no effect.

num_pages details
   You can request any number of pages for any video mode; if you omit the 
   parameter, only the visible page (number 0) will be available.  A page 
   is either the visible screen or an offscreen buffer, you can show a page 
   while working on another one; see the ScreenSet statement for details.  
   All pages are created in standard memory, the video card memory is never 
   used for video buffering.

flags details:
   (documented at the page ScreenRes)

Other details
   While in windowed mode, clicking on the window close button will add a 
   keypress of (Chr(255) & "k") to the Inkey buffer.  Clicking on the 
   Maximize window button will switch to fullscreen mode if possible.  A 
   successful Screen call sets currently visible and working pages both to 
   page number 0, resets the palette to the specified mode one (see 
   Default palettes), resets the clipping region to the size of the screen, 
   disables custom coordinates mappings, moves the graphics cursor to the 
   center of the screen, moves the text cursor to the top-left corner of 
   the screen (but never visible on any graphics screen), and sets 
   foreground and background colors to bright white and black respectively.

Note on using Screen 0
   Screen 0 closes any graphics window, but also clears the console window 
   if it exists.
   Screen 0, , , GFX_SCREEN_EXIT (with GFX_SCREEN_EXIT=&h80000000) also 
   closes any graphics window, but does not clear the console window if it 
   exists (previous text is preserved).

Example
   ' Sets screen mode 13 (320*200, 8bpp)
   Screen 13
   Print "Screen mode 13 set"

   Sleep

   #include "fbgfx.bi"
   #if __FB_LANG__ = "fb"
   Using FB '' Screen mode flags are in the FB namespace in lang FB
   #endif

   ' Sets screen mode 18 (640*480) with 32bpp color depth and 4 pages, in windowed mode; switching disabled
   Screen 18, 32, 4, (GFX_WINDOWED Or GFX_NO_SWITCH)

   ' Check to make sure Screen was opened successfully
   If ScreenPtr = 0 Then
      Print "Error setting video mode!"
      End
   End If

   Print "Successfully set video mode"
   Sleep

Platform Differences
   * In DOS, Windowing and OpenGL related switches are not available, and 
     other issues, see GfxLib overview

Dialect Differences
   * In the -lang fb and -lang fblite dialects, the usage is:
      Screen mode [, [depth] [, [num_pages] [, [flags] [, [refresh_rate
      ]]]]]
   or:
      Screen , [active_page] [, [visible_page]]]

   * In the -lang qb dialect, the usage is:
      Screen [mode] [, [colormode] [, [active_page] [, [visible_page]]]]

Differences from QB
   * None in the -lang qb dialect.
   * In QB the syntax was Screen mode,colormode,active_page,visible_page. 
     Of those parameters FreeBASIC supports only mode and redefines the 
     rest. The use of Screen , , apage,vpage to swap screen pages is only 
     available in the -lang qb dialect.
   * ScreenSet should be used in the -lang fb and -lang fblite dialects.

See also
   * Screen (Console)
   * ScreenRes More flexible alternative to Screen
   * ScreenList Check display modes available for FB GfxLib to use
   * ScreenControl Select driver and more 
   * ScreenLock
   * ScreenUnlock
   * ScreenPtr Semi-low level access
   * ScreenSet
   * ScreenCopy
   * ScreenInfo
   * ScreenGLProc
   * Internal pixel formats



------------------------------------------------------- KeyPgScreenCons ----
Screen (Console)

Gets the character or color attribute at a given location

Syntax
   Declare Function Screen ( ByVal row As Long, ByVal column As Long, ByVal 
   colorflag As Long = 0 ) As Long

Usage
   result = Screen( row, column [, colorflag ] )

Parameters
   row
      1-based offset from the top left corner of the console.
   column
      1-based offset from the top left corner of the console.
   colorflag
      If equal to 0, the ASCII code is returned, otherwise the color 
      attribute is returned.  If omitted, it defaults to 0.

Return Value
   The ASCII or color attribute of the character.

Description
   Screen returns the character or the color attribute found at a given 
   position of a console output. It works in console mode and in graphics 
   mode.

   The format of the color attribute depends on the current color depth:

   If the color type is a palette type with up to 4 bits per pixel (such as 
   the Win32 console), then the color attribute is an 8-bit value, where 
   the higher four bits hold the cell background color and the lower four 
   bits hold the foreground (character) color.

   If the color type is an 8-bit palette, then the color attribute is a 
   16-bit value, where the high byte holds the background color and the low 
   byte holds the foreground color.

   If the color type is full color, then the color attribute is a 32-bit 
   integer, holding a single color value.  If colorflag is equal to 1, then 
   the foreground color is returned; if colorflag is equal to 2, then the 
   background color is returned.

   The color values for the standard 16 color palette are:

         +-----+-------+-----+------------+
         |Value|Color  |Value|Color       |
         |0    |Black  |8    |Gray        |
         |1    |Blue   |9    |Bright Blue |
         |2    |Green  |10   |Bright Green|
         |3    |Cyan   |11   |Bright Cyan |
         |4    |Red    |12   |Bright Red  |
         |5    |Magenta|13   |Pink        |
         |6    |Brown  |14   |Yellow      |
         |7    |White  |15   |Bright White|
         +-----+-------+-----+------------+

Example
   Dim character_ascii_value As Integer
   Dim attribute As Integer
   Dim background As Integer
   Dim cell_color As Integer
   Dim row As Integer, col As Integer

   character_ascii_value = Screen( row, col )
   attribute = Screen( row, col, 1 )
   background = attribute Shr 4
   cell_color = attribute And &hf

   '' open a graphics screen with 4 bits per pixel
   '' (alternatively, omit this line to use the console)
   ScreenRes 320, 200, 4

   '' print a character
   Color 7, 1
   Print "A"

   Dim As UInteger char, col, fg, bg

   '' get the ASCII value of the character we've just printed
   char = Screen(1, 1, 0)

   ''get the color attributes
   col = Screen(1, 1, 1)
   fg = col And &HF
   bg = (col Shr 4) And &HF

   Print Using "ASCII value: ### (""!"")"; char; Chr(char)
   Print Using "Foreground color: ##"; fg
   Print Using "Background color: ##"; bg
   Sleep

   '' open a graphics screen with 8 bits per pixel
   ScreenRes 320, 200, 8

   '' print a character
   Color 30, 16
   Print "Z"

   Dim As UInteger char, col, fg, bg

   '' get the ASCII value of the character we've just printed
   char = Screen(1, 1, 0)

   ''get the color attributes
   col = Screen(1, 1, 1)
   fg = col And &HFF
   bg = (col Shr 8) And &HFF

   Print Using "ASCII value: ### (""!"")"; char; Chr(char)
   Print Using "Foreground color: ###"; fg
   Print Using "Background color: ###"; bg
   Sleep

   '' open a full-color graphics screen
   ScreenRes 320, 200, 32

   '' print a character
   Color RGB(255, 255, 0), RGB(0, 0, 255) 'yellow on blue
   Print "M"

   Dim As Integer char, fg, bg

   '' get the ASCII value of the character we've just printed
   char = Screen(1, 1, 0)

   ''get the color attributes
   fg = Screen(1, 1, 1)
   bg = Screen(1, 1, 2)

   Print Using "ASCII value: ### (""!"")"; char; Chr(char)
   Print Using "Foreground color: &"; Hex(fg, 8)
   Print Using "Background color: &"; Hex(bg, 8)
   Sleep

Platform Differences
   * On the Linux version, the value returned can differ from the 
     character shown on the console.  For example, unprintable control 
     codes - such as the LF character (10) that implicitly occurs after the 
     end of Printed text - may be picked up instead of the untouched 
     character in its place.

Differences from QB
   * In QB Screen triggered an error if the coordinates were out of 
     screen.

See also
   * Screen (Graphics)
   * Color



------------------------------------------------------- KeyPgScreencopy ----
ScreenCopy

Copies the contents of a graphical page into another graphical page

Syntax
   Declare Function ScreenCopy ( ByVal from_page As Long = -1, ByVal 
   to_page As Long = -1 ) As Long

Usage
   ScreenCopy [ from_page ] [, to_page ]

Parameters
   from_page
      page to copy from
   to_page
      page to copy to

Return Value
   Returns zero (0) if successful, or a non-zero error code to indicate a 
   failure.

Description
   from_page is the page to copy from. If this argument is omitted, the 
   current work page is assumed.  to_page is the page to copy to. If this 
   argument is omitted, the currently visible page is assumed.  Page 
   numbers range from 0 to num_pages - 1, where num_pages is the number of 
   pages specified when setting the graphics mode with ScreenRes or Screen.

   You can use this function to add a double buffer to your graphics. Any 
   graphics screen mode with multiple pages supports this function.

   ScreenCopy is inactive if the destination page is locked.

   There are two other functions similar to this: Flip and PCopy.  Flip is 
   designed to work in OpenGL modes, while PCopy supports console pages on 
   some platforms.  Both do the same thing as ScreenCopy in normal graphics 
   modes.

   The error code returned by ScreenCopy can be checked using Err in the 
   next line. The function version of  ScreenCopy returns directly the 
   error code as a 32 bit Long.

Example
   See also ScreenSet example.

   '' 320x200x8, with 3 pages
   Screen 13,,3

   '' image for working page #1 (visible page #0)
   ScreenSet 1, 0
   Cls
   Circle( 160, 100 ), 90, 1 ,,,, f
   Circle( 160, 100 ), 90, 15
   Print "Press 2 to copy page #2 to visible page"
   Print "Press escape to exit"

   '' image for working page #2 (visible page #0)
   ScreenSet 2, 0
   Cls
   Line( 50, 50 )-( 270, 150 ), 2, bf
   Line( 50, 50 )-( 270, 150 ), 15, b
   Print "Press 1 to copy page #1 to visible page"
   Print "Press escape to exit"

   '' page #0 is the working page (visible page #0)
   ScreenSet 0, 0
   Cls
   Print "Press 1 to copy page #1 to visible page"
   Print "Press 2 to copy page #2 to visible page"
   Print "Press escape to exit"

   Dim k As String

   Do
     k = Inkey
     Select Case k
     Case Chr(27)
      Exit Do
     Case "1"
      ScreenCopy 1, 0
     Case "2"
      ScreenCopy 2, 0
     End Select

     Sleep 25
   Loop

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Screencopy.

Differences from QB
   * New to FreeBASIC. It is a graphics-only version of PCopy - which 
     works in both text and graphics modes.

See also
   * PCopy
   * Screen (Graphics)
   * ScreenRes
   * ScreenSet



---------------------------------------------------- KeyPgScreencontrol ----
ScreenControl

Sets or gets internal graphics library settings

Syntax
   Declare Sub ScreenControl ( ByVal what As Const Long, ByRef param1 As 
   Long = &h80000000, ByRef param2 As Long = &h80000000, ByRef param3 As 
   Long = &h80000000, ByRef param4 As Long = &h80000000 )
   Declare Sub ScreenControl ( ByVal what As Const Long, ByRef param1 As 
   LongInt, ByRef param2 As LongInt = &h80000000, ByRef param3 As LongInt = 
   &h80000000, ByRef param4 As LongInt = &h80000000 )
   Declare Sub ScreenControl ( ByVal what As Const Long, ByRef param As 
   String)

Usage
   in the LONG (or INTEGER<32>) version of the sub:
      ScreenControl( what [, [ param1 ] [, [ param2 ] [, [ param3 ] [, 
      param4 ]]]] )
         or,
      ScreenControl( what , param )
   in the LONGINT (or INTEGER<64>) version of the sub:
      ScreenControl( what , param1 [, [ param2 ] [, [ param3 ] [, param4 
      ]]] )
         or,
      ScreenControl( what , param )

Parameters
   what
      specifies the function to perform
   param1
      first integer parameter, contains value to be set on entry or value 
      got on exit
   param2
      second integer parameter, contains value to be set on entry or value 
      got on exit
   param3
      third integer parameter, contains value to be set on entry or value 
      got on exit
   param4
      fourth integer parameter, contains value to be set on entry or value 
      got on exit
   param
      string parameter, contains text to be set on entry or text got on 
      exit

Description
   This function can be used to set or get internal GfxLib states. The what 
   parameter specifies which operation to perform. On operations that set 
   states, the param* parameters must contain the values to be set. On 
   operations that get states, param* will hold the values returned by 
   GfxLib when the function returns.
   The meaning of the param* parameters depend on the what parameter, whose 
   possible values are defined as constants in fbgfx.bi.  In lang fb, they 
   are set to be stored in the FB Namespace.
   Below is a list of the supported what constants - and their values as 
   defined at time of writing - along with the parameters associated with 
   them.

   Supported operations

      Note:
         (*) denotes operations that are allowed while a graphics mode has 
         not yet been set via Screen (Graphics) or ScreenRes,
         (**) denotes the operations that must be performed before the 
         graphics mode is set via Screen (Graphics) or ScreenRes,
         for all other operations, return values are zero (0) or the empty 
         string ("") and the operation has no effect if a graphics mode is 
         not available at call time.

      Get operations
   * GET_WINDOW_POS Returns the current window position, in desktop 
     coordinates.
      [OUT] param1 x
      [OUT] param2 y
   * (*) GET_WINDOW_TITLE Returns the title of the program window.
      [OUT] param title
   * GET_WINDOW_HANDLE Returns a handle to the program window.
      [OUT] param1 handle; this is a HWND in Windows, a "Window" XID in X11
      [OUT] param2 display ptr in X11
   * (*) GET_DESKTOP_SIZE Returns the desktop size, in pixels.
      [OUT] param1 width
      [OUT] param2 height
   * GET_SCREEN_SIZE Returns the current screen size in pixels.
      [OUT] param1 width
      [OUT] param2 height
   * GET_SCREEN_DEPTH Returns current graphics mode screen depth.
      [OUT] param1 bits per pixel
   * GET_SCREEN_BPP Returns current graphics mode BPP.
      [OUT] param1 bytes per pixel
   * GET_SCREEN_PITCH Returns the current graphics mode framebuffer pitch, 
     in bytes.
      [OUT] param1 pitch
   * GET_SCREEN_REFRESH Returns the current graphics mode refresh rate, in 
     hertz.
      [OUT] param1 rate
   * GET_DRIVER_NAME Returns the current graphics mode driver name.
      [OUT] param name
   * GET_TRANSPARENT_COLOR Returns the transparent color value for the 
     current graphics mode depth.
      [OUT] param1 value
   * GET_VIEWPORT Returns the current viewport as set by the 
     View (Graphics) statement, in screen coordinates.
      [OUT] param1 x1
      [OUT] param2 y1
      [OUT] param3 x2
      [OUT] param4 y2
   * GET_PEN_POS Returns the last graphical pen position, in screen 
     coordinates. This position is used in graphics functions supporting 
     relative coordinates using the Step keyword.
      [OUT] param1 x
      [OUT] param2 y
   * GET_COLOR Returns the current graphics mode color.
      [OUT] param1 foreground
      [OUT] param2 background
   * GET_ALPHA_PRIMITIVES Returns if primitives drawing support for alpha 
     channel is enabled.
      [OUT] param1 TRUE (-1) if alpha primitives is enabled, FALSE (0) 
      otherwise
   * GET_GL_EXTENSIONS Returns a string holding all supported GL 
     extensions, or the empty string if not in OpenGL mode.
      [OUT] param supported GL extensions
   * GET_HIGH_PRIORITY Returns if GFX_HIGH_PRIORITY was specified in the 
     flags passed to Screen or ScreenRes.
      [OUT] param1 higher priority graphics processing enabled

      Set operations
   * SET_WINDOW_POS Sets the current program window position, in desktop 
     coordinates.
      [IN] param1 x
      [IN] param2 y
   * (*) SET_WINDOW_TITLE Sets the current program window title. This is 
     equivalent to calling WindowTitle( param ).
      [IN] param title
   * SET_PEN_POS Sets the current graphical pen position, in screen 
     coordinates. This position is used in graphics functions supporting 
     relative coordinates using the Step keyword.
      [IN] param1 x
      [IN] param2 y
   * (*) SET_DRIVER_NAME Sets the name of the internal graphics driver to 
     be used in subsequent calls to Screen or ScreenRes.
      [IN] param driver name
   * SET_ALPHA_PRIMITIVES Sets if primitives drawing should honor alpha 
     channel.
      [IN] param1 enabled
   * (*) SET_GL_COLOR_BITS Sets the number of bits dedicated to the OpenGL 
     color buffer
      [IN] param1 bits
   * (*) SET_GL_COLOR_RED_BITS Sets the number of bits dedicated to the 
     red component of the OpenGL color buffer
      [IN] param1 bits
   * (*) SET_GL_COLOR_GREEN_BITS Sets the number of bits dedicated to the 
     green component of the OpenGL color buffer
      [IN] param1 bits
   * (*) SET_GL_COLOR_BLUE_BITS Sets the number of bits dedicated to the 
     blue component of the OpenGL color buffer
      [IN] param1 bits
   * (*) SET_GL_COLOR_ALPHA_BITS Sets the number of bits dedicated to the 
     alpha component of the OpenGL color buffer
      [IN] param1 bits
   * (*) SET_GL_DEPTH_BITS Sets the number of bits dedicated to the OpenGL 
     depth buffer
      [IN] param1 bits
   * (*) SET_GL_STENCIL_BITS Sets the number of bits dedicated to the 
     OpenGL stencil buffer
      [IN] param1 bits
   * (*) SET_GL_ACCUM_BITS Sets the number of bits dedicated to the OpenGL 
     accumulation buffer
      [IN] param1 bits
   * (*) SET_GL_ACCUM_RED_BITS Sets the number of bits dedicated to the 
     red component of the OpenGL accumulation buffer
      [IN] param1 bits
   * (*) SET_GL_ACCUM_GREEN_BITS Sets the number of bits dedicated to the 
     green component of the OpenGL accumulation buffer
      [IN] param1 bits
   * (*) SET_GL_ACCUM_BLUE_BITS Sets the number of bits dedicated to the 
     blue component of the OpenGL accumulation buffer
      [IN] param1 bits
   * (*) SET_GL_ACCUM_ALPHA_BITS Sets the number of bits dedicated to the 
     alpha component of the OpenGL accumulation buffer
      [IN] param1 bits
   * (*) SET_GL_NUM_SAMPLES Sets the number of samples to be used for 
     OpenGL multisampling
      [IN] param1 samples
   * (**) SET_GL_2D_MODE Sets OpenGL 2D render
      [IN] param1:
         OGL_2D_NONE No rendering
         OGL_2D_MANUAL_SYNC Manual rendering (when Flip is called)
         OGL_2D_AUTO_SYNC Automatic rendering
   * (**) SET_GL_SCALE Apply a zoom factor on OpenGL 2D render (only 
     allowed if OpenGL 2D render mode has yet been activated via 
     SET_GL_2D_MODE)
      [IN] param1 zoom factor (0: no rendering)

      Other operations
   * POLL_EVENTS Cause the library to poll all events, ie to check the 
     system event queue, specifically used for retrieving keyboard and 
     mouse events.  This is most useful for OpenGL code where Flip is not 
     used, as normally Flip will cause these events to be polled.

Example
   '' include fbgfx.bi for some useful definitions
   #include "fbgfx.bi"

   '' use FB namespace for easy access to types/constants
   Using FB

   Dim e As Event
   Dim As Integer x0, y0, x, y
   Dim As Integer shakes = 0
   Dim As Any Ptr img

   ScreenRes 320, 200, 32
   Print "Click to shake window"

   '' find window coordinates
   ScreenControl GET_WINDOW_POS, x0, y0

   Do

      If (shakes > 0) Then
         
         '' do a shake of the window

         If (shakes > 1) Then

            '' move window to a random position near its original coordinates
            x = x0 + Int(32 * (Rnd() - 0.5))
            y = y0 + Int(32 * (Rnd() - 0.5))
            ScreenControl SET_WINDOW_POS, x, y

         Else

            '' move window back to its original coordinates
            ScreenControl SET_WINDOW_POS, x0, y0

         End If

         shakes -= 1

      End If

      If (ScreenEvent(@e)) Then
         Select Case e.type
         
         '' user pressed the mouse button
         Case EVENT_MOUSE_BUTTON_PRESS

            If (shakes = 0) Then
               '' set to do 20 shakes
               shakes = 20

               '' find current window coordinates to shake around
               ScreenControl GET_WINDOW_POS, x0, y0
            End If

         '' user closed the window or pressed a key
         Case EVENT_WINDOW_CLOSE, EVENT_KEY_PRESS
            '' exit to end of program
            Exit Do

         End Select
      End If

      '' free up CPU for other programs
      Sleep 5

   Loop
      

   '' include fbgfx.bi for some useful definitions
   #include "fbgfx.bi"

   Dim As String driver

   #ifdef __FB_WIN32__
   '' set graphics driver to GDI (Win32 only), before calling ScreenRes
   ScreenControl FB.SET_DRIVER_NAME, "GDI"
   #endif

   ScreenRes 640, 480

   '' fetch graphics driver name and display it to user
   ScreenControl FB.GET_DRIVER_NAME, driver
   Print "Graphics driver name: " & driver

   '' wait for a keypress before closing the window
   Sleep
      

Version
   * Before fbc 1.08.0:
         Syntax:
            Declare Sub ScreenControl ( ByVal what As Long, ByRef param1 As 
            Integer = 0, ByRef param2 As Integer = 0, ByRef param3 As 
            Integer = 0, ByRef param4 As Integer = 0 )
            Declare Sub ScreenControl ( ByVal what As Long, ByRef param As 
            String = "" )
         Usage:
            ScreenControl( what [, [ param1 ] [, [ param2 ] [, [ param3 ] 
            [, [ param4 ]]]]] )
               or,
            ScreenControl( what [, param ] )

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Screencontrol.

Differences from QB
   * New to FreeBASIC

See also
   * Screen (Graphics)
   * ScreenEvent
   * ScreenInfo
   * WindowTitle
   * View (Graphics)



------------------------------------------------------ KeyPgScreenevent ----
ScreenEvent

Queries for and retrieves system events.

Syntax
   Declare Function ScreenEvent ( ByVal event As Any Ptr = 0 ) As Long

Usage
   result = ScreenEvent( [ event ] )

Parameters
   event
      Specifies the buffer where the function should store the event data.

Return Value
   Returns -1 if there are pending events to be retrieved, 0 otherwise.

Description
   This function returns the latest available system event from the 
   internal GfxLib events queue. By "event" we mean any mouse or keyboard 
   activity, for example.

   The event data (if available) will be copied into the buffer pointed 
   that should be declared as an Event.
   On the Event page, see the list of event types and how to use their 
   associated fields (see also the example below).

   Querying for events
      The function returns -1 if there are pending events to be retrieved, 
      0 otherwise. If the event parameter is set to 0 (the default if 
      omitted) ScreenEvent will not be able to copy the event data and it 
      will not dequeue it from the internal events queue. Calling the 
      function this way can be useful to check if there are pending events 
      without actually fetching them.

   Note
      If you receive a KEY_PRESS, KEY_RELEASE or KEY_REPEAT event, it does 
      not clear the keyboard buffer.  If you need the buffer to be clear 
      after you receive the event, you will need to clear it manually.  See 
      Inkey.

Example
   '' include fbgfx.bi for some useful definitions
   #include "fbgfx.bi"
   #if __FB_LANG__ = "fb"
   Using fb '' constants and structures are stored in the FB namespace in lang fb
   #endif

   Dim e As Event

   ScreenRes 640, 480
   Do
      If (ScreenEvent(@e)) Then
         Select Case e.type
         Case EVENT_KEY_PRESS
            If (e.scancode = SC_ESCAPE) Then
               End
            End If
            If (e.ascii > 0) Then
               Print "'" & e.ascii & "'";
            Else
               Print "unknown key";
            End If
            Print " was pressed (scancode " & e.scancode & ")"
         Case EVENT_KEY_RELEASE
            If (e.ascii > 0) Then
               Print "'" & e.ascii & "'";
            Else
               Print "unknown key";
            End If
            Print " was released (scancode " & e.scancode & ")"
         Case EVENT_KEY_REPEAT
            If (e.ascii > 0) Then
               Print "'" & e.ascii & "'";
            Else
               Print "unknown key";
            End If
            Print " is being repeated (scancode " & e.scancode & ")"
         Case EVENT_MOUSE_MOVE
            Print "mouse moved to " & e.x & "," & e.y & " (delta " & e.dx & "," & e.dy & ")"
         Case EVENT_MOUSE_BUTTON_PRESS
            If (e.button = BUTTON_LEFT) Then
               Print "left";
            ElseIf (e.button = BUTTON_RIGHT) Then
               Print "right";
            Else
               Print "middle";
            End If
            Print " button pressed"
         Case EVENT_MOUSE_BUTTON_RELEASE
            If (e.button = BUTTON_LEFT) Then
               Print "left";
            ElseIf (e.button = BUTTON_RIGHT) Then
               Print "right";
            Else
               Print "middle";
            End If
            Print " button released"
         Case EVENT_MOUSE_DOUBLE_CLICK
            If (e.button = BUTTON_LEFT) Then
               Print "left";
            ElseIf (e.button = BUTTON_RIGHT) Then
               Print "right";
            Else
               Print "middle";
            End If
            Print " button double clicked"
         Case EVENT_MOUSE_WHEEL
            Print "mouse wheel moved to position " & e.z
         Case EVENT_MOUSE_ENTER
            Print "mouse moved into program window"
         Case EVENT_MOUSE_EXIT
            Print "mouse moved out of program window"
         Case EVENT_WINDOW_GOT_FOCUS
            Print "program window got focus"
         Case EVENT_WINDOW_LOST_FOCUS
            Print "program window lost focus"
         Case EVENT_WINDOW_CLOSE
            End
         Case EVENT_MOUSE_HWHEEL
            Print "horizontal mouse wheel moved to position " & e.w
         End Select
      End If

      Sleep 1
   Loop

Platform Differences
   * ScreenEvent does not return window related events in the DOS version, 
     but does return input events.

Dialect Differences
   * Not available in the -lang qb dialect.

Differences from QB
   * New to FreeBASIC

See also
   * Event
   * Screen (Graphics)
   * Inkey
   * MultiKey
   * GetMouse
   * Event Handling



----------------------------------------------------- KeyPgScreenglproc ----
ScreenGLProc

Gets the address of an OpenGL procedure

Syntax
   Declare Function ScreenGLProc ( ByRef procname As Const String ) As Any 
   Ptr

Parameters
   procname
      name of the procedure to retrieve the address of

Description
   This function can be used to get the address of any OpenGL procedure, to 
   be used to retrieve the pointers to new functions associated with OpenGL 
   extensions. If given procedure named procname cannot be found, 
   ScreenGLProc will return NULL (0).

Example
   '' include fbgfx.bi for some useful definitions
   #include "fbgfx.bi"

   Dim SwapInterval As Function(ByVal interval As Integer) As Integer
   Dim extensions As String

   '' Setup OpenGL and retrieve supported extensions
   ScreenRes 640, 480, 32,, FB.GFX_OPENGL
   ScreenControl FB.GET_GL_EXTENSIONS, extensions

   If (InStr(extensions, "WGL_EXT_swap_control") <> 0) Then
      '' extension supported, retrieve proc address
      SwapInterval = ScreenGLProc("wglSwapIntervalEXT")
      If (SwapInterval <> 0) Then
         '' Ok, we got it. Set OpenGL to wait for vertical sync on buffer swaps
         SwapInterval(1)
      End If
   End If

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Screenglproc.

Platform Differences
   * Not available for DOS target.

Differences from QB
   * New to FreeBASIC

See also
   * Screen (Graphics)
   * ScreenControl



------------------------------------------------------- KeyPgScreeninfo ----
ScreenInfo

Retrieves information about current video mode or the desktop.

Syntax
   Declare Sub ScreenInfo ( ByRef w As Long = 0, ByRef h As Long = 0, ByRef 
   depth As Long = 0, ByRef bpp As Long = 0, ByRef pitch As Long = 0, ByRef 
   rate As Long = 0, ByRef driver As String = "" )
   Declare Sub ScreenInfo ( ByRef w As LongInt, ByRef h As LongInt, ByRef 
   depth As LongInt = 0, ByRef bpp As LongInt = 0, ByRef pitch As LongInt = 
   0, ByRef rate As LongInt = 0, ByRef driver As String = "" )

Usage
   in the LONG (or INTEGER<32>) version of the sub:
      ScreenInfo [ w ] [, [ h ] [, [ depth ] [, [ bpp ] [, [ pitch ] [, [ 
      rate ] [, driver ]]]]]]
   in the LONGINT (or INTEGER<64>) version of the sub:
      ScreenInfo w , h [, [ depth ] [, [ bpp ] [, [ pitch ] [, [ rate ] [, 
      driver ]]]]]

Parameters
   w
      Width.
   h
      Height.
   depth
      Color depth in bits.
   bpp
      Bytes per pixel.
   pitch
      Bytes per scan line.
   rate
      Refresh rate.
   driver
      Driver name.

Description
   This function can be useful to get current mode informations like 
   graphics driver name, color depth, screen size and more.

   If ScreenInfo is called when no graphics mode is set, it returns the 
   information about the desktop.

   Here's a description of available fields:

      +------+-------------------------------------------------------------------------------------------+
      |w     |Width of the screen in pixels                                                              |
      |h     |Height of the screen in pixels                                                             |
      |depth |Current pixel format bits per pixel: this can be 1, 2, 4, 8, 16, or 32                     |
      |bpp   |Bytes per pixel                                                                            |
      |pitch |Size of a framebuffer row in bytes                                                         |
      |rate  |Current refresh rate, or 0 if unknown                                                      |
      |driver|Name of current graphics driver in use, like DirectX (Direct2D added on new systems) or X11|
      +------+-------------------------------------------------------------------------------------------+

Example
   Dim w As Integer, h As Integer
   Dim depth As Integer
   Dim driver_name As String

   Screen 15, 32 
   ' Obtain info about current mode 
   ScreenInfo w, h, depth,,,,driver_name
   Print Str(w) + "x" + Str(h) + "x" + Str(depth); 
   Print " using " + driver_name + " driver" 
   Sleep 
   ' Quit graphics mode and obtain info about desktop 
   Screen 0 
   ScreenInfo w, h, depth 
   Print "Desktop running at " + Str(w) + "x" + Str(h) + "x" + Str(depth); 
      

Version
   * Before fbc 1.08.0:
         Syntax:
            Declare Sub ScreenInfo ( ByRef w As Integer = 0, ByRef h As 
            Integer = 0, ByRef depth As Integer = 0, ByRef bpp As Integer = 
            0, ByRef pitch As Integer = 0, ByRef rate As Integer = 0, ByRef 
            driver As String = "" )
         Usage:
            ScreenInfo [ w ] [, [ h ] [, [ depth ] [ , [ bpp ] [ , [ pitch 
            ] [ , [ rate ] [, driver ]]]]]]

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Screeninfo.

Differences from QB
   * New to FreeBASIC

See also
   * Screen (Graphics)



------------------------------------------------------- KeyPgScreenlist ----
ScreenList

Finds available fullscreen video modes

Syntax
   Declare Function ScreenList ( ByVal depth As Long = 0 ) As Long

Usage
   result = ScreenList( [ depth ] )

Parameters
   depth
      the color depth for which the list of modes is requested  (supported 
      depths are 8, 15, 16, 24 and 32)

Return Value
   returns 0, when there are no more resolutions to read.

Description
   It works like the Dir function: the first call to the function requires 
   the depth parameter to be specified, it  returns the lowest supported 
   resolution for the requested depth. Further calls to ScreenList without 
   arguments returns the next resolutions. When no more resolutions are 
   available, ScreenList returns 0.

   The result of ScreenList is encoded as a 32 bit value, with the screen 
   width as the High Word and the height as the Low Word.

   Resolutions are returned from lowest to highest supported ones. 

   It is safe to call this function before any graphics mode has been set.

   Dim As Integer mode, w, h

   Print "Resolutions supported at 8 bits per pixel:"

   mode = ScreenList(8)
   While (mode <> 0)
      w = HiWord(mode)
      h = LoWord(mode)
      Print w & "x" & h
      mode = ScreenList()
   Wend

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Screenlist.

Differences from QB
   * New to FreeBASIC

See also
   * Screen
   * ScreenRes



------------------------------------------------------- KeyPgScreenlock ----
ScreenLock

Locks the working page's frame buffer

Syntax
   Declare Sub ScreenLock ( )

Usage
   ScreenLock

Description
   All of FreeBASIC's Graphics Library functions draw to a frame buffer and 
   an automatic routine copies the frame buffer to the actual screen memory 
   at each draw. If the user program does a lot of drawing, the automatic 
   refreshes may take a significant amount of time.

   The ScreenLock function locks the automatic refresh, so several drawing 
   operations may be done before the screen refresh is performed, thus 
   increasing the speed of execution, and preventing the user from seeing 
   partial results. 

   Frame buffer memory may be freely accessed by using pointers (see 
   ScreenPtr) ONLY while the screen is locked. Primitive graphics 
   statements (Line, PSet, Draw String, ...)  may be used at any time.

   The screen refresh remains locked until the use of ScreenUnlock 
   statement, which resumes it.  

   Calls to ScreenLock must be paired with a matching call to ScreenUnlock. 
   The graphics driver keeps track of how many times ScreenLock has been 
   called using a counter.  Only the first call to ScreenLock actually 
   performs a locking operation.  Subsequent calls to ScreenLock only 
   increment the counter.  Conversely, ScreenUnlock only decrements the 
   lock counter until it reaches zero at which time the actual unlock 
   operation will be performed.  Using Screen or ScreenRes will release all 
   locks and set the lock counter back to zero before changing screen 
   modes.

   It is strongly recommended that the lock on a page be held for as short 
   a time as possible. Only screen drawing should occur while the screen is 
   locked, input/output and waiting must be avoided. In Win32 and Linux the 
   screen is locked by stopping the thread that processes also the OS' 
   events. If the screen is kept locked for a long time the event queue 
   could overflow and make the system unstable. When the induced lock time 
   becomes too long, use preferably the method of double buffering (with 
   ScreenCopy).

   The automatic refresh takes place only in the visible page of the frame 
   buffer. ScreenLock has no effect when drawing to pages other than the 
   visible one. 	

Example

   '' Draws a circle on-screen at the mouse cursor
   Dim As Integer mx, my
   Dim As String key

   ScreenRes 640, 480, 32

   Do

     'process
     GetMouse(mx, my)
     key = Inkey()

     'draw
     ScreenLock()
     Cls()
     Circle (mx, my), 8, RGB(255, 255, 255)
     ScreenUnlock()

     'free up CPU time
     Sleep(18, 1)
     
   Loop Until key = Chr(27) Or key = Chr(255, 107)

Platform Differences
   * In DOS, the mouse arrow does not react to mouse movements while the 
     screen is locked

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Screenlock.

Differences from QB
   * New to FreeBASIC

See also
   * Screen (Graphics) - Setting mode
   * ScreenRes - Setting mode
   * ScreenUnlock
   * ScreenPtr



-------------------------------------------------------- KeyPgScreenptr ----
ScreenPtr

Returns a pointer to the current work page's frame buffer

Syntax
   Declare Function ScreenPtr ( ) As Any Ptr

Usage
   result = ScreenPtr

Return Value
   a pointer to the current work page frame buffer memory, or NULL (0) if 
   no graphics mode is set.

Description
   ScreenPtr provides a way to directly read/write the working page's frame 
   buffer. ScreenLock should be used before any read or writes are 
   attempted. The pointer returned is valid up until any subsequent call to 
   Screen or ScreenRes, which invalidates it.

   ScreenPtr can also be used to test if a call to Screen or ScreenRes was 
   successful, indicated by a non-NULL (<> 0) return value.

   In order to access a pixel in the screen buffer, you will need to know 
   the screen's bytes per pixel and pitch (bytes per row), and also the 
   width and height to avoid going out of bounds.  This information can be 
   found out using ScreenInfo.
   Each row in the frame buffer is pitch bytes long.  The frame buffer 
   consists of height rows, stored in order of their position on the 
   screen, running from top to bottom, left to right.

   Because of the design of FreeBASIC graphics library, ScreenPtr (if 
   non-NULL) will always point to the backbuffer, and never to actual video 
   RAM.

Example
   Const SCREEN_WIDTH = 640, SCREEN_HEIGHT = 480
   Dim As Integer w, h, bypp, pitch

   '' Make 8-bit screen.
   ScreenRes SCREEN_WIDTH, SCREEN_HEIGHT, 8

   '' Get screen info (w and h should match the constants above, bypp should be 1)
   ScreenInfo w, h, , bypp, pitch

   '' Get the address of the frame buffer. An Any Ptr 
   '' is used here to allow simple pointer arithmetic
   Dim buffer As Any Ptr = ScreenPtr()
   If (buffer = 0) Then
      Print "Error: graphics screen not initialized."
      Sleep
      End -1
   End If

   '' Lock the screen to allow direct frame buffer access
   ScreenLock()
      
      '' Find the address of the pixel in the centre of the screen
      '' It's an 8-bit pixel, so use a UByte Ptr.
      Dim As Integer x = w \ 2, y = h \ 2
      Dim As UByte Ptr pixel = buffer + (y * pitch) + (x * bypp)
      
      
      '' Set the center pixel color to 10 (light green).
      *pixel = 10

   '' Unlock the screen.
   ScreenUnlock()

   '' Wait for the user to press a key before closing the program
   Sleep

   Const SCREEN_WIDTH = 256, SCREEN_HEIGHT = 256
   Dim As Integer w, h, bypp, pitch

   '' Make 32-bit screen.
   ScreenRes SCREEN_WIDTH, SCREEN_HEIGHT, 32

   '' Get screen info (w and h should match the constants above, bypp should be 4)
   ScreenInfo w, h, , bypp, pitch

   '' Get the address of the frame buffer. An Any Ptr 
   '' is used here to allow simple pointer arithmetic
   Dim buffer As Any Ptr = ScreenPtr()
   If (buffer = 0) Then
      Print "Error: graphics screen not initialized."
      Sleep
      End -1
   End If

   '' Lock the screen to allow direct frame buffer access
   ScreenLock()
      
      '' Set row address to the start of the buffer
      Dim As Any Ptr row = buffer
      
      '' Iterate over all the pixels in the screen:
      
      For y As Integer = 0 To h - 1
         
         '' Set pixel address to the start of the row
         '' It's a 32-bit pixel, so use a ULong Ptr
         Dim As ULong Ptr pixel = row
         
         For x As Integer = 0 To w - 1
            
            '' Set the pixel value
            *pixel = RGB(x, x Xor y, y) 
            
            '' Get the next pixel address 
            '' (ULong Ptr will increment by 4 bytes)
            pixel += 1
            
         Next x
         
         '' Go to the next row
         row += pitch
         
      Next y

   '' Unlock the screen.
   ScreenUnlock()

   '' Wait for the user to press a key before closing the program
   Sleep

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Screenptr.

Differences from QB
   * New to FreeBASIC

See also
   * Screen (Graphics)
   * ScreenRes
   * ScreenInfo
   * ScreenLock
   * ScreenUnlock



-------------------------------------------------------- KeyPgScreenres ----
ScreenRes

Initializes a graphics mode by specifying horizontal and vertical 
resolution

Syntax
   Declare Function ScreenRes ( ByVal width As Long, ByVal height As Long, 
   ByVal depth As Long = 8, ByVal num_pages As Long = 1, ByVal flags As Long
   = 0, ByVal refresh_rate As Long = 0 ) As Long
 
Usage
   ScreenRes width, height [, [depth] [, [num_pages] [, [flags] [, 
   refresh_rate ]]]]
   result = ScreenRes( width, height [, [depth] [, [num_pages] [, [flags] 
   [, refresh_rate ]]]] )

Parameters
   width, height
      The display width and height, respectively. For fullscreen mode, the 
      user should check the availability of the resolution using ScreenList
      .
   depth
      The color depth in bits per pixel. Valid color depths are: 1, 2, 4, 8
      , 16 and 32.  Values of 15 and 24 are also allowed as aliases for 16 
      and 32, respectively.  If omitted, the default is 8 bits per pixel.  
      8 bits and below will give a palette image.  The default palette will 
      be the first 2 ^ depth colors of the 256-color palette used in Screen 
      13.
   num_pages
      The number of video pages to create, defaults to 1. (see Screen)
   flags
      Used to set various properties of the screen, including fullscreen 
      mode and graphics driver priority. (see the standard header 
      "fbgfx.bi" for available flags)
   refresh_rate
      The desired refresh rate of the screen, only has an effect for 
      fullscreen modes, and some systems and drivers only. Defaults to an 
      appropriate value, invalid refresh rates will be ignored.

Return Value
   Returns zero (0) if successful, or a non-zero error code to indicate a 
   failure. (throws a runtime error) (???)

Description
   ScreenRes tells the compiler to link the GfxLib and initializes a 
   QB-only, QB-on-GUI or OpenGL graphics mode, depending on the flags 
   setting.

   ScreenRes  clears the created window or the full screen. In 
   non-fullscreen modes, the resolution does not have to match any 
   resolution of the graphics card. Resolutions like 555x111 are possible, 
   GfxLib will create a window of such size. See the page GfxLib overview 
   for DOS issues.

   The font size in ScreenRes modes is set to 8x8 by default.  This can be 
   changed by setting the number of text rows/columns, using the Width 
   function.

   In QB-only modes a dumb window or fullscreen resolution is set, one or 
   more buffers in standard memory are created,  console commands are 
   redirected to their graphic versions, a default palette is set and an 
   automatic screen refresh thread is started. QB-like graphics and console 
   statements can be used.  

    In QB-on-GUI modes one or more buffers in standard memory are created,  
   console commands are redirected to their graphic versions and a 
   default palette is set. QB-like  graphics and console statements can be 
   used.  It is up to the user to create a window and to refresh it with 
   the contents of the graphics buffers.

   In OpenGL modes a dumb window or fullscreen resolution is set, one or 
   more buffers in standard memory are created, and the system's OpenGL 
   library is initialized. From here only OpenGL commands can be used to 
   write to the graphics buffer. QB-like and console commands are 
   forbidden. This mode allows to initialize OpenGL in a portable way.

   The error code returned by ScreenRes can be checked using Err in the 
   next line. The function version of  ScreenRes returns directly the error 
   code as a 32 bit Long.

flags details:

   If flags are omitted, FreeBASIC uses QB-compatible graphics in windowed 
   (except in DOS) mode.  These constants are defined in fbgfx.bi.  In the 
   -lang fb dialect, these constants are part of the FB Namespace. Their 
   values can be combined to form a mask using Operator Or. Note that most 
   of the flags are not supported in DOS.

   Available flags:

   graphic mode flags
      GFX_NULL: Starts a QB-on-GUI graphics mode.  It creates a graphics 
      buffer but not a window.  User must implement the window, the events 
      manager and refresh the screen as needed.  This mode allows to mix 
      FreeBASIC drawing functions with API-driven windows.  Alternatively, 
      it allows to process graphics (for example files) without making it 
      visible on the screen, even in a purely console application.  This 
      flag overrides all other mode flags.  See an Example of GFX_NULL in 
      Windows.
      GFX_OPENGL: Initializes OpenGL to draw in a dumb window. FreeBASIC 
      graphic functions can't be used.  The screen is not automatically 
      updated, Flip must be used.  This option provides a portable way to 
      initialize the OpenGL Library.
      If none of the above options is specified, FreeBASIC enters the 
      QB-only graphics mode: it creates a buffer and a dumb window and sets 
      a thread that automatically updates the screen and manages keyboard 
      and mouse.  The FreeBASIC drawing functions can be used.

   window mode flags
      Window mode flags are meaningless if  GFX_NULL mode is used
      GFX_WINDOWED: If windowed mode is supported, FreeBASIC opens a window 
      of the requested size in the present desktop
      GFX_FULLSCREEN: The graphics card switch mode is switched to the 
      requested mode and color depth and OS fullscreen mode is used.  If 
      the mode is not available in the present card FreeBASIC switches to 
      windowed mode.
      If GFX_FULLSCREEN is not specified, the behavior for GFX_WINDOWED is 
      assumed.
      GFX_NO_SWITCH: Prevents the user from changing to fullscreen or to 
      windowed mode by pressing Alt-Enter.
      GFX_NO_FRAME: Creates a window without a border.
      GFX_SHAPED_WINDOW: Creates transparent regions wherever RGBA(255, 0, 
      255, 0) is drawn on the screen.
      GFX_ALWAYS_ON_TOP: Creates a window that stays always on top.

   option flags
      Flags working in any mode, they activate special behaviors
      GFX_ALPHA_PRIMITIVES: Tells the graphics library to enable alpha 
      channel support for all drawing primitives. This means the alpha 
      specified in a color value (via either the RGBA macro or direct color 
      in the form &hAARRGGBB) will always be used by all primitives.
      GFX_HIGH_PRIORITY: Tells the graphics library to enable a higher 
      priority for graphics processing.  Only has an effect on gdi and 
      DirectX drivers on Win32 platform and Direct2D added on new 
      platforms.

   OpenGL Buffer flags
      These flags work only in OpenGL graphics mode, must be combined with 
      GFX_OPENGL
      GFX_STENCIL_BUFFER: Forces OpenGL to use Stencil buffer 
      GFX_ACCUMULATION_BUFFER: Forces OpenGL to use Accumulation buffer
      GFX_MULTISAMPLE: Requests fullscreen anti-aliasing through the 
      ARB_multisample extension

   Depending on whether the GFX_FULLSCREEN parameter is present or not, 
   Screen will try to set the specified video mode in fullscreen or 
   windowed mode, respectively.  If fullscreen mode is set and the system 
   cannot set specified mode in fullscreen, it will try in windowed mode. 
   If windowed mode is set and the system fails to open a window for 
   specified mode, it will try fullscreen.  If everything fails, Screen 
   will have no effect and execution will resume from the statement 
   following the Screen call.  You should take care of checking if a 
   graphics mode has been set or not, and behave accordingly; a way to 
   check if Screen is successful is to test the return value of the 
   ScreenPtr function; see its page for details.

Graphics mode console
   Console commands (Locate, Print), input can be used both with standard 
   QB Screen modes and with the extended ones too, provided the standard 
   color depth is not modified by using the second argument of Screen. 
   Where the table says more than one text resolution is available for the 
   text mode, the required text resolution can be requested by using Width. 
   Any characters Printed will erase the background around them; it does 
   not use a transparent background.

Example
   ' Set the screen mode to 320*200, with 8 bits per pixel
   ScreenRes 320, 200, 8

   ' Draw color bands in a diagonal pattern over the whole screen
   For y As Integer = 0 To 200-1
      For x As Integer = 0 To 320-1
         PSet (x,y),(x + y) And 255
      Next x
   Next y

   ' Display the text "Hello World!!" over the lines we've drawn, in the top-left hand corner
   Print "Hello world!!"

   ' Keep the window open until the user presses a key
   Sleep

Platform Differences
   * In DOS, Windowing and OpenGL related switches are not available, and 
     other issues, see GfxLib overview

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Screenres.

Differences from QB
   * New to FreeBASIC

See also
   * Screen The QB-like way to set graphics mode
   * ScreenList Check display modes available for FB GfxLib to use
   * ScreenControl Select driver and more 
   * ScreenLock
   * ScreenUnlock
   * ScreenPtr Semi-low level access
   * ScreenSet
   * ScreenCopy
   * ScreenInfo
   * ScreenGLProc
   * Internal pixel formats
   * FaqPggfxlib2



-------------------------------------------------------- KeyPgScreenset ----
ScreenSet

Sets current work and visible pages

Syntax
   Declare Sub ScreenSet ( ByVal work_page As Long = -1, ByVal visible_page 
   As Long = -1 )

Usage
   ScreenSet [ work_page ] [, visible_page ]

Parameters
   work_page
      index to working page
   visible_page
      index to visible page

Description
   ScreenSet allows to set the current working page and the current visible 
   page. Page numbers range from 0 to num_pages - 1, where num_pages is the 
   number of pages specified when setting the graphics mode with ScreenRes 
   or Screen.  You can use this function to achieve page-flipping or 
   double-buffering.

   If you provide visible_page but omit work_page, only the visible page is 
   changed. If you provide work_page but omit visible_page, only the work 
   page is changed. If you omit both arguments, both work page and visible 
   page are reset to page 0.

   ScreenSet provides one method of writing to the screen without instantly 
   displaying changes to the user.  See also ScreenLock / ScreenUnlock for 
   an alternative method of doing this.

   Note: The current cursor position is not handled independently for each 
   video page. Therefore, when another working page is selected, the 
   starting cursor position corresponds to the last cursor position on the 
   previous working page (same behavior for the text cursor and the 
   graphics cursor).

Example
   ' Open graphics screen (320*200, 8bpp) with 2 pages
   ScreenRes 320, 200, 8, 2

   ' Work on page 1 while displaying page 0
   ScreenSet 1, 0

   Dim As Integer x = -40

   Do
      '' Clear the screen, draw a box, update x
      Cls
      Line (x, 80)-Step(39, 39), 4, BF
      x += 1: If (x > 319) Then x = -40
      
      ' Wait for vertical sync: only used to control refresh rate, can be put anywhere in the Do loop
      ScreenSync
      
      ' Copy work page to visible page
      ScreenCopy
      
   Loop While Inkey = ""

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Screenset.

Differences from QB
   * New to FreeBASIC

See also
   * Screen (Graphics)
   * ScreenRes
   * ScreenCopy
   * ScreenLock
   * ScreenUnlock



------------------------------------------------------- KeyPgScreensync ----
ScreenSync

Synchronizes display updates with hardware

Syntax
   Declare Function ScreenSync ( ) As Long

Usage
   result = ScreenSync

Return Value
   Zero if successful, or non-zero if a graphics mode was not previously 
   set.

Description
   This GfxLib statement stops the execution of the program until the 
   graphics card signals it has ended tracing a frame and is going to start 
   the new one.

   If the program uses this small interval of time between frames to redraw 
   the image, the flickering is greatly reduced. In that use, ScreenSync is 
   a reminiscence of QB where there was only that equivalent method (Wait 
   &H3DA, 8) to improve the flickering. It is an empirical method because 
   it only allows to synchronize the beginning of the drawing with the 
   fixed dead time between two frames. To be used occasionally to avoid 
   flickering when only very short time of drawing.

   Except the purpose to reduce the flickering, ScreenSync can be also used 
   simply as a method of synchronization of graphic drawing with the screen 
   frame tracing (similarly to statement Sleep).

   The error code returned by ScreenSync can be checked using Err in the 
   next line. The function version of  ScreenSync returns directly the 
   error code as a 32 bit Long.

   The use of the QB-compatible form Wait &H3DA, 8 is deprecated.

Example
   'main loop
   Do
     
     ' do user input
     ' calculate_a_frame
      
     ScreenSync
     
     ' draw_ a_ frame  
     
   Loop Until Inkey <> ""

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Screensync.

Differences from QB
   * New to FreeBASIC. 
   * QBasic used Wait &H3DA, 8 for this purpose.

See also
   * Wait



----------------------------------------------------- KeyPgScreenunlock ----
ScreenUnlock

Unlocks work page's framebuffer

Syntax
   Declare Sub ScreenUnlock ( ByVal startline As Long = -1, ByVal endline As
   Long = -1 )

Usage
   ScreenUnlock [ start_line ] [, end_line ]

Parameters
   startline
      optional argument specifying first screen line to be updated. If 
      omitted, top screen line is assumed.
   endline
      optional argument specifying last screen line to be updated. If 
      omitted, bottom screen line is assumed.

Description
   ScreenUnlock unlocks the current work page assuming it was previously 
   locked by calling ScreenLock and lets the system restart updating the 
   screen regularly. When called with start_line and end_line , only the 
   screen area between those lines is assumed to have changed, and will be 
   updated. 

   An internal counter exists that remembers the screen lock state, thus 
   ScreenUnlock has an effect only on a screen that is locked.  A screen 
   that has not been locked with ScreenLock cannot get unlocked, however 
   ScreenUnlock still will force an update of given area or full screen.   

   Calls to ScreenUnlock must be paired with matching calls to ScreenLock.  
   Only the first call to ScreenLock actually performs a locking operation. 
   Subsequent calls to ScreenLock only increment the lock counter.  
   Conversely, ScreenUnlock only decrements the lock counter until it 
   reaches zero at which time the actual unlock operation will be 
   performed.  Using Screen or ScreenRes will release all locks and set the 
   lock counter back to zero before changing screen modes.

   All graphic statements automatically lock the screen before the function 
   call, and unlock the screen afterwards, so you do not need to do this 
   explicitly using ScreenLock and ScreenUnlock. You only need to lock the 
   screen when you wish to access the screen (framebuffer) directly using 
   ScreenPtr  or when you wish to group several graphic statements together 
   so their effects appear simultaneously on screen, thus avoiding 
   potential screen flicker during screen updates.

   Warning (Win32, Linux) : The screen is locked by stopping the thread 
   that processes also the OS' events. This means the screen should be 
   locked only for the short time required to redraw it, and no user input 
   will be received while the screen is locked. When the induced lock time 
   becomes too long, use preferably the method of double buffering (with 
   ScreenCopy).

Example
   See ScreenPtr example.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Screenunlock.

Differences from QB
   * New to FreeBASIC

See also
   * Screen (Graphics)
   * ScreenLock
   * ScreenPtr



----------------------------------------------------------- KeyPgSecond ----
Second

Gets the seconds from a Date Serial 

Syntax
   Declare Function Second ( ByVal date_serial As Double ) As Long

Usage
   #include "vbcompat.bi"
   result = Second( date_serial )

Parameters
   date_serial
      the date serial

Return Value
   Returns the seconds from a  variable containing a date in  Date Serial  
   format.

Description
    
   The compiler will not recognize this function unless vbcompat.bi is 
   included.

Example
   #include "vbcompat.bi"

   Dim ds As Double = DateSerial(2005, 11, 28) + TimeSerial(7, 30, 50)

   Print Format(ds, "yyyy/mm/dd hh:mm:ss "); Second(ds)

Differences from QB
   * Did not exist in QB. This function appeared in PDS and VBDOS

See also
   * Date Serials



---------------------------------------------------------- KeyPgSeekset ----
Seek (Statement)

Sets the position of the next read/write operation on a file

Syntax
   Seek [#]filenum, position

Parameters
   filenum
      file number of an opened a file
   position
      the new position for i/o operations

Description
   Sets the position at which the next read or write operation on a file 
   will occur.

   The position is given in records if the file was opened in Random access 
   mode, in bytes in any other case. The position is 1 based -- the first 
   record of a file is at position 1.

   The Seek function is used to get the position of the next read or write 
   operation.

Example
   ' e.g. if you want to skip to the 100th byte in the file for reading/writing:

   Dim f As Integer

   f = FreeFile
   Open "file.ext" For Binary As #f

   Seek f, 100

   Close #f

Differences from QB
   * None

See also
   * Seek (Function)
   * Open



------------------------------------------------------- KeyPgSeekreturn ----
Seek (Function)

Gets the position of the next read/write operation for a file or device

Syntax
   Declare Function Seek ( ByVal filenum As Long ) As LongInt

Parameters
   filenum
      file number of an open file

Return Value
   The file position where the next read or write operation will take 
   place.

Description
   The position is given in records if the file was opened in Random access 
   mode, in bytes in any other case. The file position returned is 1-based, 
   so the first record of a file is 1.

   The Seek statement is used to set the position of the next read or write 
   operation.

Example
   Dim f As Integer, position As Integer

   f = FreeFile
   Open "file.ext" For Binary As #f

   position = Seek(f)

   Close #f

Differences from QB
   * None

See also
   * Seek (Statement)
   * LOC
   * Open



------------------------------------------------------- KeyPgSelectcase ----
Select Case

Conditional statement block

Syntax
   Select Case expression
   [ Case expressionlist] 
      [statements]
   [ Case Else ]
      [statements]
   End Select
or
   Select Case As Const integer_expression
   [ Case constant | enumeration ]
      [ statements ]
   [ Case Else ]
      [ statements ]
   End Select

Description
   Select Case executes specific code depending on the value of an 
   expression. The expression is evaluated once, and compared against each 
   Case, in order, until a matching expression is found. The code inside 
   the matching Case branch is executed, and the program skips down to the 
   end of the Select Case block. Case Else matches any case not already 
   matched, so if there is a Case Else, at least one Case is guaranteed to 
   be executed. If no Cases match, the whole Select Case block will be 
   skipped.

   End Select is used to close the Select Case...End Select block.

   Exit Select can be used to escape the Select Case block, preventing 
   further code in the Case block from being executed.

   Note for C users: In FreeBASIC, Select Case works like a switch block 
   where all cases have a break at the end. As there is no fall-through, 
   multiple options must be put in an expression list in a single Case.

   Besides integer types, floating point and string expressions are also 
   supported with the first syntax.  

   Syntax of an expression list:
   { expression | expression To expression | Is relational operator 
   expression }[, ...]

   * expr: evaluates expr, and compares for equality with the original 
     expression.  If they are equal, then a match has been found.  This 
     could be considered as a shorthand for "Is = expr" (see below).
   * expr1 To expr2: evaluates expr1 and checks to see if it is less than 
     or equal to the original expression.  If so, it evaluates expr2, and 
     checks to see if it is greater than or equal to the original 
     expression.  If so, then a match has been found.
   * Is relational_operator expr: evaluates expr, and compares the 
     original operation against it, using the supplied relational_operator 
     (=, >, <, <>, <=, >=).  If the comparison is true, then a match has 
     been found.

   Multiple checks can be made in each Case, by separating them by a comma 
   (,).  Once a match is found, the program finishes its checks, and goes 
   on to execute the code statements for that Case block.  No further 
   expressions are evaluated or checked.

   example of expression lists:
      +--------------------+-----------------------------+
      |Case 1              |constant                     |
      |Case 5.4 To 10.1    |range                        |
      |Case Is > 3         |bigger than-smaller than     |
      |Case 1, 3, 5, 7 to 9|match against a set of values|
      |Case x              |value of a variable          |
      +--------------------+-----------------------------+

   If As Const is used, only integer constants (all numeric constants 
   excluding the two floating-point constants: single and double) can be 
   evaluated and the expression list supports simple constants and 
   enumerations only. "To" ranges are supported, but "Is" relational 
   operators are not.

   With As Const, a jump table is created to contain the full range of 
   integer Cases handled.  This allows Select Case As Const to be faster 
   than Select Case.
   However, the size of the range of values is limited, and after 
   converting the values to the uinteger type, the largest value in the 
   range may be no higher than the smallest value + 8191 (current 
   implementation).

   Note: No statement can be placed between the Select Case statement and 
   the first Case statement.

Example

   Dim choice As Integer

   Input "Choose a number between 1 and 10: "; choice

   Select Case As Const choice
   Case 1
      Print "number is 1"
   Case 2
      Print "number is 2"
   Case 3, 4
      Print "number is 3 or 4"
   Case 5 To 10
      Print "number is in the range of 5 to 10"
   Case Else
      Print "number is outside the 1-10 range"
   End Select

   '' SELECT CASE vs. SELECT CASE AS CONST speed test

   Const N = 50000000

   Dim As Integer dummy = 0
   Dim As Double t = Timer()

   For i As Integer = 1 To N
      Select Case i
      Case 1, 3, 5, 7, 9
         dummy += 1
      Case 2, 4, 6, 8, 10
         dummy += 1
      Case 11 To 20
         dummy += 1
      Case 21 To 30
         dummy += 1
      Case 31
         dummy += 1
      Case 32
         dummy += 1
      Case 33
         dummy += 1
      Case Is >= 34
         dummy += 1
      Case Else
         Print "can't happen"
      End Select
   Next

   Print Using "SELECT CASE: ##.### seconds"; Timer() - t
   t = Timer()

   For i As Integer = 1 To N
      Select Case As Const i
      Case 1, 3, 5, 7, 9
         dummy += 1
      Case 2, 4, 6, 8, 10
         dummy += 1
      Case 11 To 20
         dummy += 1
      Case 21 To 30
         dummy += 1
      Case 31
         dummy += 1
      Case 32
         dummy += 1
      Case 33
         dummy += 1
      Case Else
         If( i >= 34 ) Then
            dummy += 1
         Else
            Print "can't happen"
         End If
      End Select
   Next

   Print Using "SELECT CASE AS CONST: ##.### seconds"; Timer() - t
   Sleep

Differences from QB
   * Select Case As Const did not exist in QB.
   * in an "expr1 TO expr2" case, QB would always evaluate both 
     expressions, even if expr1 was higher than the original expression.
   * In the -lang qb and -lang fblite dialects, variables declared inside 
     a Select..End Select block have a function-wide scope as in QB.
   * In the -lang fb and -lang deprecated dialects, variables declared 
     inside a Select..End Select block are visible only inside the block, 
     and can't be accessed outside it. To access duplicated symbols defined 
     as global outside this block, add one or preferably two dot(s) as 
     prefix: .SomeSymbol or preferably ..SomeSymbol (or only ..SomeSymbol 
     if inside a With..End With block).

See also
   * If...Then



---------------------------------------------------------- KeyPgSetdate ----
SetDate

Sets the current system date

Syntax
   Declare Function SetDate ( ByRef newdate As Const String ) As Long

Usage
   result = SetDate( newdate )

Parameters
   newdate
      the new date to set

Return Value
   Returns zero on success or non-zero on failure on all ports except DOS.

Description
   To set the date you just format newdate and send to SetDate in a valid 
   format following one of the following: "mm-dd-yy", "mm-dd-yyyy", 
   "mm/dd/yy", or "mm/dd/yyyy" (mm is the month, dd is the day, yy or yyyy 
   is the year). Two-digit year numbers are based on the year 1900.

   The error code returned by SetDate can be checked using Err in the next 
   line. The function version of  SetDate returns directly the error code 
   as a 32 bit Long.

Example
   Dim m As String, d As String, y As String
   m = "03" 'march
   d = "13" 'the 13th
   y = "1994" 'good ol' days
   SetDate m + "/" + d + "/" + y

Platform Differences
   * On Windows the privilege SE_SYSTEMTIME_NAME is required, which 
     typically means that the calling process has to be run with 
     administrator privileges.
   * On Linux the capability CAP_SYS_TIME is required, which typically 
     means that the calling process has to run as root/superuser.

Differences from QB
   * The DATE statement was used in QB and the syntax was "DATE = string"

See also
   * Date
   * SetTime



------------------------------------------------------- KeyPgSetenviron ----
SetEnviron

Sets a system environment variable

Syntax
   Declare Function SetEnviron ( ByRef varexpression As String ) As Long

Usage
   result = SetEnviron( varexpression )

Parameters
   varexpression
      Name and setting of an environment variable in the following (or 
      equivalent) form: varname=varstring.
      (varname being the name of the environment variable, and varstring 
      being its text value to set)

Return Value
   Return zero (0) if successful, non-zero otherwise.

Description
   Modifies system environment variables.  There are several variables 
   available for editing other than the default ones on your system.  An 
   example of this would be fbgfx, where you can choose the form of 
   graphics driver the FreeBASIC graphics library will use.

Example
   'e.g. to set the system variable "path" to "c:":

   Shell "set path" 'shows the value of path
   SetEnviron "path=c:"
   Shell "set path" 'shows the new value of path

     '' WINDOWS ONLY EXAMPLE! - We just set the graphics method to use
     '' GDI rather than DirectX (or Direct2D added on new systems).
     '' You may note a difference in FPS.
   SetEnviron("fbgfx=GDI")

     '' Desktop width/height
   Dim As Integer ScrW, ScrH, BPP
   ScreenInfo ScrW, ScrH, BPP

     '' Create a screen at the half width/height of your monitor.
     '' Normally this would be slow, but GDI is fairly fast for this kind
     '' of thing.
   ScreenRes ScrW/2, ScrH/2, BPP

     '' Start our timer/
   Dim As Double T = Timer

     '' Lock our page
   ScreenLock
   Do
     
      '' Print time since last frame
     Locate 1, 1
     Print "FPS: " & 1 / ( Timer - T )
     T = Timer
     
      '' Flip our screen
     ScreenUnlock
     ScreenLock
      '' Commit a graphical change to our screen.
     Cls
     
   Loop Until Len(Inkey)

     '' unlock our page.
   ScreenUnlock

Platform Differences
   * In Linux, varexpression  must be permanent (a literal, a variable 
     declared in the main code or a static variable declared in a 
     procedure), because Linux does not memorize the string but only a 
     pointer to its data characters.

Differences from QB
   * In QB, SetEnviron was called Environ.

See also
   * Environ
   * Shell



--------------------------------------------------------- KeyPgSetmouse ----
SetMouse

Sets the position and visibility of the mouse cursor

Syntax
   Declare Function SetMouse ( ByVal x As Long = -1, ByVal y As Long = -1, 
   ByVal visibility As Long = -1, ByVal clip As Long = -1 ) As Long

Usage
   result = SetMouse([ x ] [, [ y ] [, [ visibility ] [, [ clip ]]]])

Parameters
   (For each parameter, -1 is a special value indicating "no changes.")
   x
      optional - set x coordinate
   y
      optional - set y coordinate
   visibility
      optional - set visibility: 1 indicates visible, 0 indicates hidden
   clip
      optional - set clipping: 1 indicates mouse is clipped to graphics 
      window, 0 indicates no clipping

Return Value
   Zero (0) on success, non-zero to indicate failure.

Description
   SetMouse will set the (x, y) coordinates of the mouse pointer, as well 
   as setting its visibility.  The mouse position is set using the x and y 
   parameters.  The mouse will be visible if visibility is set to 1, and 
   invisible if visibility is set to 0.  SetMouse is intended for graphics 
   modes initiated using the Screen (Graphics) statement only.

   The error code returned by SetMouse can be checked using Err in the next 
   line. The function version of  SetMouse returns directly the error code 
   as a 32 bit Long.

Example
   Dim As Integer x, y, buttons

   ' create a screen 640*480
   ScreenRes 640, 480
   Print "Click the mouse button to center the mouse"

   Do
      ' get mouse x, y and button state (wait until mouse is onscreen)
      Do: Sleep 1: Loop While GetMouse( x, y , , buttons) <> 0

      If buttons And 1 Then
         ' on left mouse click, center mouse
         SetMouse 320, 240
      End If

      ' run loop until a key is pressed or the window is closed
   Loop While Inkey = ""

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Setmouse.

Differences from QB
   * New to FreeBASIC

See also
   * GetMouse
   * Screen
   * MultiKey
   * GetKey



---------------------------------------------------------- KeyPgSettime ----
SetTime

Sets the current system time

Syntax
   Declare Function SetTime ( ByRef newtime As Const String ) As Long

Usage
   result = SetTime( newtime )

Parameters
   newtime
      the new time to set

Return Value
   Returns zero on success or non-zero on failure on all ports except DOS.

Description
   To set the time, format the date and send to Settime in one of the 
   following formats: "hh:mm:ss", "hh:mm", or "hh" (hh is the hour, mm is 
   the minute, and ss is the second).

   The error code returned by SetTime can be checked using Err in the next 
   line. The function version of  SetTime returns directly the error code 
   as a 32 bit Long.

Example
   SetTime "1:20:30"

Platform Differences
   * On Windows the privilege SE_SYSTEMTIME_NAME is required, which 
     typically means that the calling process has to be run with 
     administrator privileges.
   * On Linux the capability CAP_SYS_TIME is required, which typically 
     means that the calling process has to be run as root/superuser.

Differences from QB
   * The Time statement was used QB and the syntax was TIME = newtime.

See also
   * Time
   * SetDate



-------------------------------------------------------------- KeyPgSgn ----
Sgn

Returns the sign part of a number

Syntax
   Declare Function Sgn ( ByVal number As Integer ) As Integer
   Declare Function Sgn ( ByVal number As LongInt ) As LongInt
   Declare Function Sgn ( ByVal number As Double ) As Double

Usage
   result = Sgn( number )

Parameters
   number
      the number to find the sign of

Return Value
   Returns the sign part of number.
   * If number is greater than zero, then Sgn returns 1.
   * If number is equal to zero, then Sgn returns 0.
   * If number is less than zero, then Sgn returns -1.

Description
   The required number argument can be any valid numeric expression.  
   Unsigned numbers will be treated as if they were signed, i.e. if the 
   highest bit is set the number will be treated as negative, and -1 will 
   be returned.

   The Sgn unary Operator can be overloaded with user defined types.

Example
   Dim N As Integer = 0

   Print Sgn ( -1.87 )
   Print Sgn ( 0 )
   Print Sgn ( 42.658 )
   Print Sgn ( N )

The output would look like:

   -1
   0
   1
   0

Dialect Differences
   * In the -lang qb dialect, this operator cannot be overloaded.

Differences from QB
   * None

See also
   * Abs
   * Operator



----------------------------------------------------------- KeyPgShared ----
Shared

Variable declaration modifier specifying visibility throughout a module

Syntax
   Dim Shared ...
   ReDim Shared ...
   Common Shared ...
   Static Shared ...
   [Static] Var Shared ...

Description
   Shared makes module-level variables visible inside Subs and Functions.
   If Shared is not used on a module-level variable's declaration, the 
   variable is only visible to the module-level code in that file 
   (furthermore, only a variable declared with Dim without Shared modifier, 
   and not inside a Namespace block, is stored on the stack).

   NOTES (for Shared variables excluding Common variables):
      * Generally a Shared variable may only be initialized with a 
        constant value (its starting value is set at the start of the 
        program in the .data section before any code is run, and so it 
        cannot depend on any variables or functions in it).
      * A first exception is a Shared variable of var-len string type, 
        that never can be initialized, even with a constant string (because 
        of its structure with a descriptor in the .data section, but to 
        point to a dynamic memory block).
      * A second exception is a Shared variable of user-defined type 
        having a constructor even implicit, that can be initialized with a 
        non-constant value (because it's the constructor code, called when 
        the program starts, which writes the "initial" values into the 
        .data section).

   To access from a local scope block to duplicated symbols of Shared 
   variables defined in the global namespace, add one or preferably two 
   dot(s) as prefix: .SomeSymbol or preferably ..SomeSymbol (or only ..
   SomeSymbol if inside a With..End With block).

Example
   '' Compile with -lang qb or fblite

   '$lang: "qb"

   Declare Sub MySub
   Dim Shared x As Integer
   Dim y As Integer

   x = 10
   y = 5

   MySub

   Sub MySub
      Print "x is "; x 'this will report 10 as it is shared
      Print "y is "; y 'this will not report 5 because it is not shared
   End Sub

Differences from QB
   * The Shared statement inside scope blocks -- functions, subs, 
     if/thens, and loops -- is not supported. Use Dim|Redim|Common|Static 
     Shared in the main program instead.  Or if you're inside a scope block 
     and Redimming a variable or array previously set up with Shared, just 
     do a Redim without Shared; it will work fine and won't ruin anything.

See also
   * Common
   * Dim
   * Erase
   * Extern
   * LBound
   * ReDim
   * Preserve
   * Static
   * UBound
   * Var
   * Byref (Variables)



------------------------------------------------------------ KeyPgShell ----
Shell

Sends a command to the system command interpreter

Syntax
   Declare Function Shell ( ByRef command As Const String ) As Long

Usage
   result = Shell( command )

Parameters
   command
      A string specifying the command to send to the command interpreter.

Return Value
   If the command could not be executed, -1 is returned. Otherwise, the 
   command is executed and its exit code is returned.

Description
   Program execution will be suspended until the command interpreter exits.

Example
   'e.g. for windows:
   Shell "dir c:*.*"

   'e.g. for linux:
   Shell "ls"

Platform Differences
   * Linux requires the command case matches the real name of the command. 
     Windows and DOS are case insensitive. The program being shelled may be 
     case sensitive for its command line parameters. 
   * Path separators in Linux are forward slashes / . Windows uses 
     backward slashes \ but it allows for forward slashes.  DOS uses 
     backward  \ slashes.
   * If an empty command string is passed, DOS will open an interactive 
     command prompt.  On Windows, an error may be returned.

Differences from QB
   * QB allowed SHELL on its own without a "command" argument which caused 
     a default command shell to be started.  Execution in the main program 
     would suspend until exit from the command shell.  The behaviour in FB 
     is platform-dependent.

See also
   * Exec
   * Run



------------------------------------------------------ KeyPgOpShiftLeft ----
Operator Shl (Shift Left)

Shifts the bits of a numeric expression to the left

Syntax
   Declare Operator Shl ( ByRef lhs As Integer, ByRef rhs As Integer ) As 
   Integer
   Declare Operator Shl ( ByRef lhs As UInteger, ByRef rhs As UInteger ) As 
   UInteger
   Declare Operator Shl ( ByRef lhs As LongInt, ByRef rhs As LongInt ) As 
   LongInt
   Declare Operator Shl ( ByRef lhs As ULongInt, ByRef rhs As ULongInt ) As 
   ULongInt

Usage
   result = lhs Shl rhs

Parameters
   lhs
      The left-hand side expression.
   rhs
      The right-hand side shift expression.

Return Value
   Returns the result of lhs being shifted left rhs number of times.

Description
   Operator Shl (Shift left) shifts all of the bits in the left-hand side 
   expression (lhs) left a number of times specified by the right-hand side 
   expression (rhs). Numerically, the result is the same as "CInt( lhs * 2 ^
   rhs )". For example, "&b0101 Shl 1" returns the binary number &b01010, 
   and "5 Shl 1" returns 10.

   Neither of the operands are modified in any way.

   If the result is too large to fit inside the result's data type, the 
   leftmost bits are discarded ("shifted out").
   The results of this operation are undefined for values of rhs less than 
   zero, or greater than or equal to the number of bits in the result's 
   data type.

   This operator can be overloaded for user-defined types.

Example
   'Double a number
   For i As Integer = 0 To 10
      
      Print 5 Shl i, Bin(5 Shl i, 16)
      
   Next i

Output:

    5            0000000000000101
    10           0000000000001010
    20           0000000000010100
    40           0000000000101000
    80           0000000001010000
    160          0000000010100000
    320          0000000101000000
    640          0000001010000000
    1280         0000010100000000
    2560         0000101000000000
    5120         0001010000000000

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Shl.

Differences from QB
   * New to FreeBASIC

See also
   * Operator Shl= (Shift Left And Assign)
   * Operator Shr (Shift Right)
   * Bin
   * Mathematical Functions



------------------------------------------------------------ KeyPgShort ----
Short

Standard data type: 16 bit signed

Syntax
   Dim variable As Short

Description
   16-bit signed whole-number data type. Can hold values from -32768 to 
   32767.

Example
     Dim x As Short = CShort(&H8000)
     Dim y As Short = CShort(&H7FFF)
     Print "Short Range = "; x; " to "; y

   Output:
   Short Range = -32768 To  32767

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Short.

Differences from QB
   * The name "short" is new to FreeBASIC, however they are the same as 
     integers in QB

See also
   * UShort
   * CShort
   * Table with variable types overview, limits and suffixes



----------------------------------------------------- KeyPgOpShiftRight ----
Operator Shr (Shift Right)

Shifts the bits of a numeric expression to the right

Syntax
   Declare Operator Shr ( ByRef lhs As Integer, ByRef rhs As Integer ) As 
   Integer
   Declare Operator Shr ( ByRef lhs As UInteger, ByRef rhs As UInteger ) As 
   UInteger
   Declare Operator Shr ( ByRef lhs As LongInt, ByRef rhs As LongInt ) As 
   LongInt
   Declare Operator Shr ( ByRef lhs As ULongInt, ByRef rhs As ULongInt ) As 
   ULongInt

Usage
   result = lhs Shr rhs

Parameters
   lhs
      The left-hand side expression.
   rhs
      The right-hand side shift expression.

Return Value
   Returns the result of lhs being shifted right rhs number of times.

Description
   Operator Shr (Shift right) shifts all of the bits in the left-hand side 
   expression (lhs) right a number of times specified by the right-hand 
   side expression (rhs). Numerically, the result is the same as "Int(lhs / 
   2 ^ rhs)". For example, "&b0101 Shr 1" returns the binary number &b010, 
   and "5 Shr 1" returns 2.

   If the left-hand side expression is signed and negative, the sign bit is 
   copied in the newly created bits on the left after the shift.  For 
   example, "-5 Shr 2" returns -2.

   Neither of the operands are modified in any way.

   The results of this operation are undefined for values of rhs less than 
   zero, or greater than or equal to the number of bits in the result's 
   data type.

   This operator can be overloaded for user-defined types.

Example
   'Halve a number
   For i As Integer = 0 To 10
      
      Print 1000 Shr i, Bin(1000 Shr i, 16)
      
   Next i

Output:

    1000         0000001111101000
    500          0000000111110100
    250          0000000011111010
    125          0000000001111101
    62           0000000000111110
    31           0000000000011111
    15           0000000000001111
    7            0000000000000111
    3            0000000000000011
    1            0000000000000001
    0            0000000000000000

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Shr.

Differences from QB
   * New to FreeBASIC

See also
   * Operator Shr= (Shift Right And Assign)
   * Operator Shl (Shift Left)
   * Bin
   * Mathematical Functions



-------------------------------------------------------------- KeyPgSin ----
Sin

Returns the sine of an angle

Syntax
   Declare Function Sin ( ByVal angle As Double ) As Double

Usage
   result = Sin( angle )

Parameters
   angle
      the angle (in radians)

Return Value
   Returns the sine of the argument angle as a Double within the range of 
   -1.0 to 1.0.

Description
   The argument angle is measured in radians (not degrees).

   The value returned by this function is undefined for values of angle 
   with an absolute value of 2 ^ 63 or greater.

   Sin can be overloaded as operator to accept user-defined types.

Example
   Const PI As Double = 3.1415926535897932
   Dim a As Double
   Dim r As Double
   Input "Please enter an angle in degrees: ", a
   r = a * PI / 180   'Convert the degrees to Radians
   Print ""
   Print "The sine of a" ; a; " degree angle is"; Sin ( r ) 
   Sleep

The output would look like:

   Please enter an angle in degrees: 30
   The sine of a 30 degree angle Is 0.5

Differences from QB
   * None

See also
   * Asin
   * Cos
   * Tan
   * A Brief Introduction To Trigonometry



----------------------------------------------------------- KeyPgSingle ----
Single

Standard data type: 32 bit floating point

Syntax
   Dim variable As Single

Description
   Single is a 32-bit, floating point data type used to store decimal 
   numbers. They can hold positive values in the range 1.401298e-45 to 
   3.402823e+38, or negative values in the range -1.401298e-45 to 
   -3.402823e+38, or zero (0).  They contain at most 24 bits of precision, 
   or about 6 decimal digits.

   They are similar to Double data types, but less precise. 

Example
   'Example of using a single variable.

   Dim a As Single
   a = 1.9857665
   Print a

   Sleep

Differences from QB
   * None

See also
   * Double More precise float type
   * CSng
   * Table with variable types overview, limits and suffixes



----------------------------------------------------------- KeyPgSizeof ----
SizeOf

Returns the size of a variable or type in bytes.

Syntax
   SizeOf ( variable | DataType )

Description
   The SizeOf operator returns an Integer value: the number of bytes taken 
   up by a variable or DataType (including the data fields of a UDT).

   Different from Len, when used with fixed-length strings (including 
   fixed-length ZStrings and WStrings) it will return the number of bytes 
   they use, and when used with variable-length strings, it will return the 
   size of the string descriptor.

   If there is both a user defined type and a variable visible with the 
   same name in the current scope, the user defined type takes precedence 
   over the variable.  To ensure that the SizeOf takes the variable instead 
   of the user defined type, wrap the argument to SizeOf with parentheses 
   to force it to be seen as an expression.  For example Sizeof((variable))
   .

   Note: When used with arrays, SizeOf returns the size of a single element 
   of the array.  This differs from its behavior in C, where arrays could 
   only be a fixed size, and sizeof() would return the number of it used.
   For clarity, it is recommended that you avoid this potential confusion, 
   and use SizeOf directly on an array element or the array datatype doing 
   SizeOf(array(i)) or SizeOf(Typeof(array)), rather than the whole array 
   doing SizeOf(array).

   Remark: When used with a dereferenced z/wstring pointer, SizeOf always 
   returns the number of bytes taken up by one z/wstring character.

Example
   Print SizeOf(Byte) ' returns 1
      

   Type bar
      a As Integer
      b As Double
   End Type
   Dim foo As bar
   Print SizeOf(foo)
      

Version
   * Before fbc 1.08.0:
         SizeOf was not returning the size of the data fields of a UDT.
         When a variable from a given namespace was accessed with the 
         namespace's name prefix, the argument to SizeOf had to be wrapped 
         with parentheses to force it to be seen as an expression. For 
         example Sizeof((namespace_name.variable)).

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Sizeof.

Differences from QB
   * New to FreeBASIC

See also
   * Len



------------------------------------------------------------ KeyPgSleep ----
Sleep

Waits until a specified time has elapsed, or a key is pressed.

Syntax
   Declare Sub Sleep ( ByVal amount As Long = -1 )
   Declare Function Sleep ( ByVal amount As Long , ByVal keyflag As Long ) 
   As Long

Usage
   Sleep [ amount [, keyflag ]]
   result = Sleep ( amount, keyflag )

Parameters
   amount
      Optional number of milliseconds to wait (default is to wait for a key 
      press).
   keyflag
      Optional flag; give it a value of 0 for a normal sleep, or 1 to 
      specify that the wait cannot be interrupted by a key press.

Return Value
   Returns 1 if keyflag was not a valid value (i.e. something other than 0 
   or 1) to indicate failure, or 0 otherwise.

Description
   Sleep will wait until amount milliseconds (can be seconds in -lang qb, 
   see below) given elapsed (if any value was passed) or until the user 
   presses a key. If amount is below 100 ms then Sleep will always wait the 
   full requested amount (key presses are ignored).

   Include the second parameter, 1, for a "deep" sleep, which cannot be 
   interrupted by pressing a key.

   The accuracy of Sleep is variable depending on the OS cycle time 
   (Windows NT/2K/XP: 15 ms, 9x/Me: 50 ms, Linux 10ms, DOS 55 ms).

   Call Sleep with 25ms or less to release time-slice when waiting for user 
   input or looping inside a thread.  This will prevent the program from 
   unnecessarily hogging the CPU.

   Sleep does not clear the keyboard input buffer and any keys pressed 
   during a call to Sleep are retained and can be later read by Inkey or 
   GetKey or Input.
   When Sleep has no parameters (waiting for a key pressed only), GetKey 
   keyword can be used instead of Sleep.
   For the general form of Sleep (with parameters), if the user want to 
   clear the keyboard input buffer from any eventual keys pressed during 
   the Sleep execution, he can use after the Sleep instruction line 
   something like the following method:
   While Inkey <> "": Wend  '' loop until the keyboard input buffer is empty
         

Example
   Print "press a key"
   Sleep
   GetKey  '' clear the keyboard input buffer, and even in that code case, the 'Sleep' keyword can be outright omitted
   Print "waiting half second"
   Sleep 500
      

   Dim As String s

   Print "wait 3 seconds or press a key"
   Sleep 3000
   Print "outputed by timeout or key pressed"
   While Inkey <> ""  '' loop until the keyboard input buffer is empty
   Wend

   Input "enter a string"; s
   Print "string entered: " & "'" & s & "'"

   Sleep
      

Dialect Differences
   * In the -lang fb and -lang fblite dialects, the amount value is in 
     milliseconds.
   * In the -lang qb dialect, the amount value is in seconds as in QB. If 
     the second parameter keyflag is given, or the keyword is written as 
     __Sleep  the value is expected to be in milliseconds.

Differences from QB
   * None in the -lang qb dialect.
   * In QB, the delay was given in whole seconds only and did not support 
     the keyflag parameter.

See also
   * Timer
   * Inkey



------------------------------------------------------------ KeyPgSpace ----
Space

Creates a string of a given length filled with spaces (" ")

Syntax
   Declare Function Space( ByVal count As Integer ) As String

Usage
   result = Space[$]( count )

Parameters
   count
      An integer type specifying the length of the string to be created.

Return Value
   The created string. An empty string will be returned if count <= 0.

Description
   Space creates a string with the specified number of spaces.

Example
   Dim a As String
   a = "x" + Space(3) + "x"
   Print a ' prints: x   x

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * None

See also
   * WSpace
   * Spc
   * String (Function)



-------------------------------------------------------------- KeyPgSpc ----
Spc

Output function to skip spaces when writing to screen or file

Syntax
   Spc( columns )

Usage
   Print Spc( spaces ) [(, | ;)] ...

Parameters
   spaces
      number of spaces to skip

Description
   Spc skips over the given number of spaces when Printing to screen or to 
   a file.  The character cells skipped over are left unchanged.

Example
   Print "foo"; Spc(5); "bar"
   Print "hello"; Spc(4); "world"

   '' Uses Spc to justify text instead of Tab

   Dim As String A1, B1, A2, B2

   A1 = "Jane"
   B1 = "Doe"
   A2 = "Bob"
   B2 = "Smith"

   Print "FIRST NAME"; Spc(35 - 10); "LAST NAME"
   Print "----------"; Spc(35 - 10); "----------"
   Print A1; Spc(35 - Len(A1)); B1
   Print A2; Spc(35 - Len(A2)); B2

The output would look like:

   FIRST Name                         LAST Name
   ----------                         ----------
   Jane                               Doe
   Bob                                Smith

Differences from QB
   * In QBASIC, spaces were printed in the gap, while in FreeBASIC, the 
     characters are just skipped over and left untouched.  The Space 
     function can still be used to achieve this effect.

See also
   * Tab
   * Space
   * Print
   * ?



-------------------------------------------------------------- KeyPgSqr ----
Sqr

Returns a square root of a number

Syntax
   Declare Function Sqr ( ByVal number As Double ) As Double

Usage
   result = Sqr( number )

Parameters
   number
      the number (greater than or equal to zero)

Return Value
   Returns the square root of the argument number.

   If number equals zero, Sqr returns zero (0.0).

   If number is less than zero, Sqr returns a special value representing 
   "not defined", printing like "NaN" or "IND", exact text is platform 
   dependent.

Description
   This is the same as raising the argument number to the one-half power: y 
   = x ^ (1/2) . The required number argument can be any valid numeric 
   expression greater than or equal zero.

   If a LongInt or ULongInt is passed to Sqr, it may be converted to Double 
   precision first.  For numbers over 2^52, this will cause a very small 
   loss of precision.  Without making any assumptions about the rounding 
   method, the maximum error due to this will be Sqr(2^64) - Sqr(2^64-2^12)
   , which is about 4.8e-7. However this may cause erroneous results if the 
   floor or ceiling of this value is taken, and the result of this may be 
   out by 1, particularly for square numbers and numbers that are close by.

   Sqr can be overloaded as operator to accept user-defined types.

Example
   '' Example of Sqr function: Pythagorean theorem 
   Dim As Single a, b

   Print "Pythagorean theorem, right-angled triangle"
   Print
   Input "Please enter one leg side length: ", a
   Input "Please enter the other leg side length: ", b
   Print 
   Print "The hypotenuse has a length of: " & Sqr( a * a + b * b )

The output would look like:

   Pythagorean theorem, Right-angled triangle

   Please enter one leg side length: 1.5
   Please enter the other leg side length: 2

   The hypotenuse has a length of: 2.5

Differences from QB
   * None

See also
   * Operator ^ (Exponentiate)
   * Arithmetic Operators



----------------------------------------------------------- KeyPgStatic ----
Static

Defines variables, objects and arrays having static storage

Syntax
   Static symbol1 [ (array-dimensions) ] As DataType [ = expression] [, 
   symbol2 [ (array-dimensions) ] As DataType [ = expression], ...]
      or
   Static As DataType symbol1 [ (array-dimensions) ] [ = expression] [, 
   symbol2 [ (array-dimensions) ] [ = expression], ...]
      or
   Static Var symbol1 = expression [, symbol2 = expression, ...]

      or

   Sub|Function procedurename ( parameters ) [[ ByRef ] As DataType] Static
      ...
   End Sub|Function

Parameters
   symbol
      variable or array symbol name.
   array-dimensions
      lower-bound To upper-bound [, ...]
      or
      Any [, Any...]
      or empty.
   expression
      An constant expression, or an array of constant expressions

Description
   Specifies static storage for variables, objects and arrays; they are 
   allocated at program startup and deallocated upon exit. Objects are 
   constructed once when they are defined, and destructed upon program 
   exit.

   When declaring static arrays, only numeric literals, Constants or 
   Enumerations may be used as subscript range values. Static 
   variable-length arrays must be declared empty (no subscript range list) 
   and resized using ReDim before used.

   In both iterative and recursive blocks, like looping 
   control flow statements or procedures, static variables, objects and 
   arrays local to the block are guaranteed to occupy the same storage 
   across all instantiations of the block. For example, procedures that 
   call themselves - either directly or indirectly - share the same 
   instances of their local static variables.

   A static variable may only be initialised with a constant value: its 
   starting value is set at the start of the program before any code is 
   run, and so it cannot depend on any variables or functions in it.

   When used at procedure definition level (forbidden at declaration line 
   level), Static specifies static storage for all local variables, objects 
   and arrays, except temporary types and internal variables (objects not 
   explicitly declared).

   At module-level variable declaration only, the modifier Shared may be 
   used with the keyword Static to make module-level static variables 
   visible inside procedures.

   When used with in a user-defined type, Static creates 
   Static Member Procedures Or Variables.

Example
   Sub f
      '' times called is initially 0
      Static timesCalled As Integer = 0
      timesCalled += 1
      Print "Number of times called: " & timesCalled
   End Sub

   '' the static variable in f() retains its value between
   '' multiple procedure calls.
   f()
   f()

   Will output:


   Number of times called: 1
   Number of times called: 2

Dialect Differences
   * Variables cannot be initialised in the -lang qb dialect.

Differences from QB
   * QuickBASIC allows variables and arrays to be declared using the 
     Static keyword within procedures and DEF FN routines only.
   * Static forces local visibility of variables and arrays in QuickBASIC 
     DEF FN routines. FreeBASIC supports neither DEF FN routines nor this 
     usage of Static.

See also
   * Static (Member)
   * Dim, ReDim
   * Shared
   * Byref (Variables)
   * Sub (Module), Function (Module)
   * Sub (Member), Function (Member)
   * Option Static
   * Storage Classes
   * Pointers to Procedures



----------------------------------------------------- KeyPgStaticMember ----
Static (Member)

Declare a static member procedure or variable

Syntax
   Type typename
      Static variablename As DataType [, ...]
      Declare Static Sub|Function procedurename ...
      ...
   End Type

   Dim typename.variablename As DataType [= initializer] [, ...]

   [Static] Sub|Function typename.procedurename ...
      ...
   End Sub|Function

Description
   * Static member procedures
      Static methods do not have an implicit This instance argument passed 
      to them. This allows them to be used like normal non-member 
      procedures (for example with callback procedure pointers).  An 
      advantage of Static methods are that they are encapsulated in the 
      typename namespace, and therefore have the ability to access the 
      Private or Protected members or methods of instances of typename.

      Static methods can be called directly anywhere in code, like normal 
      non-member procedures, or on objects of type typename, similar to 
      non-static methods, however either way there is no implicit or 
      explicit This (or explicit Base) access possible from within a static 
      method.

      For member procedures with a Static declaration, Static may also be 
      specified on the corresponding procedure bodies, for improved code 
      readability.

   * Static member variables
      Static member variables are created and initialized only once 
      independently of any object construction, in contrast to non-static 
      ("instance") member variables which are created again and again for 
      each separate object. Static members are always Shared, even if Shared
      was not specified in the declaration. Thus, Static member variables 
      are similar to global variables, except that they are declared in a 
      Type namespace.

      Each Static member variable declared in a Type must be explicitly 
      allocated somewhere outside the type by using a Dim statement. The 
      declaration inside the Type is the prototype that is visible to every 
      module seeing the Type declaration. The definition outside the Type 
      allocates and optionally initializes the Static member variable. 
      There can only be one definition per Static member variable: it can 
      only be allocated in a single module, not in multiple ones. This is 
      the same as for Extern variables.

      A Static member variable is subject to member access control except 
      for its definition outside the Type. If a private Static member 
      variable is to be explicitly initialized outside the Type's member 
      procedures, an initializer must be provided with the definition.

Example
   '' Example showing how the actual procedure invoked by a member can be set at runtime.
   '' using static member procedures.
   Type _Object

     Enum handlertype
      ht_default
      ht_A
      ht_B
     End Enum

     Declare Constructor( ByVal ht As handlertype = ht_default)

     Declare Sub handler()

   Private:
     Declare Static Sub handler_default( ByRef obj As _Object )
     Declare Static Sub handler_A( ByRef obj As _Object )
     Declare Static Sub handler_B( ByRef obj As _Object )
     handler_func As Sub( ByRef obj As _Object )

   End Type

   Constructor _Object( ByVal ht As handlertype )
     Select Case ht
     Case ht_A
      handler_func = @_Object.handler_A
     Case ht_B
      handler_func = @_Object.handler_B
     Case Else
      handler_func = @_Object.handler_default
     End Select
   End Constructor

   Sub _Object.handler()
     handler_func(This)
   End Sub

   Sub _Object.handler_default( ByRef obj As _Object )
     Print "Handling using default method"
   End Sub

   Sub _Object.handler_A( ByRef obj As _Object )
     Print "Handling using method A"
   End Sub

   Sub _Object.handler_B( ByRef obj As _Object )
     Print "Handling using method B"
   End Sub

   Dim objects(1 To 4) As _Object => _
     { _
      _Object.handlertype.ht_B, _
      _Object.handlertype.ht_default, _
      _Object.handlertype.ht_A _
     }
     '' 4th array item will be _Object.handlertype.ht_default

   For i As Integer = 1 To 4
     Print i,
     objects(i).handler()
   Next i

   '' Assign an unique ID to every instance of a Type (ID incremented in order of creation)

   Type UDT
     Public:
      Declare Property getID () As Integer
      Declare Constructor ()
     Private:
      Dim As Integer ID
      Static As Integer countID
   End Type
   Dim As Integer UDT.countID = 0

   Property UDT.getID () As Integer
     Property = This.ID
   End Property

   Constructor UDT ()
     This.ID = UDT.countID
     UDT.countID += 1
   End Constructor

   Dim As UDT uFirst
   Dim As UDT uSecond
   Dim As UDT uThird

   Print uFirst.getID
   Print uSecond.getID
   Print uThird.getID

Differences from QB
   * New to FreeBASIC

See also
   * Class
   * Declare
   * Type
   * Static



---------------------------------------------------------- KeyPgStdcall ----
stdcall

Specifies a stdcall-style calling convention in a procedure declaration

Syntax
   Sub name stdcall [Overload] [Alias "alias"] ( parameters )
   Function name stdcall [Overload] [Alias "alias"] ( parameters ) [ ByRef 
   ] As return_type

Description
   In procedure declarations, stdcall specifies that a procedure will use 
   the stdcall calling convention. In the stdcall calling convention, any 
   parameters are to be passed (pushed onto the stack) in the reverse order 
   in which they are listed, that is, from right to left. The procedures 
   need not preserve the EAX, ECX or EDX registers, and must clean up the 
   stack (pop any parameters) before it returns.

   stdcall is not allowed to be used with variadic procedure declarations 
   (those with the last parameter listed as "...").

   stdcall is the default calling convention on Windows, unless another 
   calling convention is explicitly specified or implied by one of the 
   Extern Blocks. stdcall is also the standard (or most common) calling 
   convention used in BASIC languages, and the Windows API.

Example
   Declare Function Example stdcall (param1 As Integer, param2 As Integer) As Integer
   Declare Function Example2 cdecl (param1 As Integer, param2 As Integer) As Integer

   Function Example stdcall (param1 As Integer, param2 As Integer) As Integer
      ' This is an STDCALL function, the first parameter on the stack is param2, since it was pushed last.
      Print param1, param2
      Return param1 Mod param2
   End Function

   Function Example2 cdecl (param1 As Integer, param2 As Integer) As Integer
      ' This is a CDECL function, the first parameter on the stack is param1, since it was pushed last.
      Print param1, param2
      Return param1 Mod param2
   End Function

Platform Differences
   * On Windows systems, stdcall procedures have an "@N" decoration added 
     to their internal/external name, where N is the size of the parameter 
     list, in bytes.

Differences from QB
   * New to FreeBASIC

See also
   * pascal, cdecl
   * Declare
   * Sub, Function



------------------------------------------------------------- KeyPgStep ----
Step

Statement modifier.

Syntax
   For iterator = initial_value To end_value Step increment

   Line [ buffer, ] Step ( x1, y1 ) - Step ( x2, y2 ) [, [ color ][, [ B|BF 
   ][, style ] ] ]

   Circle [ target, ] Step ( x, y ), radius [, [ color ][, [ start ][, [ 
   end ][, [ aspect ][, F] ] ] ] ]

   Paint [ target, ] STEP ( x, y ) [, [ paint ][, [ border_color ] ] ]

Description
   In a For statement, Step specifies the increment of the loop iterator 
   with each loop.

   In a Line, Circle or Paint statement, Step indicates that the following 
   coordinate has values relative to the graphics cursor.

Example
   Dim i As Integer
   For I=10 To 1 Step -1
   Next

   Line -Step(10,10),13

See also
   * For...Next
   * Line
   * Circle
   * Paint



------------------------------------------------------------ KeyPgStick ----
Stick

Reads axis position from attached gaming devices

Syntax
   Declare Function Stick ( ByVal axis As Long ) As Long

Usage
   result = Stick( axis )

Parameters
   axis
      the axis number to query for position

Return Value
   Returns a number between 1 and 200 for specified axis, otherwise zero 
   (0), if the device is not attached.

Description
   Stick will retrieve the axis position for the first and second axes on 
   the first and second gaming devices.  axis must be a number between 0 
   and 3 having the following meaning:

      +----+------------------------------------------------------+
      |Axis|Returns                                               |
      |0   |X position of gaming device A                         |
      |1   |Y position of gaming device A when STICK(0) was called|
      |2   |X position of gaming device B when STICK(0) was called|
      |3   |Y position of gaming device B when STICK(0) was called|
      +----+------------------------------------------------------+

   Stick(0) must first be called to obtain the positions for the other 
   axes.

Example
   '' Compile with -lang qb

   '$lang: "qb"

   Screen 12

   Do
      Locate 1, 1
      Print "Joystick A-X position : "; Stick(0); "   "
      Print "Joystick A-Y position : "; Stick(1); "   "
      Print "Joystick B-X position : "; Stick(2); "   "
      Print "Joystick B-Y position : "; Stick(3); "   "
      Print
      Print "Button A1 was pressed : "; Strig(0); "  "
      Print "Button A1 is pressed  : "; Strig(1); "  "
      Print "Button B1 was pressed : "; Strig(2); "  "
      Print "Button B1 is pressed  : "; Strig(3); "  "
      Print "Button A2 was pressed : "; Strig(4); "  "
      Print "Button A2 is pressed  : "; Strig(5); "  "
      Print "Button B2 was pressed : "; Strig(6); "  "
      Print "Button B2 is pressed  : "; Strig(7); "  "
      Print
      Print "Press ESC to Quit"

      If Inkey$ = Chr$(27) Then
         Exit Do
      End If

      Sleep 1

   Loop

Dialect Differences
   * Only available in the -lang qb dialect.

Differences from QB
   * None

See also
   * GetJoystick
   * Strig



------------------------------------------------------------- KeyPgStop ----
Stop

Halts program execution, and waits for a key press before ending the 
program.

Syntax
   Declare Sub Stop ( ByVal retval As Long = 0 )

Usage
   Stop

Parameters
   retval
      Error code returned to system.

Description
   Halts the execution of the program and stands by. It's  provided as a 
   help to debugging, as it preserves the memory and doesn't close files. 
   For normal program termination the End keyword should be used. An 
   optional return value, an integer, can be specified to return an error 
   code to the system. If no return value is given, a value of 0 is 
   automatically returned.

   Note: STOP is not implemented properly yet; currently it is the same as 
   System.

Example
   Print "this text is shown"
   Sleep
   Stop
   Print "this text will never be shown"

Differences from QB
   * None

See also
   * End



-------------------------------------------------------------- KeyPgStr ----
Str

Returns a string representation of a number, boolean or Unicode character 
string

Syntax
   Declare Function Str ( ByVal n As Byte ) As String
   Declare Function Str ( ByVal n As UByte ) As String
   Declare Function Str ( ByVal n As Short ) As String
   Declare Function Str ( ByVal n As UShort ) As String
   Declare Function Str ( ByVal n As Long ) As String
   Declare Function Str ( ByVal n As ULong ) As String
   Declare Function Str ( ByVal n As LongInt ) As String
   Declare Function Str ( ByVal n As ULongInt ) As String
   Declare Function Str ( ByVal n As Single ) As String
   Declare Function Str ( ByVal n As Double ) As String
   Declare Function Str ( ByVal b As Boolean ) As String
   Declare Function Str ( ByRef str As Const String ) As String
   Declare Function Str ( ByVal str As Const WString ) As String

Usage
   result = Str[$]( number )
      or
   result = Str( string )

Parameters
   number
      Numeric expression to convert to a string.
   string
      String expression to convert to a string.

Description
   Str converts numeric variables to their string representation. Used this 
   way it is the String equivalent to WStr applied to numeric variables, 
   and the opposite of the Val function, which converts a string into a 
   number.

   Str converts boolean variables to their string representation "false" / 
   "true".

   Str also converts Unicode character strings to ASCII character strings. 
   Used this way it does the opposite of WStr. If an ASCII character string 
   is given, that string is returned unmodified.

Example
   Dim a As Integer
   Dim b As String
   a = 8421
   b = Str(a)
   Print a, b

Dialect Differences
   * In the -lang qb dialect, Str will left pad a positive number with a 
     space.
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Platform Differences
   * DOS version/target of FreeBASIC does not support the wide-character 
     string version of Str.

Differences from QB
   * QB does not support the wide-character string version of Str.

See also
   * Val
   * CBool
   * Chr
   * Asc



------------------------------------------------------------ KeyPgStrig ----
Strig

Reads button state from attached gaming devices

Syntax
   Declare Function Strig ( ByVal button As Long ) As Long

Usage
   result = Strig( button )

Parameters
   button
      the button to query for state

Return Value
   Returns -1 (pressed) or 0 (not-pressed) to indicate the state of the 
   button requested.

Description
   Strig will retrieve the button state for the first and second buttons on 
   the first and second gaming devices.  button must be a number between 0 
   and 7 and has the following meaning:

      +------+------------------------------------------------------------------+
      |Button|State to return                                                   |
      |0     |First button on gaming device A pressed since STICK(0) was called |
      |1     |First button on gaming device A is pressed                        |
      |2     |First button on gaming device B pressed since STICK(0) was called |
      |3     |First button on gaming device B is pressed                        |
      |4     |Second button on gaming device A pressed since STICK(0) was called|
      |5     |Second button on gaming device A is pressed                       |
      |6     |Second button on gaming device B pressed since STICK(0) was called|
      |7     |Second button on gaming device B is pressed                       |
      +------+------------------------------------------------------------------+

   Calling Stick(0) will reset the state returned where button is equal to 
   0, 2, 4, or 6.

Example
   '' Compile with -lang qb

   '$lang: "qb"

   Screen 12

   Do
      Locate 1, 1
      Print "Joystick A-X position : "; Stick(0); "   "
      Print "Joystick A-Y position : "; Stick(1); "   "
      Print "Joystick B-X position : "; Stick(2); "   "
      Print "Joystick B-Y position : "; Stick(3); "   "
      Print
      Print "Button A1 was pressed : "; Strig(0); "  "
      Print "Button A1 is pressed  : "; Strig(1); "  "
      Print "Button B1 was pressed : "; Strig(2); "  "
      Print "Button B1 is pressed  : "; Strig(3); "  "
      Print "Button A2 was pressed : "; Strig(4); "  "
      Print "Button A2 is pressed  : "; Strig(5); "  "
      Print "Button B2 was pressed : "; Strig(6); "  "
      Print "Button B2 is pressed  : "; Strig(7); "  "
      Print
      Print "Press ESC to Quit"

      If Inkey$ = Chr$(27) Then
         Exit Do
      End If

      Sleep 1

   Loop

Dialect Differences
   * Only available in the -lang qb dialect.

Differences from QB
   * None

See also
   * GetJoystick
   * Stick



--------------------------------------------------- KeyPgStringFunction ----
String (Function)

Creates and fills a string of a certain length with a certain character

Syntax
   Declare Function String ( ByVal count As Integer, ByVal ch_code As Long 
   ) As String
   Declare Function String ( ByVal count As Integer, ByRef ch As Const 
   String ) As String

Usage
   result = String[$]( count, ch_code )
      or
   result = String[$]( count, ch )

Parameters
   count
      An integer specifying the length of the string to be created.
   ch_code
      A long specifying the ASCII character code to be used to fill the 
      string.
   ch
      A string whose first character is to be used to fill the string.

Return Value
   The created string. An empty string will be returned if either ch is an 
   empty string, or count <= 0.

Description
   The String function returns a string with a length of count, filled with 
   a given ch_code or ch.

Example
   Print String( 4, 69 )         '' prints "EEEE"
   Print String( 5, "Indeed" )   '' prints "IIIII"
   End 0

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * None 

See also
   * String (data type)
   * Space

   


----------------------------------------------------------- KeyPgString ----
String

Standard data type: 8 bit character string

Syntax
   Dim variable As String [ * size]

Description
   A String is an array of characters.

   A String declared without the size parameter is dynamically resized 
   depending on the length of the string. The length can range from 0 bytes 
   to 2 gigabytes. A descriptor contains a pointer to the actual string, 
   the length of the string, and the amount of space allocated for it. 
   VarPtr will return a pointer to the descriptor, while StrPtr will point 
   to the actual string.

   Because of the hidden descriptor with a String, manual allocation of 
   space, for example using the memory allocation function CAllocate 
   (preferentially), for a String is not encouraged. The common way to 
   ensure a certain amount of space is reserved for a String, to prevent 
   unnecessary allocations inside a loop for instance, is to use the Space 
   or String functions.

   Nevertheless if necessary, dynamic allocation may be carefully used by 
   means of the memory allocation functions Allocate, CAllocate, Reallocate 
   (see precautions for use) and string pointer (which is a pointer to a 
   string descriptor, not string data). When memory is allocated to hold 
   string descriptors, the string must always be destroyed (setting to "") 
   before deallocate each string descriptor (allowing to deallocate the 
   memory taken up by the string data), otherwise, it is not possible to 
   deallocate it later, and it may induce memory leak in the program 
   continuation.

   A simpler and safer method for dynamic allocation /deallocation is to 
   use the advanced New / Delete keyword (which itself also calls the 
   constructor / destructor of the string object).

   Despite the use of the descriptor, an implicit NULL character (Chr(0)) 
   is added to the end of the string, to allow passing them to functions in 
   external libraries without making slow copies.  FreeBASIC's internal 
   functions will ignore this character, and not treat it as part of the 
   string.

   A String declared with a fixed size (numeric constant, or expression 
   that can be evaluated at compile time) is a QB-style fixed length 
   string, with the exception that unused characters are set to 0, 
   regardless of what "-lang" compiler option is used. It has no descriptor 
   and it is not resized to fit its contents. As in QB, if data overflows 
   the size of the string, it is truncated on the right side.
   Fixed length strings are also terminated with a NULL character, and so 
   they use size + 1 bytes of space.  This NULL terminator may be removed 
   in future, to prevent the redundant character complicating data layout 
   in user-defined Types.

   String variable names need not end in a dollar sign $ as in other 
   dialects of BASIC.  In lang fb variable suffixes, including the dollar 
   sign, are disallowed entirely.

Example

   '' Variable length
   Dim a As String

   a = "Hello"
   Print a

   a += ", world!"
   Print a

   Dim As String b = "Welcome to FreeBASIC"
   Print b + "! " + a

   '' QB-like $ suffixes
   #lang "qb"

   '' DIM based on $ suffix
   Dim a$
   a$ = "Hello"

   '' Implicit declaration based on $ suffix
   b$ = ", world!"

   Print a$ + b$

   '' Variable-length strings as buffers

   '' Reserving space for a string,
   '' using Space() to produce lots of space characters (ASCII 32)
   Dim As String mybigstring = Space(1024)
   Print "buffer address: &h" & Hex( StrPtr( mybigstring ), 8 ) & ", length: " & Len( mybigstring )

   '' Explicitly destroying a string
   mybigstring = ""
   Print "buffer address: &h" & Hex( StrPtr( mybigstring ), 8 ) & ", length: " & Len( mybigstring )

   '' Variable-length string as Const parameter

   '' Const qualifier preventing string from being modified
   Sub silly_print( ByRef printme As Const String )
      Print ".o0( " & printme & " )0o."
      'next line will cause error if uncommented
      'printme = "silly printed"
   End Sub

   Dim As String status = "OK"

   silly_print( "Hello FreeBASIC!" )
   silly_print( "Status: " + status )

Differences from QB
   * In QB the strings were limited to 32767 characters.
   * In QB, the unused characters of a fixed-length string were 
     initialized with 32 (space, or " ", in ASCII).
   * In QB static or fixed-size strings were often used in records to 
     represent a number of bytes of data;  for example, a string of 1 
     length to represent 1 byte in a UDT read from a file.  This is not 
     possible in FreeBASIC since strings always have an NULL character 
     following.  When converting QBasic code that reads UDTs from files, 
     make sure all instances of "As String * n" are replaced with "As uByte 
     (0 to n - 1)" or your files will be incompatible.

See also
   * String (Function)
   * Space
   * ZString
   * WString
   * Str
   * StrPtr
   * VarPtr
   * Standard Data Type Limits
   * Operator [] (String Index)
   * String Operators



--------------------------------------------------------- KeyPgOpStrptr ----
Operator Strptr (String Pointer)

Returns the address of a string's character data.

Syntax
   Declare Operator StrPtr ( ByRef lhs As String ) As ZString Ptr
   Declare Operator StrPtr ( ByRef lhs As WString ) As WString Ptr

Usage
   result = StrPtr ( lhs )

Parameters
   lhs
      A string.

Return Value
   Returns a ZString/WString Ptr to a string/wstring's character data (null 
   value in case of empty string).

Description
   This operator returns a ZString/WString Ptr that points to the beginning 
   of a string/wstring's character data. Operator Strptr is the proper 
   method for acquiring the address of a string's character data.
   In case of empty String (only for variable length strings), Operator 
   Strptr returns a null pointer.

   The related Operator Varptr (Variable Pointer) and 
   Operator @ (Address Of), when used with a String, return the address of 
   the internal string descriptor.
   When a variable length string is modified, the address of its descriptor 
   remains always the same, but the the string's character data address 
   (returned by Operator Strptr) may change (like any allocated memory that 
   must be reallocated).
   When a fixed length string is modified, the string's character data 
   address (returned by Operator Strptr) is unchanged.

   Note: For a variable length string, the operator returns a ZString Const 
   Ptr (because returning by reference the string's characters pointer set 
   in the string descriptor, this one is to be considered as read only). If 
   the keyword Var is used to declare/initialize a user pointer from 
   Operator Strptr, this user pointer is also defined as read only (it can 
   not be modified further).

Example
   '' This example uses Strptr to demonstrate using pointers with strings
   Dim myString As String
   Dim toMyStringDesc As Any Ptr
   Dim toMyString As ZString Ptr

   '' Note that using standard VARPTR notation will return a pointer to the
   '' descriptor, not the string data itself
   myString = "Improper method for Strings"
   toMyStringDesc = @myString
   Print myString
   Print Hex( toMyStringDesc )
   Print

   '' However, using Strptr returns the proper pointer
   myString = "Hello World Examples Are Silly"
   toMyString = StrPtr(myString)
   Print myString
   Print *toMyString
   Print

   '' And the pointer acts like pointers to other types
   myString = "MyString has now changed"
   Print myString
   Print *toMyString
   Print

Differences from QB
   * New to FreeBASIC, but does exactly the same thing as SAdd

See also
   * SAdd
   * VarPtr
   * ProcPtr
   * Pointers



-------------------------------------------------------------- KeyPgSub ----
Sub

Defines a procedure

Syntax
   [Public|Private] Sub identifier [cdecl|pascal|stdcall] [Overload] [Alias 
   external_identifier] [( [parameter_list] )] [Static] [Export]
      statements
      ...
      [Return]
      ...
   End Sub

   [Public] Sub identifier [cdecl|pascal|stdcall] [Overload] [Alias 
   external_identifier] [()] [Constructor|Destructor] [Static]
      statements
      ...
      [Return]
      ...
   End Sub

Parameters
      identifier: the name of the subroutine
      external_identifier: externally visible (to the linker) name enclosed 
      in quotes
      parameter_list: parameter[, parameter[, ...]]
      parameter: [ByRef|ByVal] identifier [As type] [= default_value]
         identifier: the name of the variable referenced in the subroutine. 
         If the argument is an array then the identifier must be followed 
         by an empty parenthesis.
         type: the type of variable
         default_value: the value of the argument if none is specified in 
         the call
      statements: one or more statements that make up the subroutine body

Description
   A subroutine is a block of code which may be called at any time from a 
   program. This code may need to be executed multiple times, and 
   subroutines provide an invaluable means to simplify code by replacing 
   these blocks of code with a single subroutine call. A subroutine also 
   serves to allow a user to extend the FreeBASIC language to provide 
   custom commands. Many of the functions built into FreeBASIC are merely 
   subroutines part of a "runtime library" linked to by default.

   The Sub keyword marks the beginning of a subroutine, and its end is 
   marked by End Sub. The "name" parameter is the name by which this 
   subroutine is called. For instance, if the declaration is "Sub...End Sub
   ", the user can execute the code in between "Sub foo" and "End Sub" by 
   using "foo" as a statement. This code is executed separate from the code 
   which calls the subroutine, so any variable names, unless they are 
   shared, are not available to the subroutine. Values can, however, be 
   passed using parameters.

   Parameters are the arguments passed to any statement. For instance, if a 
   user executes a statement as "Print 4", the value "4" is passed to the 
   function "Print". Parameters that need to be passed to a subroutine are 
   supplied by one or more parameter arguments in the "Sub" keyword. 
   Creating a subroutine with "Sub mysub(foo, bar)...End Sub", allows the 
   code in between "Sub" and "End Sub" to refer to the first passed 
   argument as "foo" and the second passed argument as "bar". If a 
   parameter is given a default value, that parameter is optional.
   Array parameters are specified by following an identifier with an empty 
   parenthesis. Note that array parameters are always ByRef and the ByRef 
   keyword is neither required nor allowed for array parameters. When 
   calling a subroutine with an array argument the parenthesis must be 
   supplied there too.

   In the default dialect -lang fb, parameters must also have a supplied 
   type, in the form "parameter as type". Type suffixes are not allowed.

   In the -lang qb and -lang fblite dialects only, it will be given a 
   default type if the type is not explicitly given either by name or by 
   type suffix. The default type is Single in the -lang qb dialect and 
   Integer in the -lang fblite dialect.

   A subroutine can also specify how parameters are passed, either as "ByRef
   " or "ByVal", as shown in the syntax definition. If a parameter is "ByRef
   ", the parameter name literally becomes a reference to the original 
   variable passed to the subroutine. Any changes made to that variable 
   will be reflected outside of the subroutine. If a parameter is passed "
   ByVal", however, the value of any passed variable is copied into a new 
   variable, and any changes made to it will not affect the original.

   The Static specifier indicates that the values of all local variables 
   defined in the sub should be preserved between calls. To specify 
   individual local variables as static see the Static keyword.
   To access duplicated symbols defined as global outside the subroutine 
   body, add one or preferably two dot(s) as prefix: .SomeSymbol or 
   preferably ..SomeSymbol (or only ..SomeSymbol if inside a With..End With 
   block).

   Sub is the same as Function, except it does not allow a value to be 
   returned.

   When calling a subroutine, parentheses after the subroutine name 
   (surrounding the argument list if any) are optional.

   The second syntax defines either a constructor or destructor using the 
   Constructor and Destructor keywords, respectively. Constructor 
   subroutines are executed before the first line of code in the module, 
   while destructors execute on module exit. Note the public access 
   specifier and empty parameter list for both constructors and 
   destructors.

   Warning for 64-bit compiler only: See the Identifier Rules page for the 
   choice of user procedure identifier names (and specially the 'Platform 
   Differences' paragraph).

Example
   '' Example of writing colored text using a sub:

   Sub PrintColoredText( ByVal colour As Integer, ByRef text As String )
      Color colour
      Print text
   End Sub

      PrintColoredText( 1, "blue" )        '' a few colors
      PrintColoredText( 2, "green" )
      PrintColoredText( 4, "red" )
      Print
      
      Dim i As Integer
      For i = 0 To 15                        '' all 16 colors
        PrintColoredText( i, ("color " & i) )
      Next i

   ' The following demonstrates optional parameters.

   Sub TestSub(P As String = "Default")
      Print P
   End Sub

   TestSub "Testing:"
   TestSub

Dialect Differences
   * The -lang qb and -lang fblite dialects keep the QB convention: 
     parameters are ByRef by default.
   * In the -lang fb dialect, numeric parameters are passed ByVal by 
     default.  Strings and UDTs are passed ByRef by default.

Differences from QB
   * Public and Private access specifiers are new to FreeBASIC.
   * Constructor subroutines are new to FreeBASIC.

See also
   * Declare
   * Function
   * Exit
   * Public
   * Private
   * Static

   


-------------------------------------------------------- KeyPgMemberSub ----
Sub (Member)

Declares or defines a member procedure

Syntax
   { Type | Class | Union } typename
      Declare [ Static | Const ] Sub fieldname [calling convention 
      specifier] [ Alias external_name ] ( [ parameters ] ) [ Static ] 
   End { Type | Class | Union }

   Sub typename.fieldname ( [ parameters ] ) [ Export ]
      statements
   End Sub

Parameters
   typename 
      name of the Type, Class, or Union
   fieldname 
      name of the procedure
   external_name
      name of field as seen when externally linked
   parameters 
      the parameters to be passed to the procedure
   calling convention specifier	
      can be one of: cdecl, stdcall or pascal

Description
   Sub members are accessed with Operator . (Member Access) or 
   Operator -> (Pointer To Member Access) to call a member procedure and 
   may optionally accept parameters either ByVal or ByRef.  typename be 
   overloaded  without explicit use of the Overload keyword.

   typename is the name of the type for which the Sub method is declared 
   and defined.  Name resolution for typename follows the same rules as 
   procedures when used in a Namespace.

   A hidden This parameter having the same type as typename is passed to 
   non-static member procedures.  This is used to access the fields of the 
   Type, Class, or Union.
   To access duplicated symbols defined as global outside the Type, add one 
   or preferably two dot(s) as prefix: .SomeSymbol or preferably ..
   SomeSymbol (or only ..SomeSymbol if inside a With..End With block).

   A Static (Member) may be declared using the Static specifier.  A 
   Const (Member) may be declared using the Const specifier.

Example
   Type Statistics
     count As Single
     sum As Single
     Declare Sub AddValue( ByVal x As Single )
     Declare Sub ShowResults( )
   End Type

   Sub Statistics.AddValue( ByVal x As Single )
     count += 1
     sum += x
   End Sub

   Sub Statistics.ShowResults( )
     Print "Number of Values = "; count
     Print "Average          = ";
     If( count > 0 ) Then
      Print sum / count
     Else
      Print "N/A"
     End If
   End Sub

   Dim stats As Statistics

   stats.AddValue 17.5
   stats.AddValue 20.1
   stats.AddValue 22.3
   stats.AddValue 16.9

   stats.ShowResults

Output:

   Number of Values =  4
   Average          =  19.2

Dialect Differences
   * Only available in the -lang fb dialect.

See also
   * Class
   * Function (Member)
   * Sub
   * Type



----------------------------------------------------------- KeyPgSubPtr ----
Sub Pointer

Data type that stores a pointer to a Sub procedure

Syntax
   Dim variable As Sub [cdecl|pascal|stdcall] [( [parameter_list] )] [= 
   initializer]

Parameters
      parameter_list: parameter[, parameter[, ...]]
      parameter: [ByRef|ByVal] identifier [As type] [= default_value]
         identifier: the name of the variable referenced in the subroutine
         type: the type of variable
         default_value: the value of the argument if none is specified in 
         the call
      intializer: address of a subroutine to set as the intial value

Description
   A Sub pointer is a procedure pointer that stores the memory location of 
   compiled code.  If no intializer is given the default initial value is 
   zero (0).

   The memory address for the Sub procedure can be assigned to the variable 
   by taking the address of a subroutine with ProcPtr or 
   Operator @ (Address Of).

   The procedure must match the same Sub declaration as the declared Sub 
   pointer.

   To call the subroutine assigned, use the variable name as if it were a 
   normal declared Sub, always with parentheses around the parameter list 
   even empty (without parentheses, only the pointer value, ie the address 
   of the subroutine, would be accessed).

   One of the primary uses for Sub pointers is to create callback 
   procedures:
      - A callback Sub is a Sub that is passed through an argument (a Sub 
      pointer) to another procedure which is expected to call back 
      (execute) the "argument" at a convenient time.
      - If the callback Sub is completely executed before the invocation 
      returns to the caller code, then the callback process is said to be 
      "synchronous".
      - If the invocation immediately returns to the caller code, and the 
      callback Sub and the caller's next code are running in parallel, then 
      the callback process is said to be "asynchronous".

Example
      Sub Hello()
         Print "Hello"
      End Sub

      Sub Goodbye()
         Print "Goodbye"
      End Sub

      Dim x As Sub() = ProcPtr( Hello )

      x()

      x = @Goodbye  '' or procptr(Goodbye)

      x()

   Sub s0 ()
     Print "'s0 ()'"
   End Sub

   Sub s1 (ByVal I As Integer)
     Print "'s1 (Byval As Integer)'", I
   End Sub

   Sub s2 (ByRef S As String, ByVal D As Double)
     Print "'s2 (Byref As String, Byval As Double)'", S, D
   End Sub

   Dim s0_ptr As Sub () = @s0
   Dim s1_ptr As Sub (ByVal I As Integer) = @s1
   Dim s2_ptr As Sub (ByRef S As String, ByVal D As Double) = @s2

   s0_ptr()
   s1_ptr(3)
   s2_ptr("PI", 3.14)

   ' Example of advanced callback Sub mechanism (asynchronous) to implement a key pressed event:
   ' (the user callback Sub address can be modified while the event thread is running)
   '   - An asynchronous thread tests the keyboard in a loop, and calls a user callback Sub each time a key is pressed.
   '   - An UDT groups the common variables used (callback Sub pointer, character of key pressed, thread end flag),
   '       and the static thread Sub plus the thread handle.
   '   - An UDT instance pointer is passed to the thread, which then transmits it to the callback Sub each time.
   '   - The callback Sub prints the character of the key pressed character,
   '       but if the key pressed is <escape> it orders the thread to finish.
   '   - As the user callback pointer is a member field of the UDT, it can be modified while the thread is running.

   '' UDT for thread environment
     Type threadUDT
      Dim As Sub (ByVal As ThreadUDT Ptr) callback             '' callback Sub pointer
      Dim As Integer threadEnd                                 '' thread end flag
      Dim As String s                                          '' character of the key pressed
      Declare Static Sub threadInkey (ByVal p As Any Ptr)      '' static thread Sub
      Dim As Any Ptr threadHandle                              '' handle to the thread
     End Type

   '' thread Sub definition
     Sub threadUDT.threadInkey (ByVal p As Any Ptr)
      Dim As threadUDT Ptr pt = p                              '' convert the any ptr to a threadUDT pointer
      Do
        pt->s = Inkey
        If pt->s <> "" AndAlso pt->callback > 0 Then           '' test condition key pressed & callback Sub defined
         pt->callback(p)
        End If
        Sleep 50, 1
      Loop Until pt->threadEnd                                 '' test condition to finish thread
     End Sub

   '' user callback Sub definition
     Sub printInkey (ByVal pt As threadUDT Ptr)
      If Asc(pt->s) = 27 Then                                  '' test condition key pressed = <escape>
        pt->threadEnd = -1                                     '' order thread to finish
        Print
      Else
        Print pt->s;
      End If
     End Sub

   '' user main code
     Dim As ThreadUDT t                                         '' create an instance of threadUDT
     t.threadHandle = ThreadCreate(@threadUDT.threadInkey, @t)  '' launch the thread, passing the instance address
     t.callback = @printInkey                                   '' initialize the callback Sub pointer
     ThreadWait(t.threadHandle)                                 '' wait for the thread finish

Differences from QB
   * New to FreeBASIC

See also
   * Sub
   * ProcPtr
   * Operator @ (Address Of)



------------------------------------------------------------- KeyPgSwap ----
Swap

Exchanges the values of two variables

Syntax
   Declare Sub Swap  ( ByRef a As Any, ByRef b As Any )

Parameters
   a
      A variable to swap.
   b
      A variable to swap.

Description
   Swaps the value of two variables, including UDT instances (swaps all 
   data members).

   Note: When the data are referenced by a pointer, alone or within a 
   descriptive structure (a UDT, for example), Swap only exchanges the 
   values of the pointers or the contents of the descriptive structures 
   without accessing data themselves.
   For var-len strings, Swap only exchanges the descriptors of the strings 
   rather than reallocate memory for exchange all strings data characters.
   For UDTs, Swap simply exchanges the contents of the structures, without 
   any operators or methods being called.

Example
   ' using swap to order 2 numbers:
   Dim a As Integer, b As Integer

   Input "input a number: "; a
   Input "input another number: "; b
   If a > b Then Swap a, b
   Print "the numbers, in ascending order are:"
   Print a, b

Differences from QB
   * None

See also
   * Operator = (Assignment)



----------------------------------------------------------- KeyPgSystem ----
System

Closes all open files and ends the program

Syntax
   Declare Sub System ( ByVal retval As Long = 0 )

Usage
   System( [ retval ] )

Parameters
   retval
      Error code returned to system.

Description
   Closes all open files, exits the program, and returns to the operating 
   system. An optional return value, an integer, can be specified to return 
   an error code to the system. If no return value is given, a value of 0 
   is automatically returned. This is the same as End and is here for 
   compatibility between older BASIC dialects. It is recommended to use End 
   instead.

   Usage of this statement does not cleanly close scope. Local variables 
   will not have their destructors called automatically, because FreeBASIC 
   does not do stack unwinding. Only the destructors of global variables 
   will be called in this case.

   For this reason, it is discouraged to use System simply to mark the end 
   of a program; the program will come to an end automatically, and in a 
   cleaner fashion, when the last line of module-level code has executed.

Example
   Print "this text is shown"
   System
   Print "this text will never be shown"

Differences from QB
   * None

See also
   * End




============================================================================
    T

-------------------------------------------------------------- KeyPgTab ----
Tab

Sets the column when writing to screen or file

Syntax
   Tab( col_num )

Usage
   Print Tab( column ) [(, | ;)] ...

Parameters
   column
      1-based column number to move to

Description
   Tab will move the cursor to given column number when Printing to screen 
   or to a file.  Character cells skipped over between the old and new 
   cursor positions are left unchanged.
   If the current column is greater than column, then Tab will move the 
   cursor to the requested column number on the next line.  If the current 
   column is equal to column, then the cursor will not move anywhere.

Example
   '' Using Print with Tab to justify text in a table

   Dim As String A1, B1, A2, B2

   A1 = "Jane"
   B1 = "Doe"
   A2 = "Bob"
   B2 = "Smith"

   Print "FIRST NAME"; Tab(35); "LAST NAME"
   Print "----------"; Tab(35); "----------"
   Print A1; Tab(35); B1
   Print A2; Tab(35); B2

The output would look like:

   FIRST Name                         LAST Name
   ----------                         ----------
   Jane                               Doe
   Bob                                Smith

Differences from QB
   * In QBASIC, spaces were printed in the gap, while in FreeBASIC, the 
     characters are just skipped over and left untouched.

See also
   * Spc
   * Locate
   * Pos
   * Print
   * ?



-------------------------------------------------------------- KeyPgTan ----
Tan

Returns the tangent of an angle

Syntax
   Declare Function Tan ( ByVal angle As Double ) As Double

Usage
   result = Tan( angle )

Parameters
   angle
      the angle (in radians)

Return Value
   Returns the tangent of the argument angle as a Double within the range 
   of -infinity to infinity.

Description
   The argument angle is measured in radians (not degrees).

   The value returned by this function is undefined for values of angle 
   with an absolute value of 2 ^ 63 or greater.

   Tan can be overloaded as operator to accept user-defined types.

Example
   Const PI As Double = 3.1415926535897932
   Dim a As Double
   Dim r As Double
   Input "Please enter an angle in degrees: ", a
   r = a * PI / 180   'Convert the degrees to Radians
   Print ""
   Print "The tangent of a" ; a; " degree angle is"; Tan ( r ) 
   Sleep

The output would look like:

   Please enter an angle in degrees: 75
   The tangent of a 75 degree angle Is 3.732050807568878

Differences from QB
   * None

See also
   * Atn
   * Atan2
   * Sin
   * Cos
   * A Brief Introduction To Trigonometry



------------------------------------------------------------- KeyPgThen ----
Then

Control flow statement for conditional branching.

Syntax
   If expression Then [statement(s)] [Else [statement(s)]] [End If]
or
   If expression Then : [statement(s)] [Else [statement(s)]] : End If
or
   If expression Then
      [statement(s)]
   [ ElseIf expression Then ]
      [statement(s)]
   [ Else ]
      [statement(s)]
   End If

   Remark: EndIf (without blank) is also supported like in QB for backward 
   compatibility.

Example
   See example at If...Then.

Differences from QB
   * None

See also
   * If...Then

   


------------------------------------------------------------- KeyPgThis ----
This

Hidden instance parameter passed to non-static member functions in a Type 
or Class

Syntax
   This.fieldname
or
   With This
      .fieldname
   End With

Description
   This is a reference to an instance of a Type or Class that is passed 
   (through a hidden Byref Parameter) to all non-static member functions of 
   that type or class. Non-static member functions are procedures declared 
   inside the body of a Type or Class and include Sub, Function, Constructor
   , Destructor, assignment or Cast Operator, and Property procedures.

   The This additional parameter has the same data type as the Type or Class
   in which the procedure is declared.

   The This parameter can be used just like any other variable, ie., pass 
   it to procedures taking an object of the same type, call other member 
   procedures and access member data using Operator . (Member Access), etc.

   Most of the time, using This explicitly for member access is 
   unnecessary; member procedures can refer to other members of the 
   instance which they are passed directly by name, without having to 
   qualify it with This and Operator . (Member Access). The only times when 
   you need to qualify member names with This is when the member is 
   shadowed, for example by duplicating its name for a local variable or 
   parameter. In these situations, qualifying the member name is the only 
   way to refer to these masked member names.

Example
   Type sometype
      Declare Sub MyCall()
      value As Integer
   End Type

   Dim example As sometype

   '' Set element test to 0
   example.value = 0
   Print example.value

   example.MyCall()

   '' Output should now be 10
   Print example.value

   End 0

   Sub sometype.MyCall()
      This.value = 10
   End Sub

Differences from QB
   * New to FreeBASIC

See also
   * Base
   * Class
   * Type



--------------------------------------------------------- KeyPgThiscall ----
__Thiscall

Specifies the Thiscall calling convention in a member procedure declaration

Syntax
   Type typename
      declare Sub name __Thiscall [Overload] [Alias "alias"] ( parameters )
      declare Function name __Thiscall [Overload] [Alias "alias"] ( 
      parameters ) [ ByRef ] As return_type
   End Type

Description
   In member procedure declarations, __Thiscall specifies that a procedure 
   will use the Thiscall calling convention. In the Thiscall calling 
   convention, the implicit and hidden This parameter is passed in the ECX 
   register.

   The Thiscall calling convention is for 32-bit x86 targets only and is 
   only partially implemented.  It should work when using -gen gcc backend, 
   but as of fbc-1.08.0, it is not implemented for the -gen gas backed.

   It is not needed for normal fbc usage, and would typically only be 
   needed for linking to and using g++/c++ libraries.

Example
   '' __thiscall only makes sense on windows 32-bit
   #if defined(__FB_WIN32__) And Not defined(__FB_64BIT__)
      #define thiscall __Thiscall
   #else
      #define thiscall
   #endif

   Extern "c++"
   Type UDT
      value As Long
      '' fbc doesn't automatically add the __thiscall calling convention
      '' therefore, currently needs to be explicitly given where needed
      Declare Constructor thiscall ()
      Declare Destructor thiscall ()
      Declare Sub someproc thiscall ()
      '' etc
   End Type
   End Extern

Version
   * Since fbc 1.08.0

Differences from QB
   * New to FreeBASIC

See also
   * cdecl, stdcall
   * Declare
   * Sub, Function



------------------------------------------------------- KeyPgThreadCall ----
ThreadCall

Starts a user-defined procedure with parameters in a separate execution 
thread

   Threadcall uses LibFFI internally: people who write programs using this 
   functionality should be careful to follow LibFFI's license, which can be 
   found at http://github.com/atgreen/libffi/blob/master/LICENSE.

Syntax
   Function ThreadCall subname([paramlist]) As Any Ptr

Usage
   threadid = ThreadCall subname([paramlist])

Parameters
   subname
      The name of a subroutine
   paramlist
      A list of parameters to pass to the subroutine, as with a normal sub 
      call.	

Return Value
   Threadcall returns an Any Ptr handle to the thread created, or the null 
   pointer (0) on failure.

Description
   Like ThreadCreate, Threadcall creates a thread which runs at the same 
   time as the code calling it.  By placing "Threadcall" before almost any 
   normal call to sub, the sub is called inside of a new thread and returns 
   a pointer to that thread.

   Using Threadcall is simpler method of creating threads, and allows data 
   to be passed to the thread without global variables or pointers which 
   are not type safe.  However, ThreadCreate is more efficient and should 
   be used for programs creating a large number of threads.

   While most subroutines are supported, the following types of subroutines 
   may not be called:
      * Subroutines using Variable Arguments.
      * Subroutines with unions which are passed as arguments.
      * Subroutines with user types containing unions, arrays, strings, or 
        bitfields which are passed as arguments.

   When using Threadcall, parenthesis around the parameter list are 
   required unless the subroutine has no parameters.

   Warning:
      - Presently when Threadcall involves to pass parameters to the 
      thread, there is no guarantee that the corresponding data are still 
      maintained after the end of the Threadcall statement and this until 
      the thread is launched.
      - That can cause bad behavior:
         - see example below where the not displayed parameter id seems to 
         be the consequence of a prematurely destroyed string argument 
         (visible for a fbc version >= 1.00),
         - replace id As String with id As Zstring in the parameters 
         declaration seems to workaround the problem when passing this 
         parameter.
      - Therefore it is more advisable for the moment to use ThreadCreate 
      (100% safe) instead.	

Example
   '' Threading using "ThreadCall"

   Sub thread( id As String, tlock As Any Ptr, count As Integer )
      For i As Integer = 1 To count
         MutexLock tlock
         Print "thread " & id;
         Locate , 20
         Print i & "/" & count
         MutexUnlock tlock
      Next
   End Sub

   Dim tlock As Any Ptr = MutexCreate()
   Dim a As Any Ptr = ThreadCall thread("A", tlock, 6)
   Dim b As Any Ptr = ThreadCall thread("B", tlock, 4)
   ThreadWait a
   ThreadWait b
   MutexDestroy tlock
   Print "All done (and without Dim Shared!)"

Dialect Differences
   * Threading is not allowed in the -lang qb dialect.

Platform Differences
   * Threadcall is not available with the DOS version / target of 
     FreeBASIC, because multithreading is not supported by DOS kernel nor 
     the used extender.
   * In Linux the threads are always started in the order they are 
     created, this can't be assumed in Win32. It's an OS, not a FreeBASIC 
     issue. 
   * In Linux, the stdcall and pascal calling conventions are not 
     supported
   * In Windows, the pascal calling convention is not supported.

Differences from QB
   * New to FreeBASIC

See also
   * ThreadCreate
   * ThreadWait
   * MutexCreate
   * MutexLock
   * MutexUnlock
   * MutexDestroy



----------------------------------------------------- KeyPgThreadCreate ----
ThreadCreate

Starts a user-defined procedure in a separate execution thread

Syntax
   Declare Function ThreadCreate _
      ( _
         ByVal procptr As Sub ( ByVal userdata As Any Ptr ), _
         ByVal param As Any Ptr = 0, _
         ByVal stack_size As Integer = 0 _
      ) As Any Ptr

Usage
   result = ThreadCreate ( procptr [, [ param ] [, stack_size ] ] )

Parameters
   procptr
      A pointer to the Sub intended to work as a thread (see 
      Operator Procptr (Procedure Pointer) to get a pointer to a sub). The 
      sub must have the following signature (same parameters, same calling 
      convention) to be compatible to procptr:
         Declare Sub myThread ( ByVal userdata As Any Ptr )
   userdata
      The Any Ptr parameter of the Sub intended to work as a thread. 
      FreeBASIC expects this parameter to be present, it must not be 
      omitted! 
   param
      Any Ptr argument that will be passed to the thread Sub pointed to by 
      procptr through its userdata parameter. For example, this can be a 
      pointer to a structure or an array containing various information for 
      the thread sub to work with. If param is not given, 0 (zero) will be 
      passed to the thread sub's userdata parameter instead.
   stack_size
      Optional number of bytes to reserve for this thread's stack.

Return Value
   ThreadCreate returns an Any Ptr handle to the thread created, or a null 
   pointer (0) on failure.

Description
   The sub pointed to by procptr is started as a thread. It will be passed 
   the content of param, or 0 (zero) if not specified, in its userdata 
   parameter.

   The sub that was started as a thread will execute in parallel with the 
   main part of the program. The OS achieves this by assigning it to a 
   different processor if it exists, or by alternating between execution 
   threads on a single processor.
   There is no guarantee about the order in which different threads 
   execute, and no assumptions can be made about the order in which 
   multiple create threads actually start executing.
   In the fastest launch cases, the thread body may start executing even 
   before ThreadCreate returns.

   Each running thread can be identified by its handle which is unique 
   among all running threads. See ThreadSelf.

   Before closing, programs should wait for the termination of all launched 
   threads by using ThreadWait. Alternatively, if it's not necessary to 
   safely wait for a thread to finish execution, ThreadDetach can be used. 
   However, if a program exits while some threads are still active, those 
   threads will be aborted by the system. For every thread created, 
   programs should call either ThreadWait or ThreadDetach to ensure that 
   the system resources associated with the thread handles are released. 
   Otherwise, there may be memory or system resource leaks.

   Due to the nature of threads, no assumptions about execution order can 
   be made. In order to exchange data between multiple threads, including a 
   thread and the main part of the program, mutexes must be used. These 
   mutual exclusion locks can be "owned" by a single thread while doing 
   critical work, causing other threads to wait for their turn. See 
   MutexCreate, MutexLock, MutexUnlock, MutexDestroy.

   stack_size can be used to change the thread's stack size from the 
   system's default. This can be useful when the program requires a big 
   stack, for example due to lots of procedure recursion or when allocating 
   huge strings/arrays on the stack. On some systems (Linux), the stack 
   automatically grows beyond stack_size if more space is needed; on others 
   (Win32), this is the fixed maximum allowed. Behavior is undefined when 
   more stack is used than the reserved size on systems where stacks are 
   not able to grow.

   The intrinsic macro __FB_MT__ is only automatically set from the point 
   of usage of ThreadCreate onward.

   Note:
      - The userdata parameter can be unused in the body of the myThread 
      sub, but declaring it as an Any Ptr parameter is always mandatory in 
      the header. In this case, the corresponding param parameter can then 
      be omitted when calling ThreadCreate, or else a needless argument can 
      still be passed ('0' is commonly used because this value is directly 
      compatible with any pointer). See the 2nd and 3rd example.
      - In the case where data must be passed to myThread, the Any Ptr 
      param can be used to reference them, usually requiring a type 
      conversion (implicit or explicit) into Any Ptr before passing it to 
      ThreadCreate, and a reverse type conversion from Any Ptr in the body 
      of myThread before using it. See the 1st example.

Example
   '' Threading synchronization using Mutexes
   '' If you comment out the lines containing "MutexLock" and "MutexUnlock",
   '' the threads will not be in sync and some of the data may be printed
   '' out of place.

   Const MAX_THREADS = 10

   Dim Shared As Any Ptr ttylock

   '' Teletype unfurls some text across the screen at a given location
   Sub teletype( ByRef text As String, ByVal x As Integer, ByVal y As Integer )
      ''
      '' This MutexLock makes simultaneously running threads wait for each
      '' other, so only one at a time can continue and print output.
      '' Otherwise, their Locates would interfere, since there is only one
      '' cursor.
      ''
      '' It's impossible to predict the order in which threads will arrive
      '' here and which one will be the first to acquire the lock thus
      '' causing the rest to wait.
      ''
      MutexLock ttylock

      For i As Integer = 0 To (Len(text) - 1)
         Locate x, y + i
         Print Chr(text[i])
         Sleep 25, 1
      Next

      '' MutexUnlock releases the lock and lets other threads acquire it.
      MutexUnlock ttylock
   End Sub

   Sub thread( ByVal userdata As Any Ptr )
      Dim As Integer id = CInt(userdata)
      teletype "Thread (" & id & ").........", 1 + id, 1
   End Sub

      '' Create a mutex to syncronize the threads
      ttylock = MutexCreate()

      '' Create child threads
      Dim As Any Ptr handles(0 To MAX_THREADS-1)
      For i As Integer = 0 To MAX_THREADS-1
         handles(i) = ThreadCreate(@thread, CPtr(Any Ptr, i))
         If handles(i) = 0 Then
            Print "Error creating thread:"; i
            Exit For
         End If
      Next

      '' This is the main thread. Now wait until all child threads have finished.
      For i As Integer = 0 To MAX_THREADS-1
         If handles(i) <> 0 Then
            ThreadWait(handles(i))
         End If
      Next

      '' Clean up when finished
      MutexDestroy(ttylock)

   Sub print_dots(ByRef char As String)
      For i As Integer = 0 To 29
         Print char;
         Sleep CInt(Rnd() * 100), 1
      Next
   End Sub

   Sub mythread(param As Any Ptr)
      '' Work (other thread)
      print_dots("*")
   End Sub

      Randomize(Timer())

      Print " main thread: ."
      Print "other thread: *"

      '' Launch another thread
      Dim As Any Ptr thread = ThreadCreate(@mythread, 0)

      '' Work (main thread)
      print_dots(".")

      '' Wait until other thread has finished, if needed
      ThreadWait(thread)
      Print
      Sleep

   '' Threaded consumer/producer example using mutexes

   Dim Shared As Any Ptr produced, consumed 

   Sub consumer( ByVal param As Any Ptr )
      For i As Integer = 0 To 9
         MutexLock produced
         Print ", consumer gets:", i
         Sleep 500, 1
         MutexUnlock consumed
      Next
   End Sub

   Sub producer( ByVal param As Any Ptr )
      For i As Integer = 0 To 9
         Print "Producer puts:", i;
         Sleep 500, 1
         MutexUnlock produced
         MutexLock consumed
      Next i
   End Sub

      Dim As Any Ptr consumer_id, producer_id

      produced = MutexCreate
      consumed = MutexCreate
      If( ( produced = 0 ) Or ( consumed = 0 ) ) Then
         Print "Error creating mutexes! Exiting..."
         End 1
      End If

      MutexLock produced
      MutexLock consumed
      consumer_id = ThreadCreate(@consumer)
      producer_id = ThreadCreate(@producer)
      If( ( producer_id = 0 ) Or ( consumer_id = 0 ) ) Then
         Print "Error creating threads! Exiting..."
         End 1
      End If

      ThreadWait consumer_id
      ThreadWait producer_id

      MutexDestroy consumed
      MutexDestroy produced

      Sleep

Dialect Differences
   * Threading is not allowed in the -lang qb dialect.

Platform Differences
   * Threadcreate is not available with the DOS version / target of 
     FreeBASIC, because multithreading is not supported by DOS kernel nor 
     the used extender.
   * In Linux the threads are always started in the order they are 
     created, this can't be assumed in Win32. It's an OS, not a FreeBASIC 
     issue. 

Differences from QB
   * New to FreeBASIC

See also
   * ThreadSelf
   * ThreadWait
   * ThreadDetach
   * MutexCreate
   * MutexLock
   * MutexUnlock
   * MutexDestroy
   * Operator Procptr (Procedure Pointer)



----------------------------------------------------- KeyPgThreadDetach ----
ThreadDetach

Releases a thread handle without waiting for the thread to finish

Syntax
   Declare Sub ThreadDetach ( ByVal id As Any Ptr )

Usage
   #include "fbthread.bi"
   ThreadDetach( id )

Parameters
   id
      Any Ptr handle of a thread created by ThreadCreate or ThreadCall

Description
   ThreadDetach releases resources associated with the thread handle 
   returned by ThreadCreate or ThreadCall. The thread handle will be 
   destroyed by ThreadDetach and cannot be used anymore.
   Unlike ThreadWait, ThreadDetach does not wait for the thread to finish 
   and thread execution continues independently. Any allocated resources 
   will be freed once the thread exits.

   In order to avoid memory leaks, the safe way to end a thread is to 
   always signal to it that it must end, and then call ThreadWait on that 
   thread except if ThreadDetach has previously been called.

   Note: As ThreadDetach destroys the thread handle, ThreadWait can no 
   longer check for the thread ending, and even the use of ThreadWait 
   becomes unpredictable (may crash the program). The use between ThreadWait
   and ThreadDetach must be exclusive.
   But mutexes and conditional variables can also be used with detached 
   threads.

Example
   #include "fbthread.bi"

   Sub mythread( ByVal param As Any Ptr )
      Print "hi!"
   End Sub

   Dim As Any Ptr thread = ThreadCreate( @mythread )
   ThreadDetach( thread )
   '' or
   ThreadDetach( ThreadCreate( @mythread ) )

   Sleep

Dialect Differences
   * Threading is not allowed in the -lang qb dialect.

Platform Differences
   * ThreadDetach is not available with the DOS version of FreeBASIC, 
     because multithreading is not supported by DOS kernel nor the used 
     extender.

Differences from QB
   * New to FreeBASIC

See also
   * ThreadWait
   * ThreadCreate



------------------------------------------------------- KeyPgThreadSelf ----
ThreadSelf

Return the thread handle of the current thread.

Syntax
   Declare Function ThreadSelf ( ) As Any Ptr

Usage
   #include "fbthread.bi"
   result = ThreadSelf

Return Value
   ThreadSelf returns an Any Ptr handle of the current thread.

Description
   ThreadSelf is used to get the handle of the current thread.

   This function can uniquely identify the existing threads:
      - If there are multiple threads, and one thread is completed, then 
      that handle can be reused.
      - So for all the only threads still running, the handles are unique.

   When a new thread is created, a handle to the thread is returned by the 
   creation function.
   When the thread runs code, ThreadSelf allows to return the handle of the 
   thread (the implicit main thread also has its own unique handle).

   ThreadSelf may be used to code some sort of TLS (Thread Local Storage) 
   from the unique handle of each thread (including the implicit main 
   thread).
   Therefore, a same global variable name may be defined, but with a stored 
   value specific to the thread that accesses it.
   This allows generic procedures to be coded, but with parameters 
   depending on the thread which executes them (see 3rd example below).

Example
   #include "fbthread.bi"

   Dim As Any Ptr phandle(1 To 10)

   Sub myThread (ByVal p As Any Ptr)
      Print "Thread handle: " & ThreadSelf()
   End Sub

   For I As Integer = 1 To 10
      phandle(I) = ThreadCreate(@myThread)
   Next I

   For I As Integer = 1 To 10
      ThreadWait(phandle(I))
   Next I

   Sleep
      

   Checking for equality between the thread handle returned by ThreadCreate 
   at thread creation and the one returned by ThreadSelf from thread 
   running:
   #include "fbthread.bi"

   Dim As Any Ptr phandle(1 To 10)
   Dim Shared As Any Ptr pmutex

   Sub myThread (ByVal p As Any Ptr)
      MutexLock(pmutex)  ' to ensure that ThreadCreate line is completed before accessing the handle value
      Dim As Any Ptr phandle1 = *CPtr(Any Ptr Ptr, p)
      MutexUnlock(pmutex)
      Dim As Any Ptr phandle2 = ThreadSelf()
      Print Left("   ThreadCreate: " & phandle1 & Space(18), 36) _
           & "   ThreadSelf: " & phandle2  ' single print with concatenated string avoids using a mutex
      Sleep 100, 1
   End Sub

   Print "Handles returned from:"
   pmutex = MutexCreate()
   For I As Integer = 1 To 10
      MutexLock(pmutex)  ' to ensure that ThreadCreate line is completed before thread accesses the handle value
      phandle(I) = ThreadCreate(@myThread, @phandle(I))
      MutexUnlock(pmutex)
   Next I

   For I As Integer = 1 To 10
      ThreadWait(phandle(I))
   Next I
   MutexDestroy(pmutex)

   Sleep
      

   Example of a sort of TLS (Thread Local Storage):
   (see the end of the "Description" paragraph)
   #include Once "fbthread.bi"

   Function TLSindex() As Integer  ' returning a unique thread index (incremented with each new thread)
      Static As Any Ptr TLSind()
      Dim As Integer index = -1
      For I As Integer = LBound(TLSind) To UBound(TLSind)
         If TLSind(I) = ThreadSelf() Then
            index = I
            Exit For
         End If
      Next I
      If index = -1 Then
         index = UBound(TLSind) + 1
         ReDim Preserve TLSind(index)
         TLSind(index) = ThreadSelf()
      End If
      Return index
   End Function

   Function TLSinteger() ByRef As Integer  ' emulation of global integer with value depending on thread using it
      Static As Integer TLSint()
      Dim As Integer index = TLSindex()
      If index > UBound(TLSint) Then
         ReDim Preserve TLSint(index)
      End If
      Return TLSint(index)
   End Function

   '------------------------------------------------------------------------------

   Type threadData
      Dim As Any Ptr handle
      Dim As String prefix
      Dim As String suffix
      Dim As Double tempo
   End Type

   Function counter() As Integer  ' definition of a generic counter with counting depending on thread calling it
      TLSinteger() += 1
      Return TLSinteger()
   End Function

   Sub Thread(ByVal p As Any Ptr)
      Dim As threadData Ptr ptd = p
      Dim As UInteger c
      Do
         c = counter()
         Print ptd->prefix & c & ptd->suffix & " ";  ' single print with concatenated string avoids using a mutex
         Sleep ptd->tempo, 1
      Loop Until c = 12
   End Sub

   '------------------------------------------------------------------------------

   Print "|x| : counting from thread a"
   Print "(x) : counting from thread b"
   Print "[x] : counting from thread c"
   Print

   Dim As threadData mtlsa
   mtlsa.prefix = "|"
   mtlsa.suffix = "|"
   mtlsa.tempo = 250
   mtlsa.handle = ThreadCreate(@Thread, @mtlsa)

   Dim As threadData mtlsb
   mtlsb.prefix = "("
   mtlsb.suffix = ")"
   mtlsb.tempo = 150
   mtlsb.handle = ThreadCreate(@Thread, @mtlsb)

   Dim As threadData mtlsc
   mtlsc.prefix = "["
   mtlsc.suffix = "]"
   mtlsc.tempo = 100
   mtlsc.handle = ThreadCreate(@Thread, @mtlsc)

   ThreadWait(mtlsa.handle)
   ThreadWait(mtlsb.handle)
   ThreadWait(mtlsc.handle)

   Print
   Print
   Print "end of threads"

   Sleep   

Version
   * Since fbc 1.08.0

Dialect Differences
   * Threading is not allowed in the -lang qb dialect.

Platform Differences
   * ThreadSelf is not available with the DOS version of FreeBASIC, 
     because multithreading is not supported by DOS kernel nor the used 
     extender.

Differences from QB
   * New to FreeBASIC

See also
   * ThreadCreate



------------------------------------------------------- KeyPgThreadWait ----
ThreadWait

Waits for a thread to finish execution and releases the thread handle

Syntax
   Declare Sub ThreadWait ( ByVal id As Any Ptr )

Usage
   ThreadWait( id )

Parameters
   id
      Any Ptr handle of a thread created by ThreadCreate or ThreadCall

Description
   ThreadWait waits for a thread created by ThreadCreate or ThreadCall to 
   finish execution, and then releases the resources associated with the 
   thread handle. ThreadWait does not return until the thread designated by 
   id ends.
   During the wait, no CPU time is consumed by the caller.

   In order to release a thread handle without waiting for the thread to 
   finish, use ThreadDetach.

   ThreadWait does not force the thread to end; if a thread requires a 
   signal to force its end, a mechanism such as shared variables and 
   mutexes must be used.

   In order to avoid memory leaks, the safe way to end a thread is to 
   always signal to it that it must end, and then call ThreadWait on that 
   thread except if ThreadDetach has previously been called.

   The intrinsic macro __FB_MT__ is only automatically set from the point 
   of usage of ThreadWait onward.

Example
   See the ThreadCreate examples.

Dialect Differences
   * Threading is not allowed in the -lang qb dialect.

Platform Differences
   * ThreadWait is not available with the DOS version of FreeBASIC, 
     because multithreading is not supported by DOS kernel nor the used 
     extender.

Differences from QB
   * New to FreeBASIC

See also
   * ThreadCreate
   * ThreadDetach



------------------------------------------------------------- KeyPgTime ----
Time

Returns the current system time as a string

Syntax
   Declare Function Time ( ) As String

Usage
   result = Time[$]

Return Value
   Returns the current system time.

Description
   Returns the current system time in the format hh:mm:ss.

Example
   Print "the current time is: "; Time

Differences from QB
   * The QB TIME statement (to set the system time) is now called SetTime.
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

See also
   * Date
   * Timer



------------------------------------------------------------ KeyPgTimer ----
Timer

Returns the amount of time that has passed since a static reference point.

Syntax
   Declare Function Timer ( ) As Double

Usage
   result = Timer

Return Value
   Returns a Double precision result with the time, in seconds, since a 
   static reference point.

Description
   The Timer function is useful for finding out how long a section of code 
   takes to run, or for control the timing of your code.  To find out how 
   much time has passed between two points in your program, you can record 
   the value of Timer at the start and end points, and then subtract the 
   start value from the end value.

   On some platforms, the value of Timer resets to zero at midnight (see 
   below), so if the start and end time are on either side of the reset 
   point, the difference will be negative.  This could cause unexpected 
   behavior in some programs.  In those cases, adding 86400 (the number of 
   seconds in 24 hours) to the difference should return the correct result. 
   If the time taken is longer than a day, then it will be also be 
   necessary to check the number of days that have elapsed.

   The value returned by Timer is NOT affected by the automatic changing of 
   the system clock, in Spring and Autumn, for DST (Daylight Savings Time).

Example
   '' Example of using TIMER function 
   '' Note: see text about correct waiting strategies
   Dim Start As Double
   Print "Wait 2.5 seconds."
   Start = Timer
   Do
      Sleep 1, 1
   Loop Until (Timer - Start) > 2.5
   Print "Done."

Platform Differences
   * On Win32 and Linux, if the program must wait for periods of 0.1 
     seconds or more, Sleep should be used, this allows other programs to 
     run during the waiting period. For shorter delays, a loop using TIMER 
     can be more precise.
   * The reference point chosen varies, depending on the platform.  On 
     Windows, the time is measured relative to the point the computer was 
     booted up.  On DOS, the time is measured relative to Jan 1 1970.

   Note for DOS users: today, the number of seconds since 1970 is in excess 
   of 10^9, and is therefore unsuitable for storing in Single-precision 
   variables, also it shouldn't be multiplied (to get 1/10 seconds or so) 
   and stored in 32-bit integer variables then

   * The precision of TIMER varies, depending on the computer used.  If 
     the processor has a precision timer (as the Performance Counter 
     Pentium processors from Intel have) and the OS uses it, the precision 
     is linked to the processor clock and microseconds can be expected. 
     With older processors (386, 486), and always in DOS, the resolution is 
     1/18 second.

   * Usage of TIMER can cause disk accesses in DOS, see forum for analysis 
     and solutions

Differences from QB
   * In QB, TIMER returned the number of seconds from last midnight, and 
     its accuracy was 1/18 secs

See also
   * Time
   * Sleep



------------------------------------------------------- KeyPgTimeserial ----
TimeSerial

Gets a Date Serial for the specified hours, minutes, and seconds

Syntax
   Declare Function TimeSerial ( ByVal hour As Long, ByVal minute As Long, 
   ByVal second As Long ) As Double

Usage
   #include "vbcompat.bi"
   result = TimeSerial( hours, minutes, seconds )

Parameters
   hour
      number of hours, in the range 0-23
   minute
      number of minutes
   second
      number of seconds

Return Value
   Returns a date serial containing the time formed by the values in the 
   hours, minutes and seconds parameters.The date serial returned has no 
   integer part.

Description
   hours must be specified in the range 0-23

   The compiler will not recognize this function unless vbcompat.bi or 
   datetime.bi is included.

Example
   #include "vbcompat.bi"

   Dim ds As Double = DateSerial(2005, 11, 28) + TimeSerial(7, 30, 50)

   Print Format(ds, "yyyy/mm/dd hh:mm:ss")

Differences from QB
   * Did not exist in QB. This function appeared in PDS and VBDOS

See also
   * Date Serials
   * DateSerial
   * TimeValue
   * DateValue



-------------------------------------------------------- KeyPgTimeValue ----
TimeValue

Gets a Date Serial from a time string

Syntax
   Declare Function TimeValue ( ByRef timestring As String ) As Double

Usage
   #include "vbcompat.bi"
   result = TimeValue( timestring )

Parameters
   timestring
      the string to convert

Return Value
   Returns a Date Serial from a time string.

Description
   The time string must be in the format "23:59:59" or  "11:59:59PM"

   The compiler will not recognize this function unless vbcompat.bi or 
   datetime.bi is included.

Example
   #include "vbcompat.bi"

   Dim ds As Double = TimeValue("07:12:28AM")

   Print Format(ds, "hh:mm:ss")

Differences from QB
   * Did not exist in QB. This function appeared in PDS and VBDOS

See also
   * Date Serials
   * DateSerial
   * TimeValue
   * DateValue



--------------------------------------------------------------- KeyPgTo ----
To

Statement modifier to specify a range.

Syntax
   For iterator intial_value To ending_value
      statement(s).
   Next [ iterator ]
or
   Select Case case_comparison_value
   Case lower_bound To upper_bound
      statement(s).
   End Select
or
   Dim variable_identifier( lower_bound To upper_bound ) As type_specifier

Description
   The To keyword is used to define a certain numerical range. This keyword 
   is valid only if used with For ... Next, Case and Dim statements.

   In the first syntax, the To keyword defines the initial and ending 
   values of the iterator in a For statement.

   In the second syntax, the To keyword defines lower and upper bounds for 
   Case comparisons.

   In the third syntax, the To keyword defines the array bounds in a Dim 
   statement

   For more information, see For...Next, Dim and Select Case.

Example
   '' this program uses bound variables along with the TO keyword to create an array, store random
   '' temperatures inside the array, and to determine output based upon the value of the temperatures
   Randomize Timer

   '' define minimum and maximum number of temperatures we will create
   Const minimum_temp_count As Integer = 1
   Const maximum_temp_count As Integer = 10

   '' define the range of temperatures zones in which bacteria breed rapidly (in degrees)
   Const min_low_danger As Integer = 40
   Const max_low_danger As Integer = 69
   Const min_medium_danger As Integer = 70
   Const max_medium_danger As Integer = 99
   Const min_high_danger As Integer = 100
   Const max_high_danger As Integer = 130

   '' define array to hold temperatures using our min/max temp count bounds
   Dim As Integer array( minimum_temp_count To maximum_temp_count )

   '' declare a for loop that iterates from minimum to maximum temp count
   Dim As Integer it
   For it = minimum_temp_count To maximum_temp_count

      array( it ) = Int( Rnd( 1 ) * 200 ) + 1

      '' display a message based on temperature using our min/max danger zone bounds
      Select Case array( it )
        Case min_low_danger To max_low_danger
          Color 11
          Print "Temperature" ; it ; " is in the low danger zone at" ; array( it ) ; " degrees!"
        Case min_medium_danger To max_medium_danger
          Color 14
          Print "Temperature" ; it ; " is in the medium danger zone at" ; array( it ) ; " degrees!"
        Case min_high_danger To max_high_danger
          Color 12
          Print "Temperature" ; it ; " is in the high danger zone at" ; array( it ) ; " degrees!"
        Case Else
          Color 3
          Print "Temperature" ; it ; " is safe at" ; array( it ) ; " degrees."
      End Select

   Next it

   Sleep

Differences from QB
   * none

See also
   * For...Next
   * Dim
   * Select Case



--------------------------------------------------------- KeyPgTransGfx ----
Trans

Parameter to the Put graphics statement which selects transparent 
background as the blitting method

Syntax
   Put [ target, ] [ STEP ] ( x,y ), source [ ,( x1,y1 )-( x2,y2 ) ], Trans

Parameters
   Trans
      Required.

Description
   Trans selects transparent background as the method for blitting an image 
   buffer.  This is similar to the PSET method, but pixels containing the 
   mask color are skipped.
   For 8-bit color images, the mask color is palette index 0.  For 
   16/32-bit color images, the mask color is Magenta, which is RGB(255, 0, 
   255).  The alpha value is ignored when checking for the mask color in 
   32-bit images.

   Note: for 32-bit images, the alpha value of pixels may be changed to 0.  
   This is for efficiency reasons.  To preserve the alpha values, a custom 
   blender may be used, as in the second example below.

Example
   '' set up a screen: 320 * 200, 16 bits per pixel
   ScreenRes 320, 200, 16

   '' set up an image with the mask color as the background.
   Dim img As Any Ptr = ImageCreate( 32, 32, RGB(255, 0, 255) )
   Circle img, (16, 16), 15, RGB(255, 255, 0),     ,     , 1, f
   Circle img, (10, 10), 3,  RGB(  0,   0, 0),     ,     , 2, f
   Circle img, (23, 10), 3,  RGB(  0,   0, 0),     ,     , 2, f
   Circle img, (16, 18), 10, RGB(  0,   0, 0), 3.14, 6.28

   '' Put the image with PSET (gives the exact contents of the image buffer)
   Draw String (110, 50 - 4), "Image put with PSET"
   Put (60 - 16, 50 - 16), img, PSet

   '' Put the image with TRANS
   Draw String (110, 150 - 4), "Image put with TRANS"
   Put (60 - 16, 150 - 16), img, Trans

   '' free the image memory
   ImageDestroy img

   '' wait for a keypress
   Sleep

   Function trans32 ( ByVal source_pixel As ULong, ByVal destination_pixel As ULong, ByVal parameter As Any Ptr ) As ULong
      '' returns the source pixel
      '' unless it is &hff00ff (magenta), then return the destination pixel
      If (source_pixel And &hffffff) <> &hff00ff Then
         Return source_pixel
      Else
         Return destination_pixel
      End If
   End Function

   '' set up a screen: 320 * 200, 16 bits per pixel
   ScreenRes 320, 200, 32

   '' set up an image with the mask color as the background.
   Dim img As Any Ptr = ImageCreate( 32, 32, RGB(255, 0, 255) )
   Circle img, (16, 16), 15, RGB(255, 255, 0),     ,     , 1, f
   Circle img, (10, 10), 3,  RGB(  0,   0, 0),     ,     , 2, f
   Circle img, (23, 10), 3,  RGB(  0,   0, 0),     ,     , 2, f
   Circle img, (16, 18), 10, RGB(  0,   0, 0), 3.14, 6.28

   '' Put the image with PSET (gives the exact contents of the image buffer)
   Draw String (110, 50 - 4), "Image put with PSET"
   Put (60 - 16, 50 - 16), img, PSet

   '' Put the image with TRANS
   Draw String (110, 100 - 4), "Image put with TRANS"
   Put (60 - 16, 100 - 16), img, Trans

   '' Put the image with TRANS
   Draw String (110, 150 - 4), "Image put with trans32"
   Put (60 - 16, 150 - 16), img, Custom, @trans32

   '' free the image memory
   ImageDestroy img

   '' wait for a keypress
   Sleep

Differences from QB
   * New to FreeBASIC

See also
   * Put (Graphics)
   * Custom



------------------------------------------------------------- KeyPgTrim ----
Trim

Removes surrounding substrings or characters on the left and right side of 
a string

Syntax
   Declare Function Trim ( ByRef str As Const String, [ Any ] ByRef trimset 
   As Const String = " " ) As String
   Declare Function Trim ( ByRef str As Const WString, [ Any ] ByRef 
   trimset As Const WString = WStr(" ") ) As WString

Usage
   result = Trim[$]( str [, [ Any ] trimset ] )

Parameters
   str
      The source string.
   trimset
      The substring to trim.

Return Value
   Returns the trimmed string.

Description
   This procedure trims surrounding characters from the left (beginning) 
   and right (end) of a source string. Substrings matching trimset will be 
   trimmed if specified, otherwise spaces (ASCII code 32) are trimmed.

   If the Any keyword is used, any character matching a character in 
   trimset will be trimmed.

   All comparisons are case-sensitive.

Example
   Dim s1 As String = " ... Stuck in the middle ... "
   Print "'" + Trim(s1) + "'"
   Print "'" + Trim(s1, Any " .") + "'"

   Dim s2 As String = "BaaBaaaaB With You aaBBaaBaa"
   Print "'" + Trim(s2, "Baa") + "'"
   Print "'" + Trim(s2, Any "Ba") + "'"

   will produce the output:


   '... Stuck in the middle ...'
   'Stuck in the middle'
   'aaB With You aaB'
   ' With You '		

Platform Differences
   * DOS version/target of FreeBASIC does not support the wide-character 
     version of Trim.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Trim.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * New to FreeBASIC

See also
   * LTrim 
   * RTrim



------------------------------------------------------------- KeyPgTrue ----
True

Intrinsic constant set by the compiler

Syntax
   Const True As Boolean

Description
   Gives the True Boolean value where used.

Example
   Dim b As Boolean = True
   If b Then
      Print "b is True"
   Else
      Print "b is False"
   End If


   b Is True

Version
   * Since fbc 1.04.0

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __True.

Differences from QB
   * New to FreeBASIC

See also
   * False
   * Boolean



-------------------------------------------------------- KeyPgTypeAlias ----
Type (Alias)

Declares an alternative name for a type

Syntax
   Type typename As symbol

Parameters
   typename 
      new alternative name.
   symbol 
      symbol or data type declaration to associate with typename. 

Description
   symbol may refer to any declared data type including a built-in data 
   type, Sub or Function pointer, Type declaration, Union declaration, or 
   Enum declaration.

   A type alias can be used to allow forward declarations of parameters in 
   procedure declarations, but only used with pointers (whatever their 
   passing mode), or otherwise with parameters (excluding arrays) but 
   passed or returned only by reference. Generally the bodies of such 
   procedures need to be implemented further in the code once the actual 
   types are well defined (for example because of the passing of such a 
   reference; or when such a pointer passed is then dereferenced in any 
   form).
   A type alias can also be used to allow forward declarations of data 
   fields in User Defined Types, but only used with pointers.

   A type alias must be used to allow declaration of pointer to a function 
   pointer, otherwise  ptr applies on return type and not on function.

Example
   Type ParentFwd As Parent
   Type Child
      Name As ZString * 32
      ParentRef As ParentFwd Ptr
      ''...
   End Type

   Type Parent
      Name As ZString * 32
      ChildList(0 To 9) As Child
      ''...
   End Type

   Dim p As Parent
   p.Name = "Foo"
   With p.ChildList(0)
      .Name = "Jr."
      .ParentRef = @p
      '' ...
   End With   

   With p.ChildList(0)
      Print .Name; " is child of "; .parentRef->Name
   End With

   Function triple (ByVal i As Integer) As Integer
      Return 3 * i
   End Function

   Type As Function (ByVal As Integer) As Integer function_alias

   'Dim As Function (Byval As Integer) As Integer f  ''this syntax works but is less readable than the next code line
   Dim As function_alias f
   f = @triple
   Print f(123)

   'Dim As Function (Byval As Integer) As Integer Ptr pf  ''this syntax does not work because Ptr applies on Integer and not on function
   Dim As function_alias Ptr pf                           ''this syntax works
   pf = @f
   Print (*pf)(123)  ''the dereferenced pointer to procedure pointer must be enclosed in parentheses

Differences from QB
   * New to FreeBASIC

See also
   * Type...End Type
   * Type (Temporary)



--------------------------------------------------------- KeyPgTypeTemp ----
Temporary Types

Creates a temporary copy of a user defined type

Syntax
   result = Type( initializers, ... )
      or
   result = Type<typename>( initializers, ... )

Parameters
   initializers
      Initial values for the type (or only the firsts)
   typename
      The name of the Type or Union

Return Value
   A temporary copy of the type.

Description
   Used to create a temporary type.  If typename is not explicitly given, 
   it will be inferred from its usage if possible.  Usage of the temporary 
   copy may include assigning it to a variable, passing it as a parameter 
   to a procedure, or returning it as a value from a procedure.

   For a type without own or inherited constructor (excluding also any type 
   that is directly or indirectly derived from Object), the temporary type 
   syntax is allowed if all type data-fields (including those inherited) 
   are numeric primitives only and without any default initializers.
   If at same time the type is without destructor, the compiler does a 
   direct assignment instead of using a temporary copy.

   The Constructor for the type, if there is one with parameters matching 
   with the initializers provided, will be called when the temporary copy 
   is created, and the Destructor for the type, if there is one, will be 
   called immediately after its use. But when there is a matching 
   constructor, the temporary type expression may be simply replaced by 
   typename( initializers, ... ).
   If there is a constructor at least but none which matches with the 
   initializers, the temporary type syntax is obviously disallowed.

   It can create not only a temporary copy of an user defined type, but 
   also a temporary copy of predefined data-type as a variable-length 
   string or any numeric data-type (all standard data-types excluding 
   fixed-length strings).

   It can also be used as an even shorter shortcut than With (see below) if 
   you are changing all the data-fields (or the n firsts only).

   A temporary object is destroyed at the end of execution of the statement 
   (where it's defined), but its corresponding allocated memory is not 
   released and remains available (unused) until going out the scope where 
   statement is.

   Note: Static qualifier used at procedure definition level does not apply 
   to temporary types.

Example
   Type Example
      As Integer field1
      As Integer field2
   End Type

   Dim ex As Example

   '' Filling the type by setting each field
   ex.field1 = 1
   ex.field2 = 2

   '' Filling the type by setting each field using WITH
   With ex
      .field1 = 1
      .field2 = 2
   End With

   '' Fill the variable's fields with a  temporary type
   ex = Type( 1, 2 )

   '' Passing a user-defined types to a procedure using a temporary type
   '' where the type can be inferred.

   Type S
     As Single x, y
   End Type

   Sub test ( v As S )
     Print "S", v.x, v.y
   End Sub

   test( Type( 1, 2 ) )

   '' Passing a user-defined type to a procedure using temporary types
   '' where the type is ambiguous and the name of the type must be specified.

   Type S
     As Single x, y
   End Type

   Type T
     As Integer x, y
   End Type

   Union U
     As Integer x, y
   End Union

   '' Overloaded procedure test()
   Sub test Overload ( v As S )
     Print "S", v.x, v.y
   End Sub

   Sub test ( v As T )
     Print "T", v.x, v.y
   End Sub

   Sub test ( v As U )
     Print "U", v.x, v.y
   End Sub

   '' Won't work: ambiguous
   '' test( type( 1, 2 ) )

   '' Specify name of type instead
   test( Type<S>( 1, 2 ) )
   test( Type<T>( 1, 2 ) )
   test( Type<U>( 1 ) )

Differences from QB
   * New to FreeBASIC

See also
   * Type...End Type
   * Type (Alias)



------------------------------------------------------------- KeyPgType ----
Type

Declares a user-defined type.

Syntax
   Type typename
      fieldname1 As DataType
      fieldname2 As DataType
      As DataType fieldname3, fieldname4
      ...
   End Type

   Type typename [Alias "alternatename"] [Extends base_typename] [Field = 
   alignment]
      [Private:|Public:|Protected:]

      Declare Sub|Function|Constructor|Destructor|Property|Operator ...
      Static variablename As DataType
      ReDim arrayname(array dimensions) As DataType

      fieldname As DataType [= initializer]
      fieldname(array dimensions) As DataType [= initializer]
      fieldname(Any [, Any...]) As DataType
      fieldname : bits As DataType [= initializer]

      As DataType fieldname [= initializer], ...
      As DataType fieldname(array dimensions) [= initializer], ...
      As DataType fieldname(Any [, Any...])
      As DataType fieldname : bits [= initializer], ...

      Union
         fieldname As DataType
         Type
            fieldname As DataType
            ...
         End Type
         ...
      End Union

      ...
   End Type

Description
   Type is used to declare custom data types containing one or more data 
   fields, including integer types, floating point types, fixed-size or 
   variable-length (dynamic) arrays, fixed-size or variable-length strings, 
   bitfields, or other user-defined types.

   Types support various functionality related to object-oriented 
   programming:
      * Inheritance through the use of the Extends keyword.
      * Member procedures such as Subs or Functions, including Abstract or 
        Virtual ones.
      * Member procedures with special semantic meaning such as 
        Constructors or a Destructor.
      * Static member variables.
      * Member visibility specifiers: Public:, Private:, Protected:.

   A Type can also contain nested types or unions, allowing data members to 
   be grouped as desired.
   Type and Union can be directly nested on condition of alternating their 
   nesting.
   Only the main structure (Type or Union) can be named, the others 
   (nested) must be unnamed.
   Nested unnamed Type or Union can not have procedure members or static 
   data members (same restriction for local scope named Type/Union).

   Alias "alternatename" specifies that if typename must be encoded 
   (mangled) in to a public symbol (as in an object module or library), 
   then specifically use alternate name instead of the usual encoding 
   (mangling) of typename.

   Memory layout
   Types lay out their fields consecutively in memory, following the native 
   alignment and padding rules (described on the Field page). Special care 
   must be taken when using Types for file I/O or interacting with other 
   programs or programming languages, in case the alignment and padding 
   rules are different. The optional Field = number specifier can be used 
   to change the behavior on the FreeBASIC side.

   Variable-length data
   In FreeBASIC, Type data structures must ultimately be fixed-size, such 
   that the compiler knows how much memory to allocate for objects of that 
   Type. Nevertheless, Types may contain variable-length (dynamic) string 
   or array data members. However, the string's/array's data will not be 
   embedded in the Type directly. Instead, the Type will only contain a 
   String/array descriptor structure, which FreeBASIC uses behind the 
   scenes to manage the variable-length string/array data. For sizing the 
   structure of the array descriptor in the Type, a variable-length 
   (dynamic) array data member must be always declared by using Any(S) in 
   place of the array bounds, in order to fix the amount of dimensions 
   based on the number of Anys specified. A variable-length (dynamic) array 
   data member can also be pre-sized in its declaration by using syntax 
   with ReDim.
   Variable-length array fields are considered as pseudo-objects when they 
   are declared in a Type, just like variable-length strings (the implicit 
   copy constructor and the implicit let operator themselves support 
   [re]sizing and copying such arrays, or their erasing).

   Because of that, saving such a Type into a file will write out the 
   descriptor, not the actual string/array data. In order to embed 
   strings/arrays into Types directly, fixed-length strings/arrays must be 
   used.

   Similarly, when maintaining dynamic data manually through the use of 
   pointers within a Type, it does usually not make sense to save the Type 
   to a file, because the address stored in the pointer field will be 
   written to file, not the actual memory it points to. Addresses are 
   meaningful to a specific process only though, and cannot be shared that 
   way.

   Special note on fixed-length strings
   Currently, fixed-length string fields of String * N type have an extra 
   null terminator at their end, for compatibility with C strings, making 
   them incompatible with QB strings inside Types, because they actually 
   use up N+1 bytes, instead of just N bytes. A possible work-around is to 
   declare the field As String * (N-1), though this will not work in future 
   releases if the null terminator is removed.  Another alternative is to 
   use a Byte or UByte array with the proper size.

   Note on bitfields ( fieldname : bits )
   Bitfields can only be declared inside a type or a union, and allow to 
   specify some very small objects of a given number of bits in length. 
   Each field is accessed and manipulated as if it were an ordinary member 
   of the structure.
   Only integer data-types (up to 32-bit for 32-bit development or 64-bit 
   for 64-bit development) are valid. The sizes of the declared data-types, 
   large enough to contain the bit patterns, affect how the bitfields are 
   placed in memory.
   Bitfield members in a type are packed together, unless the next member 
   is a non-bitfield (nested union is considered a non-bitfield).
   A bitfield does not have any address (one cannot get a pointer to it and 
   its offset inside the structure).

Example
   This is an example of a QB-style type, not including procedure 
   definitions
   Type clr
      red As UByte
      green As UByte
      blue As UByte
   End Type

   Dim c As clr
   c.red = 255
   c.green = 128
   c.blue = 64

   And this is an example of a type working as an object:
   '' Example showing the problems with fixed length string fields in UDTs
   '' Suppose we have read a GIF header from a file
   ''                        signature         width        height
   Dim As ZString*(10+1) z => "GIF89a" + MKShort(10) + MKShort(11)

   Print "Using fixed-length string"

   Type hdr1 Field = 1
      As String*(6-1) sig /' We have to dimension the string with 1 char
   						'  less to avoid misalignments '/
      As UShort wid, hei
   End Type

   Dim As hdr1 Ptr h1 = CPtr(hdr1 Ptr, @z)
   Print h1->sig, h1->wid, h1->hei '' Prints GIF89 (misses a char!)  10  11

   '' We can do comparisons only with the 5 visible chars and creating a temporary string with LEFT

   If Left(h1->sig, 5) = "GIF89" Then Print "ok" Else Print "error"

   '' Using a ubyte array, we need an auxiliary function to convert it to a string
   Function ub2str( ub() As UByte ) As String
      Dim As String res = Space(UBound(ub) - LBound(ub) + 1)
      For i As Integer = LBound(ub) To UBound(ub)
         res[i - LBound(ub)] = ub(i)
      Next
      Function = res
   End Function

   Print
   Print "Using an array of ubytes"

   Type hdr2 Field = 1
      sig(0 To 6-1) As UByte '' Dimension 6
      As UShort wid, hei
   End Type

   Dim As hdr2 Ptr h2 = CPtr(hdr2 Ptr, @z)
   '' Viewing and comparing is correct but a conversion to string is required

   Print ub2str(h2->sig()), h2->wid, h2->hei '' Prints GIF89a  10  11 (ok)
   If ub2str(h2->sig()) = "GIF89a" Then Print "ok" Else Print "error" '' Prints ok

   This is an example of conversion from an Ubyte to a digit string in base 
   8 (octal string), by using bitfields in a local UDT (conversion 
   equivalent to 'Oct(x, 3)'):
   Function UbyteToOctalString (ByVal b As UByte) As String
    
      Union UbyteOctal
         number As UByte
         Type
            d0 : 3 As UByte
            d1 : 3 As UByte
            d2 : 2 As UByte
         End Type
      End Union
    
      Dim uo As UbyteOctal
      uo.number = b
      Return uo.d2 & uo.d1 & uo.d0
    
   End Function

   For I As Integer = 0 To 255
      Print Using "###: "; I;
   ''    Print Oct(I, 3),
      Print UbyteToOctalString(I),  '' this line is thus equivalent to the previous one
   Next I
   Print

   Sleep

Platform Differences
   * The default Field alignment parameter is 4 bytes for DOS and Linux 
     targets.
   * The default Field alignment parameter is 8 bytes for Windows targets 
     (this difference with regard to 4 bytes applies only to Longint and 
     Double members).

Dialect Differences
   * Object-related features such as functions declared inside Type blocks 
     are supported only with the -lang fb dialect since version 0.17b
   * In the -lang fb and -lang fblite dialects, the default Field 
     alignment parameter depends on the target platform.
   * With the -lang qb dialect the fields are aligned to byte boundaries 
     by default, unless otherwise specified.
   * To force byte alignment use FIELD=1.

Differences from QB
   * At present, fixed-length strings have an extra, redundant character 
     on the end, which means they take up one more byte than they do in QB. 
     For this reason, UDTs that use them are not compatible with QB when 
     used for file I/O.

See also
   * Type (Alias)
   * Type (Temporary)
   * Union
   * Enum
   * TypeOf
   * OffsetOf
   * Alias (Name)
   * Field
   * Extends
   * Extends Zstring
   * Extends Wstring
   * With
   * Coercion and Conversion



----------------------------------------------------------- KeyPgTypeof ----
TypeOf

Returns the type of a variable.

Syntax
   TypeOf ( variable | datatype )

Parameters
   variable
      A variable of any type.
   datatype
      A DataType.

Description
   TypeOf is a compiler intrinsic that replaces itself with the type of the 
   variable passed to it. It can either be used in a variable declaration 
   (Example 1) or it can be used in the preprocessor for comparison, 
   printing. (Example 2)

   TypeOf also supports passing any intrinsic data type, or user-defined 
   type (and its data fields), not only variables defined as those types. 
   Also supported are expressions, the type is inferred from the expression 
   (much like Var).

   If there is both a user defined type and a variable visible with the 
   same name in the current scope, the user defined type takes precedence 
   over the variable.  To ensure that the TypeOf takes the variable instead 
   of the user defined type, wrap the argument to TypeOf with parentheses 
   to force it to be seen as an expression.  For example Typeof((variable))
   .

Example
   Example 1:
   Dim As Integer foo
   Dim As TypeOf(67.2) bar '' '67.2' is a literal double
   Dim As TypeOf( foo + bar ) teh_double '' double + integer results in double
   Print SizeOf(teh_double)
         

   Example 2:
   Dim As String foo
   #print TypeOf(foo)
   #if TypeOf(foo) = TypeOf(Integer)
     #print "Never happened!"
   #endif

   #if TypeOf(foo) = TypeOf(String)
     #print "It's a String!"
   #endif
         

Version
   * Before fbc 1.08.0:
         TypeOf was not returning the type of the data fields of a UDT.
         When a variable from a given namespace was accessed with the 
         namespace's name prefix, the argument to TypeOf had to be wrapped 
         with parentheses to force it to be seen as an expression. For 
         example Typeof((namespace_name.variable)).

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Typeof.

Differences from QB
   * New to FreeBASIC

See also
   * SizeOf
   * Var
   * Type (Alias)
   * Type...End Type




============================================================================
    U

----------------------------------------------------------- KeyPgUbound ----
UBound

Returns the upper bound of an array's dimension

Syntax
   Declare Function UBound ( array() As Any, ByVal dimension As Integer = 1 
   ) As Integer

Usage
   result = UBound( array [, dimension ] )

Parameters
   array
      an array of any type
   dimension
      the dimension to get upper bound of

Return Value
   Returns the upper bound of an array's dimension.
 
Description
   UBound returns the largest value that can be used as an index into a 
   particular dimension of an array.

   Array dimensions are numbered from one (1) to n, where n is the total 
   number of dimensions. If dimension is not specified, UBound will return 
   the upper bound of the first dimension.

   If dimension is zero (0), UBound returns n, the number of dimensions in 
   the array. For any other dimension values outside of the valid range 1..
   n, the result is -1. This can be used to detect the number of dimensions 
   of variable-length arrays, and in combination with the result of 
   Lbound() for such cases, whether a given dimension exists, or whether 
   the array is empty (zero dimensions). See the LBound page for more 
   information.

Example

   Dim array(-10 To 10, 5 To 15, 1 To 2) As Integer

   Print UBound(array) 'returns 10
   Print UBound(array, 2) 'returns 15
   Print UBound(array, 3) 'returns 2

   '' determining the size of an array
   Dim As Short array(0 To 9)
   Dim As Integer arraylen, arraysize

   arraylen = UBound(array) - LBound(array) + 1
   arraysize = arraylen * SizeOf( Short )

   Print "Number of elements in array:", arraylen    '10
   Print "Number of bytes used in array:", arraysize '10 * 2 = 20 

   '' determining the size of a multi-dimensional array
   Dim As Long array4D(1 To 2, 1 To 3, 1 To 4, 1 To 5)
   Dim As Integer arraylen, arraysize

   arraylen = (UBound(array4D, 4) - LBound(array4D, 4) + 1) _
          * (UBound(array4D, 3) - LBound(array4D, 3) + 1) _
          * (UBound(array4D, 2) - LBound(array4D, 2) + 1) _
          * (UBound(array4D, 1) - LBound(array4D, 1) + 1)

   arraysize = arraylen * SizeOf( Long )

   Print "Number of elements in array:", arraylen    '2 * 3 * 4 * 5 = 120
   Print "Number of bytes used in array:", arraysize '120 * 4 = 480

   '' determining whether an array is empty
   Dim array() As Integer

   Print "lbound: "; LBound( array ), "ubound: "; UBound( array )  ''  0 and -1

   If LBound( array ) > UBound( array ) Then
      Print "array is empty"
   Else
      Print "array is not empty"
   End If

   Sub printArrayDimensions( array() As Integer )
      Print "dimensions: " & UBound( array, 0 )

      '' For each dimension...
      For d As Integer = LBound( array, 0 ) To UBound( array, 0 )
         Print "dimension " & d & ": " & LBound( array, d ) & " to " & UBound( array, d )
      Next
   End Sub

   Dim array() As Integer
   printArrayDimensions( array() )

   Print "---"

   ReDim array(10 To 11, 20 To 22)
   printArrayDimensions( array() )

See also
   * LBound
   * Static
   * Dim
   * ReDim
   * SizeOf



------------------------------------------------------------ KeyPgUbyte ----
UByte

Standard data type: 8 bit unsigned.
Equivalent to Unsigned Byte.

Syntax
   Dim variable As UByte

Description
   8-bit unsigned whole-number data type. Can hold a value in the range of 
   0 to 255.

Example
   Dim ubytevar As UByte
   ubytevar = 200
   Print "ubytevar= ", ubytevar

Example
     Dim x As UByte = 0
     Dim y As UByte = &HFF
     Print "UByte Range = "; x; " to "; y

   Output:
   UByte Range = 0 To 255

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Ubyte.

Differences from QB
   * New to FreeBASIC

See also
   * Byte
   * CUByte
   * Table with variable types overview, limits and suffixes



------------------------------------------------------------ KeyPgUcase ----
UCase

Returns an upper case copy of a string

Syntax
   Declare Function UCase ( ByRef str As Const String, ByVal mode As Long = 
   0 ) As String
   Declare Function UCase ( ByRef str As Const WString, ByVal mode As Long 
   = 0 ) As WString

Usage
   result = UCase[$]( str [ , mode ] )

Parameters
   str
      String to convert to uppercase.
   mode
      The conversion mode: 0 = current locale, 1 = ASCII only

Return Value
   Uppercase copy of str.

Description
   Returns a copy of str with all of the letters converted to upper case.

   If str is empty, the null string ("") is returned.

Example
   Print UCase("AbCdEfG")

   will produce the output:

   ABCDEFG

Platform Differences
   * The wide-character string version of UCase is not supported for DOS 
     target.

Dialect Differences
   * The string type suffix "$" is required in the -lang qb dialect.
   * The string type suffix "$" is optional in the -lang fblite dialect.
   * The string type suffix "$" is ignored in the -lang fb dialect, warn 
     only with the -w suffix compile option (or -w pedantic compile 
     option).

Differences from QB
   * QB does not support Unicode.

See also
   * LCase



--------------------------------------------------------- KeyPgUinteger ----
UInteger

Standard data type: 32-bit or 64-bit unsigned, same size as SizeOf(Any Ptr).
Equivalent to Unsigned Integer.

Syntax
   Dim variable As UInteger
   Dim variable As UInteger<bits>

Parameters
   bits
      A numeric constant expression indicating the size in bits of unsigned 
      integer desired.  The values allowed are 8, 16, 32 or 64.

Description
   32-bit or 64-bit unsigned whole-number data type, depending on the 
   platform.

   If an explicit bit size is given, a data type is provided that can hold 
   values from 0 up to (1ULL Shl (bits)) - 1. The selected data type is 
   UByte for UInteger<8>, UShort for UInteger<16>, ULong for UInteger<32> 
   and ULongInt for UInteger<64>.

Example
   #ifdef __FB_64BIT__
      Dim x As UInteger = 0
      Dim y As UInteger = &HFFFFFFFFFFFFFFFF
      Print "UInteger Range = "; x; " to "; y
   #else
      Dim x As UInteger = 0
      Dim y As UInteger = &HFFFFFFFF
      Print "UInteger Range = "; x; " to "; y
   #endif

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Uinteger.

Differences from QB
   * New to FreeBASIC

See also
   * Integer
   * Unsigned
   * CUInt
   * Table with variable types overview, limits and suffixes



------------------------------------------------------------ KeyPgUlong ----
ULong

Standard data type: 32-bit unsigned integer.
Equivalent to Unsigned Long.

Syntax
   Dim variable As ULong

Description
   32-bit unsigned whole-number data type. Can hold values from 0 to 
   4294967295. Corresponds to an unsigned DWORD.

Example
     Dim x As ULong = 0
     Dim y As ULong = &HFFFFFFFF
     Print "ULong Range = "; x; " to "; y

   Output:
   ULong Range = 0 To 4294967295

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Ulong.

Differences from QB
   * New to FreeBASIC

See also
   * Long
   * UInteger
   * ULongInt
   * Table with variable types overview, limits and suffixes



--------------------------------------------------------- KeyPgUlongint ----
ULongInt

Standard data type: 64 bit unsigned.
Equivalent to Unsigned LongInt.

Syntax
   Dim variable As ULongInt

Description
   A 64-bit unsigned whole-number data type. Can hold values from 0 to 18 
   446 744 073 709 551 615. Corresponds to an unsigned QWORD.

Example
   Dim x As ULongInt = 0
   Dim y As ULongInt = &HFFFFFFFFFFFFFFFFull
   Print "ULongInt Range = "; x; " to "; y

   Output:
   ULongInt Range = 0 To 18446744073709551615

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Ulongint.

Differences from QB
   * New to FreeBASIC

See also
   * LongInt
   * CULngInt
   * Table with variable types overview, limits and suffixes



------------------------------------------------------------ KeyPgUnion ----
Union

Declares a union user defined type.

Syntax
   Union typename
      fieldname as datatype
      Declare member function declaration ...
      ...
   End Union

Parameters
   typename
      Name of the Union
   fieldname
      Name of a data field member
   member function declaration
      Any of the supported member functions

Description
   The data elements of a Union occupy a common space in memory (same 
   memory address for all data elements of the Union). A data element of a 
   Union can be a simple data field or an unnamed Type block of data 
   fields.
   The size of the Union is the size of the largest data element.
   Since they occupy a common memory space, only one data element can 
   usually be used at a given time (when a given data element is written, 
   the other data elements sharing the common union space may be 
   overwritten or mutilated).

   Like Type, Union can use the optional Field = number specifier for field 
   alignment, and supports also inheritance through the use of the Extends 
   keyword.
   Unlike Type, Union can not contain variable-length strings and arrays, 
   and more generally can not have object fields (or bases) with 
   constructors or destructors. Therefore, Union does not support to 
   inherit from the Object built-in type.

   A Union supports member procedures including Constructor, Destructor, 
   Function, Operator, Property and Sub. All members of a Union are public 
   and access modifiers are not supported. 

   A Union can also contain nested types or unions, allowing data members 
   to be grouped as desired.
   Type and Union can be directly nested on condition of alternating their 
   nesting.
   Only the main structure (Type or Union) can be named, the others 
   (nested) must be unnamed.
   Nested unnamed Type or Union can not have procedure members or static 
   data members (same restriction for local scope named Type/Union).

   A Union can be passed in a similar way of a User Defined Type to 
   overloaded operator procedures.

   Note: When Union extends a base, it can be confusing because no new 
   fields are added to the base, but instead the base is added to the 
   derived Union. This means that data elements in the derived Union can 
   share the same memory space like the base (here it doesn't matter 
   whether the base is a Union or not). Of course it can be dangerous, but 
   that is always the problem with Unions.
   If only the base is a Union, then it won't be affected by data elements 
   from the derived UDT.
   Since Union is not allowed to have complex data elements (i.e. UDTs with 
   constructor/destructor, or dynamic strings), a derived Union can not be 
   allowed to have (contain) a complex base.

Example
   ' Example 0: Little-endianness
   ' For larger integer values (as the following Ulong data type),
   '   bytes are arranged in memory in 'little-endian' byte order
   '   (the least significant byte gets stored first).

   Union UDU
      ul As ULong      ' 32-bit data type
      Type
        ub0 As UByte  ' 8-bit data type
        ub1 As UByte  ' 8-bit data type
        ub2 As UByte  ' 8-bit data type
        ub3 As UByte  ' 8-bit data type
      End Type
   End Union

   Dim As UDU u
   u.ul = &h12345678
   Print Hex(u.ul)                                       ' Result: 12345678
   Print Hex(u.ub3), Hex(u.ub2), Hex(u.ub1), Hex(u.ub0)  ' Result: 12   34   56   78

   Sleep

   ' Example 1: Only one union member can be relevantly accessed at a time
   Union member
     username As String * 32
     posts As ULong
   End Union

   Dim As member userX
   userX.username = "Samantha"
   userX.posts = 1234

   Print userX.username  ' value of username corrupted because final value assigned to posts occupies same memory location
   '                     ' (and this is reason that value of posts is displayed well)
   Print userX.posts
   Print

   Dim As member userY
   userY.posts = 4321
   userY.username = "Alexander"

   Print userY.username
   Print userY.posts  ' value of posts corrupted because final value assigned to username occupies same memory location
   '                  ' (and this is reason that value of username is displayed well)
   Print

   Sleep

   ' Example 2: Alternative to RGBA keyword and allowing to retrieve elementary colors values
   Union BGRA_UNION
      colour As ULong
      Type
        blue  As UByte
        green As UByte
        red   As UByte
        Alpha As UByte
      End Type
   End Union

   Dim ubgra As BGRA_UNION

   ' Setting the individual color values...
   ubgra.red = &h33
   ubgra.green = &hcc
   ubgra.blue = &h66
   ' We can get a ULONG value
   Print Hex(ubgra.colour)  ' Result: 33CC66
   Print

   ' Setting a ULONG value...
   ubgra.colour = &h228844
   ' We can get the individual color values
   Print Hex(ubgra.red)    ' Result: 22
   Print Hex(ubgra.green)  ' Result: 88
   Print Hex(ubgra.blue)   ' Result: 44
   Print

   Sleep

   ' Example 3.
   ' Define a simple union.
   Union AUnion
      a As UByte
      b As UInteger
   End Union
   ' Define a composite type with an unnamed union.
   Type CompType
      s As String * 20
      ui As UByte 'Flag to tell us what to use in union.
      Union
         au As UByte
         bu As UInteger
      End Union
   End Type

   ' Flags to let us know what to use in union,
   ' because it's relevant to only use a single element of a union at a given time.
   Const IsInteger = 1
   Const IsUByte = 2

   Dim MyUnion As AUnion
   Dim MyComposite As CompType

   ' Only one field within the union is set, without choice criterion.
   MyUnion.a = 128

   MyComposite.s = "Type + Union"
   MyComposite.ui = IsInteger ' Tells us this is an integer union.
   MyComposite.bu = 1500      ' Field set according to the above flag.

   Print "Simple Union: ";MyUnion.a

   Print MyComposite.s & ": ";
   If MyComposite.ui = IsInteger Then
      Print MyComposite.bu
   ElseIf MyComposite.ui = IsUByte Then
      Print MyComposite.au
   Else
      Print "Unknown Type."
   End If
   Print

   Sleep

Dialect Differences
   * Object-related features as functions defined inside the Union block 
     are supported only in the -lang fb dialect.
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Union.

Differences from QB
   * New to FreeBASIC

See also
   * Type
   * Coercion and Conversion



----------------------------------------------------------- KeyPgUnlock ----
Unlock

Removes a previous access restriction (lock) on a file

Syntax
   Unlock #filenum, record
   Unlock #filenum, start To end

Parameters
   filenum
      The file number used to Open the file.
   record
      The record (Random files) to unlock.
   start
      The first byte position (Binary files) in a range to unlock.
   end
      The last byte position (Binary files) in a range to unlock.

Description
   Unlock removes the temporary access restriction set by Lock.

   It is strongly recommended to use the same arguments used in the 
   previous Lock.

   Note: This command does not always work, neither as documented nor as 
   expected. It appears to be broken at the moment.

Example
       For an example see Lock.

Differences from QB
   * Currently, FB cannot implicitly unlock the entire file
   * In Random mode, FB cannot unlock a range of records

See also
   * Lock
   * Open
   * ScreenUnlock



--------------------------------------------------------- KeyPgUnsigned ----
Unsigned

Integer data type modifier

Syntax
   Dim variable As Unsigned {integer-based data type}

Description
   Forces an integer-based data type to be unsigned (cannot contain 
   negative numbers, but has its maximum value doubled).

Example
   'e.g. notice what is displayed:

   Dim x As Unsigned Integer
   x = -1
   Print x 

   'output is 4294967295

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Unsigned.

Differences from QB
   * New to FreeBASIC

See also
   * UInteger



------------------------------------------------------------ KeyPgUntil ----
Until

Conditional clause used in Do..Loop statements.

Syntax
   Do Until condition
      or
   Loop Until condition

Description
   Until is used with the Do...Loop structure.

Example
   Dim a As Integer

   a = 1
   Do
      Print "hello"
   a = a + 1
   Loop Until a > 10

   'This will continue to print "hello" on the screen until the condition (a > 10) is met. 

Differences from QB
   * None

See also
   * Do...Loop

   


----------------------------------------------------------- KeyPgUshort ----
UShort

Standard data type: 16 bit unsigned.
Equivalent to Unsigned Short.

Syntax
   Dim variable As UShort

Description
   16-bit unsigned whole-number data type. Can hold values from 0 to 65535.

Example
     Dim x As UShort = 0
     Dim y As UShort = &HFFFF
     Print "UShort Range = "; x; " to "; y

   Output:
   UShort Range = 0 To 65535

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Ushort.

Differences from QB
   * New to FreeBASIC

See also
   * Short
   * CUShort
   * Table with variable types overview, limits and suffixes



------------------------------------------------------- KeyPgPrintusing ----
(Print | ?) Using

Outputs formatted text to the screen or output device

Syntax
   (Print | ?) [# filenum ,] [ printexpressionlist {,|;} ] Using 
   formatstring ; [ expressionlist [ ; ] ]

Parameters
   filenum
      The file number of a file or device opened for Output or Append.  
      (Alternatively LPrint may be used where appropriate, instead of 
      Print #)
   printexpressionlist
      Optional preceding list of items to print, separated by commas (,) or 
      semi-colons (;) (see Print for more details).
   formatstring
      Format string to use.
   expressionlist
      List of items to format, separated by semi-colons (;).

Description
   Print to screen various expressions using a format determined by the 
   formatstring parameter. Internally, Print Using uses a buffer size of 
   2048 bytes: while it is highly unlikely that this buffer would be 
   filled, it should be noted that output would be truncated should this 
   limit be reached.

   If no expression list is given, the format string will be printed up to 
   the first special marker.  Note that the semi-colon after formatstring 
   is still necessary, even if no expression list is given.

   The format string dictates how the expressions are to be formatted when 
   output to the screen, indicated by the use of special marker characters. 
   There are markers for formatting both string and numeric output:

   String formatting

         +------+----------------------------------------------------------------------+
         |Marker|Formatting                                                            |
         |!     |prints the first character of a string                                |
         |\   \ |prints as many characters of a string as occupied between the pair \ \|
         |&     |prints the entire string                                              |
         +------+----------------------------------------------------------------------+

   Numeric formatting

         +------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+
         |Marker|Formatting                                                                                                                                                            |
         |#     |placeholder for either an integer digit, or a decimal digit if a decimal point precedes it                                                                            |
         |,     |placed after integer digit indicates groups of 3 digits should be separated by commas in fixed-point notation                                                         |
         |.     |placed near # indicates place for the decimal point                                                                                                                   |
         |^^^   |uses exponential notation (E+/-#) when placed after the digit characters                                                                                              |
         |^^^^  |uses exponential notation (E+/-##) when placed after the digit characters                                                                                             |
         |^^^^^ |uses exponential notation (E+/-###) when placed after the digit characters                                                                                            |
         |+     |placed before/after the format string, controls whether the sign of a number is prepended/appended, and causes an explicit '+' sign to be printed for positive numbers|
         |-     |placed after the format string, causes the sign of the number to be appended rather than prepended, appending a space/negative sign for positive/negative numbers     |
         |$$    |placed at the start of integer digits, causes a dollar sign to be prepended to the number (after the sign if one is prepended)                                        |
         |**    |placed at the start of integer digits, causes any padding on the left to be changed from spaces to asterisks                                                          |
         |**$   |placed at the start of integer digits, pads on the left with asterisks, and prepends a dollar sign after the asterisks                                                |
         |&     |prints a number intelligently, using the exact number of digits required (new to version 0.21.0b)                                                                     |
         +------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+

   All of the special marker characters can be escaped by preceding them 
   with the underscore character "_", allowing them to be printed directly. 
   For example, "_!" is printed as "!", and "__" is printed as "_".

   If a numerical value cannot fit in the number of digits indicated by the 
   format string, the formatting is adapted to fit the number, possibly 
   switching to scientific notation, and the number is printed preceded by 
   the percent "%" character. E.g., the number 1234 with a formatstring of 
   "##.##" would be printed as "%1234.00".

   All other characters within the format string are printed as they 
   appear.

   A new-line character is printed after the values in the expression list 
   unless the expression list is followed by a semicolon (;).

Example

   Print Using "The value is #.## seconds"; 1.019
   Print Using "The ASCII code for the pound sign (_#) is ###"; Asc("#")
   Print Using "The last day in the year is & \ \"; 31; "December"

   will produce the output:

   The value Is 1.02 seconds
   The ASCII code For the pound sign (#) Is  35
   The last Day in the Year Is 31 Dec

Differences from QB
   * QB didn't allow "&" to be used for printing numbers.

See also
   * Print
   * ?
   * Print #
   * ? #
   * Format
   * Using
   * Palette Using



------------------------------------------------------------ KeyPgUsing ----
Using (Namespaces)

Brings namespace symbols into the current scope

Syntax
   Using identifier [, identifier [, ...] ]

Parameters
   identifier: The name of the Namespace that you want to use.

Description
   The Using command allows all symbols from a given namespace to be 
   accessed without the namespace's name prefix. Unlike C++ but like C#, 
   the Namespace keyword is not needed after Using, because individual 
   symbols cannot be inherited from a namespace.

   Using is allowed in namespaces and procedures only (not in type or union 
   or enum declarations).

   Inheriting a whole namespace can save typing, but sometimes some meaning 
   of the code can be lost, and conflicts with other symbols could be 
   created.

Example
   Namespace Sample
      Type T
         x As Integer
      End Type
   End Namespace

   '' Just using the name T would not find the symbol,
   '' because it is inside a namespace.
   Dim SomeVariable As Sample.T

   '' Now the whole namespace has been inherited into
   '' the global namespace.
   Using Sample

   '' This statement is valid now, since T exists
   '' without the "Sample." prefix.
   Dim OtherVariable As T 

Version
   * Before fbc 1.09.0, if there is duplicated symbol in the global 
     namespace (unnamed namespace), access to local symbol is captured by 
     duplicated global symbol (in that case, full prefixing is required to 
     access local symbol).

Differences from QB
   * QB had the Using keyword, but for other purposes. Namespaces did not 
     exist in QB.

See also
   * Print Using
   * ? Using
   * Palette Using
   * Namespace




============================================================================
    V

------------------------------------------------------------ KeyPgVaArg ----
va_arg

Returns the current argument from a variable argument list.

Syntax
   variable = va_arg ( argument_list, datatype )

Description
   The va_arg macro allows the use of a variable number of arguments within 
   a function:
      * 	va_arg returns the current argument in the list, argument_list, 
        with an expected data type of datatype.
      * 	Before first va_arg use, argument_list must be initialized with 
        the command va_first.
      * 	Unlike the C macro with the same name, va_arg does not 
        automatically increment argument_list to the next argument within 
        the list. Instead va_next must be used to find the next argument in 
        adjusting argument_list.

   Not supported when using -gen gcc.  Use Cva_List variadic argument list 
   type for cross platform compatibility.

Example
   See the Va_First() examples.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __va_arg.

Differences from QB
   * New to FreeBASIC

See also
   * ... (Ellipsis)
   * va_first
   * va_next



---------------------------------------------------------- KeyPgVaFirst ----
va_first

Returns a pointer to the first argument in a variable argument list

Syntax
   pointer_variable = va_first()

Description
   The va_first function provides an untyped pointer value that points to 
   the first variable argument passed to a function.

   Not supported when using -gen gcc.  Use Cva_List variadic argument list 
   type for cross platform compatibility.

Example
   Function average cdecl(count As Integer, ... ) As Double
      Dim arg As Any Ptr
      Dim sum As Double = 0
      Dim i As Integer
      
      arg = va_first()

      For i = 1 To count
         sum += va_arg(arg, Double)
         arg = va_next(arg, Double)
      Next
      
      Return sum / count
   End Function

   Print average(4, 3.4,5.0,3.2,4.1)  '' all passed variable arguments must be of type double
   Print average(2, 65.2,454.65481)   '' all passed variable arguments must be of type double
   Sleep

The output would look like:

   3.925
   259.927405

   '' Example of a simple custom printf
   Sub myprintf cdecl(ByRef formatstring As String, ...)
      '' Get the pointer to the first var-arg
      Dim As Any Ptr arg = va_first()

      '' For each char in format string...
      Dim As UByte Ptr p = StrPtr(formatstring)
      Dim As Integer todo = Len(formatstring)
      While (todo > 0)
         Dim As Integer char = *p
         p += 1
         todo -= 1

         '' Is it a format char?
         If (char = Asc("%")) Then
            If (todo = 0) Then
               '' % at the end
               Print "%";
               Exit While
            End If

            '' The next char should tell the type
            char = *p
            p += 1
            todo -= 1

            '' Print var-arg, depending on the type
            Select Case char
            '' integer?
            Case Asc("i")
               Print Str(va_arg(arg, Integer));
               '' Note, different from C: va_next() must be
               '' used as va_arg() won't update the pointer.
               arg = va_next(arg, Integer)

            '' long integer? (64-bit)
            Case Asc("l")
               Print Str(va_arg(arg, LongInt));
               arg = va_next(arg, LongInt)

            '' single or double?
            '' Note: because the C ABI, all singles passed on
            '' var-args are converted to doubles.
            Case Asc( "f" ), Asc( "d" )
               Print Str(va_arg(arg, Double));
               arg = va_next(arg, Double)

            '' string?
            Case Asc("s")
               '' Strings are passed byval, so the length is unknown
               Print *va_arg(arg, ZString Ptr);
               arg = va_next(arg, ZString Ptr)

            End Select

         '' Ordinary char, just print as-is
         Else
            Print Chr( char );
         End If
      Wend
   End Sub

      Dim As String s = "bar"

      myprintf(!"integer=%i, longint=%l single=%f, double=%d, string=%s, string=%s\n", _
             1, 1ll Shl 32, 2.2, 3.3, "foo", s)

      Sleep

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Va_first.

Differences from QB
   * New to FreeBASIC

See also
   * ... (Ellipsis)
   * va_arg
   * va_next



----------------------------------------------------------- KeyPgVaNext ----
va_next

Returns a pointer to the next argument in a variable argument list

Syntax
   Argument_Pointer = va_next ( Argument_List, datatype )

Description
   The va_next macro provides a datatype pointer value that points to the 
   next argument within the list Argument_List, datatype being the type of 
   the current argument being stepped over.

   Not supported when using -gen gcc.  Use Cva_List variadic argument list 
   type for cross platform compatibility.

Example
   See the Va_First() examples.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Va_next.

Differences from QB
   * New to FreeBASIC

See also
   * ... (Ellipsis)
   * va_arg
   * va_first



-------------------------------------------------------------- KeyPgVal ----
Val

Converts a string to a floating point number

Syntax
   Declare Function Val ( ByRef str As Const String ) As Double
   Declare Function Val ( ByRef str As Const WString ) As Double

Usage
   result = Val( strnum )

Parameters
   strnum
      the string containing a number to convert

Return Value
   Returns a converted Double precision number

   If the first character of the string is invalid, Val will return 0.

Description
   Val("10") will return 10.0, and Val("10.10") will return 10.1. The 
   function parses the string from the left, skipping any white space, and 
   returns the longest number it can read, stopping at the first 
   non-suitable character it finds.  Scientific notation is recognized, 
   with "D" or "E" used to specify the exponent.

   Val can be used to convert integer numbers in binary / octal / 
   hexadecimal format, if they have the relevant identifier ("&B" / "&O" / 
   "&H") prefixed, for example: Val("&HFF") returns 255.

   Note:
   If you want to get an integer value from a string, consider using ValInt 
   or ValLng instead.  They are faster, since they don't use floating-point 
   numbers, and only ValLng provides full 64-bit precision for LongInt 
   types.

   If you want to convert a number into string format, use the Str 
   function.

Example
   Dim a As String, b As Double
   a = "2.1E+30xa211"
   b = Val(a)
   Print a, b


   2.1E+30xa211   2.1e+030

Differences from QB
   * None

See also
   * CDbl
   * ValInt
   * ValUInt
   * ValLng
   * ValULng
   * Str
   * Chr
   * Asc



----------------------------------------------------------- KeyPgVallng ----
ValLng

Converts a string to a 64bit integer

Syntax
   Declare Function ValLng ( ByRef strnum As Const String ) As LongInt
   Declare Function ValLng ( ByRef strnum As Const WString ) As LongInt

Usage
   result = ValLng ( strnum )

Parameters
   strnum
      the string to convert

Return Value
   Returns a LongInt of the converted string

   If the first character of the string is invalid, ValLng will return 0.

Description
   For example, ValLng("10") will return 10, and ValLng("10.60") will 
   return 10 as well. The function parses the string from the left, 
   skipping any white space, and returns the longest number it can read, 
   stopping at the first non-suitable character it finds.  Any non-numeric 
   characters, including decimal points and exponent specifiers, are 
   considered non-suitable, for example, ValLng("23.1E+6") will just return 
   23.

   ValLng can be used to convert integer numbers in Binary / Octal / 
   Hexadecimal format, if they have the relevant identifier ("&B" / "&O" / 
   "&H") prefixed, for example: ValLng("&HFF") returns 255.

   If you want to convert a number into string format, use the Str 
   function.

Example
   Dim a As String, b As LongInt
   a = "20xa211"
   b = ValLng(a)
   Print a, b


   20xa211   20

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Vallng.

Differences from QB
   * New to FreeBASIC

See also
   * CLngInt
   * Val
   * ValInt
   * ValULng
   * Str
   * Chr
   * Asc



----------------------------------------------------------- KeyPgValint ----
ValInt

Converts a string to a 32bit integer

Syntax
   Declare Function ValInt ( ByRef strnum As Const String ) As Long
   Declare Function ValInt ( ByRef strnum As Const WString ) As Long

Usage
   result = ValInt ( strnum )

Parameters
   strnum
      the string to convert

Return Value
   Returns a Long value of the converted string

   If the first character of the string is invalid, ValInt will return 0.

Description
   For example, ValInt("10") will return 10, and ValInt("10.60") will 
   return 10 as well. The function parses the string from the left, 
   skipping any white space, and returns the longest number it can read, 
   stopping at the first non-suitable character it finds.  Any non-numeric 
   characters, including decimal points and exponent specifiers, are 
   considered non-suitable, for example, ValInt("23.1E+6") will just return 
   23.

   ValInt can be used to convert integer numbers in Binary / Octal / 
   Hexadecimal format, if they have the relevant identifier ("&B" / "&O" / 
   "&H") prefixed, for example: ValInt("&HFF") returns 255.

   If you want to convert a number into string format, use the Str 
   function.

Example
   Dim a As String, b As Integer
   a = "20xa211"
   b = ValInt(a)
   Print a, b


   20xa211   20

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Valint.

Differences from QB
   * New to FreeBASIC

See also
   * CLng
   * Val
   * ValUInt
   * ValLng
   * Str
   * Chr
   * Asc



---------------------------------------------------------- KeyPgValuint ----
ValUInt

Converts a string to an unsigned 32bit integer

Syntax
   Declare Function ValUInt ( ByRef strnum As Const String ) As ULong
   Declare Function ValUInt ( ByRef strnum As Const WString ) As ULong

Usage
   result = ValUInt ( strnum )

Parameters
   strnum
      the string to convert

Return Value
   Returns a ULong value of the converted string

   If the first character of the string is invalid, ValUInt will return 0.

Description
   For example, ValUInt("10") will return 10, and ValUInt("10.60") will 
   return 10 as well. The function parses the string from the left, 
   skipping any white space, and returns the longest number it can read, 
   stopping at the first non-suitable character it finds.  Any non-numeric 
   characters, including decimal points and exponent specifiers, are 
   considered non-suitable, for example, ValUInt("23.1E+6") will just 
   return 23.

   ValUInt can be used to convert integer numbers in Binary / Octal / 
   Hexadecimal format, if they have the relevant identifier ("&B" / "&O" / 
   "&H") prefixed, for example: ValUInt("&HFF") returns 255.

   If you want to convert a number into string format, use the Str 
   function.

Example
   Dim a As String, b As UInteger
   a = "20xa211"
   b = ValUInt(a)
   Print a, b


   20xa211   20

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Valuint.

Differences from QB
   * New to FreeBASIC

See also
   * Val
   * ValInt
   * ValULng
   * CULng
   * Str
   * Chr
   * Asc



---------------------------------------------------------- KeyPgValulng ----
ValULng

Converts a string to a unsigned 64bit integer

Syntax
   Declare Function ValULng ( ByRef strnum As Const String ) As ULongInt
   Declare Function ValULng ( ByRef strnum As Const WString ) As ULongInt

Usage
   result = ValULng ( strnum )

Parameters
   strnum
      the string to convert

Return Value
   Returns a ULongInt of the converted string

   If the first character of the string is invalid, ValULng will return 0.

Description
   For example, ValULng("10") will return 10, and ValULng("10.60") will 
   return 10 as well. The function parses the string from the left, 
   skipping any white space, and returns the longest number it can read, 
   stopping at the first non-suitable character it finds.  Any non-numeric 
   characters, including decimal points and exponent specifiers, are 
   considered non-suitable, for example, ValULng("23.1E+6") will just 
   return 23.

   ValULng can be used to convert integer numbers in Binary / Octal / 
   Hexadecimal format, if they have the relevant identifier ("&B" / "&O" / 
   "&H") prefixed, for example: ValULng("&HFF") returns 255.

   If you want to convert a number into string format, use the Str 
   function.

Example
   Dim a As String, b As ULongInt
   a = "20xa211"
   b = ValULng(a)
   Print a, b


   20xa211   20

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Valulng.

Differences from QB
   * New to FreeBASIC

See also
   * CULngInt
   * Val
   * ValUInt
   * ValLng
   * Str
   * Chr
   * Asc



-------------------------------------------------------------- KeyPgVar ----
Var

Declares a variable whose type is implied from the initializer expression

Syntax
   [Static] Var [Shared] symbolname = expression[, symbolname = expression]

Description
   Var declares a variable whose type is implied from the initializer 
   expression. It is illegal to specify an explicit type in a Var 
   declaration. The initializer expression can be either a constant or any 
   variable of any type.

   Note: WString is not supported with Var, due to the fact that there is 
   no var-len WString type. This isn't likely to change, due to the 
   complexities involved with handling Unicode.

   Since the type of the variable is inferred from what you assign into it, 
   it's helpful to know how literals work. Any literal number without a 
   decimal point defaults to Integer. A literal number with a decimal point 
   defaults to Double.  See Literals for further information.

   All ZString expressions, including string literals and dereferenced 
   ZString Ptrs, will be given the String variable type.

   Explicit suffixes may be used on literal variables, to change/clarify 
   their type. See Literals and Variable Types for some more information 
   about suffixes that can be used on literals.

   Note: Suffixes must appear on the initializer, not on the variable. 
   Trying to use Var with a variable that has a suffix will throw a compile 
   error.

Example
   Var a  = Cast(Byte, 0)
   Var b  = Cast(Short, 0)
   Var c  = Cast(Integer, 0)
   Var d  = Cast(LongInt, 0)
   Var au = Cast(UByte, 0)   
   Var bu = Cast(UShort, 0)  
   Var cu = Cast(UInteger, 0)
   Var du = Cast(ULongInt, 0)
   Var e  = Cast(Single, 0.0)
   Var f  = Cast(Double, 0.0)
   Var g  = @c      '' integer ptr
   Var h  = @a      '' byte ptr
   Var s2 = "hello" '' var-len string

   Var ii = 6728   '' implicit integer
   Var id = 6728.0 '' implicit double

   Print "Byte: ";Len(a)
   Print "Short: ";Len(b)
   Print "Integer: ";Len(c)
   Print "Longint: ";Len(d)
   Print "UByte: ";Len(au)
   Print "UShort: ";Len(bu)
   Print "UInteger: ";Len(cu)
   Print "ULongint: ";Len(du)
   Print "Single: ";Len(e)
   Print "Double: ";Len(f)
   Print "Integer Pointer: ";Len(g)
   Print "Byte Pointer: ";Len(h)
   Print "Variable String: ";Len(s2)
   Print
   Print "Integer: ";Len(ii)
   Print "Double: ";Len(id)

   Sleep

Differences from QB
   * New to FreeBASIC

Dialect Differences
   * Only valid in the -lang fb dialect.

See also
   * Common
   * Dim
   * Erase
   * Extern
   * LBound
   * ReDim
   * Preserve
   * Shared
   * Static
   * Byref (Variables)
   * UBound
   * Pointers to Procedures



--------------------------------------------------------- KeyPgOpVarptr ----
Operator Varptr (Variable Pointer)

Returns the address of a variable or object

Syntax
   Declare Operator VarPtr ( ByRef lhs As T ) As T Ptr

Syntax
   result = VarPtr ( lhs )

Parameters
   lhs
      A variable or object.
   T
      Any data type.

Return Value
   Returns the address of a variable or object.

Description
   This operator returns the address of its operand.

   When the operand is of type String, the address of the internal string 
   descriptor is returned. Use Operator Strptr (String Pointer) to retrieve 
   the address of the string data.

   The operand cannot be an array, but may be an array element. For 
   example, "VarPtr(myarray(0))" returns the address of "myarray(0)".

   Operator @ (Address Of), when used with variables or objects, has 
   identical behavior.

Example
   Dim a As Integer, addr As Integer
   a = 10

   '' place the address of a in addr
   addr = CInt( VarPtr(a) )

   '' change all 4 bytes (size of INTEGER) of a
   Poke Integer, addr, -1000 
   Print a

   '' place the address of a in addr (same as above)
   addr = CInt( @a )

   '' print the least or most significant byte, depending on the CPU endianess
   Print Peek( addr ) 

Differences from QB
   * None

See also
   * Pointers
   * Peek
   * Poke



--------------------------------------------------------- KeyPgViewtext ----
View Print

Sets the printable text area of the screen

Syntax
   View Print [ firstrow To lastrow ]

Parameters
   firstrow
      first row of print area
   lastrow
      last row of print area

Description
   Sets the boundaries of the text printing area on the screen (in console 
   mode or in graphics mode) to the lines starting at first up to and 
   including last (the number of the available text lines on the screen 
   depends on the screen mode). Text lines are counted starting with 1. The 
   text cursor is moved to the beginning of the first line specified.
   If the row numbers are omitted, the entire screen is used as the text 
   printing area.

Example
   Cls
   View Print 5 To 6
   Color , 1 
   '' clear only View Print area
   Cls 

View Print can be used in graphics mode to avoid the text output 
overwriting graphics:
   Screen 12
   Dim As Integer R,Y,x,y1
   Dim As Single y2
   View Print 20 To 27
   Line (0,0)-(639,300),1,BF
   Line (100,50)-(540,200),0,BF
   Do
    r = (r + 1) And 15
    For y = 1 To 99
      y1 = ((1190 \ y + r) And 15)
      y2 = 6 / y
      For x = 100 To 540
      PSet (x, y + 100), CInt((319 - x) * y2) And 15 Xor y1 
     Next x,y
    If r=0 Then Color Int(Rnd*16): Print "blah"
   Loop Until Len(Inkey)

Differences from QB
   * None.

See also
   * Cls
   * Print
   * ?
   * Color



----------------------------------------------------- KeyPgViewgraphics ----
View (Graphics)

Sets new physical coordinate mapping and clipping region for graphics 
keywords

Syntax
   View
   View ( x1, y1 )-( x2, y2 ) [ [, fill_color ] [, border_color ] ]
   View Screen ( x1, y1 )-( x2, y2 ) [ [, fill_color ] [, border_color ] ]

Parameters
   x1 As Integer, y1 As Integer
      The horizontal and vertical offsets, in pixels, of one corner of the 
      viewport relative to the top-left corner of the screen.
   x2 As Integer, y2 As Integer
      The horizontal and vertical offsets, in pixels, of the opposite 
      corner of the viewport relative to the top-left corner of the screen.
   fill_color As ULong
      The color to fill the new viewport.
   border_color As ULong
      The color of the border to draw around the new viewport.

Description
   The viewport, or clipping region, is a rectangular area of the graphics 
   screen, outside of which no graphics drawing will be done. That is, only 
   graphics drawing done within this area will be shown. A graphics screen 
   must be created with Screen or ScreenRes before calling View or View 
   Screen.

   The first statement (View) sets the viewport to encompass the entire 
   screen, which is the default viewport for a new graphics screen.

   The second and third statements (View parameters and View Screen 
   parameters) both allow a new viewport to be defined. The indicated 
   effects for each parameter only occur if that parameter is specified:
      * The corners of the viewport are specified by the x1, y1, x2 and y2 
        parameters.
      * fill_color and border_color are both in the format accepted by 
        Color.
      * The second statement (View parameters) modifies the coordinate 
        mapping of the graphics screen such that coordinates specified for 
        graphics drawing statements and procedures are relative to the 
        top-left corner of the viewport.
      * The third statement (View Screen parameters) modifies the 
        coordinate mapping of the graphics screen such that coordinates 
        specified for graphics drawing statements and procedures are 
        relative to the top-left corner of the screen.
      * In both cases no new scale factor is applied (see Window for 
        that).

Example
   Screen 12
   Dim ip As Any Ptr
   Dim As Integer x, y

   'simple sprite
   ip = ImageCreate(64,64)
   For y = 0 To 63
     For x = 0 To 63
      PSet ip, (x, y), (x\4) Xor (y\4)
     Next x
   Next y

   'viewport with blue border
   Line (215,135)-(425,345), 1, bf
   View (220,140)-(420,340)

   'move sprite around the viewport
   Do

     x = 100*Sin(Timer*2.0)+50
     y = 100*Sin(Timer*2.7)+50
     
     ScreenSync
     ScreenLock
     
     'clear viewport and put image
     Cls 1
     Put (x, y), ip, PSet
      
     ScreenUnlock

   Loop While Inkey = ""

   ImageDestroy(ip)

Differences from QB
   * QBASIC preserves the WINDOW coordinate mapping after subsequent calls 
     to VIEW.
   * FreeBASIC's current behavior is to preserve the WINDOW coordinates 
     after calls to VIEW, or when working on images, meaning that the 
     coordinate mapping may undergo scaling/translations if the viewport 
     changes. (If a WINDOW hasn't been set, there is no coordinate mapping, 
     and so it doesn't change after calls to VIEW.)  The behavior may 
     change in future, but consistent behavior can be assured over 
     inconstent viewport coordinates by re-calling WINDOW whenever you 
     change the VIEW.

See also
   * View Print
   * Screen (Graphics)
   * Window
   * PMap



---------------------------------------------------------- KeyPgVirtual ----
Virtual

Declare virtual methods

Syntax
   Type typename Extends base_typename
      Declare Virtual Sub|Function|Property|Operator|Destructor ...
   End Type

Description
   Virtual methods are methods that can be overridden by data types derived 
   from the type they were declared in, allowing for dynamic polymorphism. 
   In contrast to Abstract methods, virtual methods must have an 
   implementation, which is used when the virtual is not overridden.

   A derived type can override virtual methods declared in its base type by 
   declaring a non-static method with the same identifier and signature, 
   meaning same number and type of parameters (invariant parameters), same 
   calling convention, and if any, same return type (or a covariant return 
   type for return by reference or by pointer):
      * if that differs only in parameter passing mode or calling 
        convention or return type, then an overriding error is returned at 
        compile time,
      * otherwise, only shadowing is allowed for any other signature 
        difference, corresponding to case where both methods would be 
        overloadable (if within the same type).
   The property of being a virtual method is not implicitly inherited by 
   the overriding method in the derived type. If this overriding method 
   must be overridden in turn in a lower level derived type, it must also 
   be declared as virtual.
   On the other hand, since a derived static method can never override a 
   base virtual/abstract method, it can therefore shadow any base method 
   (including virtual/abstract) with same identifier and regardless of the 
   signature.

   When calling virtual methods, the compiler may need to do a vtable 
   lookup in order to find out which method must be called for a given 
   object. This requires an extra hidden vtable pointer field to be added 
   at the top of each type with virtual methods. This hidden vptr is 
   provided by the built-in Object type. Because of that, virtual methods 
   can only be declared in a type that directly or indirectly Extends Object
   .

   Dynamic polymorphism by using override procedures:
      * Normally only a typename procedure (or upper in hierarchy) is 
        accessible through a base-typename reference/pointer even if this 
        one refers to an object derived from typename.
      * But when the procedure is virtual, this tells the running program 
        to resolve the override procedure the most derived relating to the 
        real object type by vtable lookup (dynamic binding at runtime), 
        rather than procedure normally accessible from the raw base-type of 
        the reference/pointer (static binding at compile time).

   Constructors cannot be virtual because they create objects, while 
   virtual methods require an already-existing object with a specific type. 
   The type of the constructor to call is determined at compile-time from 
   the code.
   In addition, when calling a virtual method inside a constructor, only 
   the version of the method corresponding to an object of type of this 
   constructor is used. That is because the vptr has not yet been set up by 
   the derived type constructor, but only by the local type constructor.

   Destructors often must be virtual when deleting an object manipulated 
   through a pointer to its base type, so that the destruction starts at 
   the most derived type and works its way down to the base type. To do 
   this, it may be necessary to add virtual destructors with an empty body 
   anywhere an explicit destruction was not yet required, in order to 
   supersede each non-virtual implicit destructor built by the compiler.
   On the other hand, when calling a virtual (or abstract) method inside a 
   destructor (virtual or not), only the version of the method 
   corresponding to an object of type of this destructor is used because 
   the vptr is reset at the top of the destructor according to its own 
   type's vtable. This avoids to access child methods and so to refer to 
   child members previously destroyed by the child destructor execution.

   For member methods with Virtual in their declaration, Virtual can also 
   be specified on the corresponding method bodies, for improved code 
   readability.

   Note: In a multi-level inheritance, a same named method (same identifier 
   and signature) can be declared Abstract, Virtual or normal (without 
   specifier) at each inheritance hierarchy level. When there is mixing of  
   specifiers, the usual order is abstract -> virtual -> normal, from top 
   to bottom of the inheritance hierarchy.
   The access control (Public/Protected/Private) of an overriding method is 
   not taken into account by the internal polymorphism process, but only 
   for the initial call at compile-time.
   Base.method() calls always the base's own method, never the overriding 
   method.

Example

   '' Example with overriding subroutines

   Type Hello Extends Object
      Declare Virtual Sub hi( )
   End Type

   Type HelloEnglish Extends Hello
      Declare Sub hi( )            '' overriding subroutine
   End Type

   Type HelloFrench Extends Hello
      Declare Sub hi( )            '' overriding subroutine
   End Type

   Type HelloGerman Extends Hello
      Declare Sub hi( )            '' overriding subroutine
   End Type

   Sub Hello.hi( )
      Print "hi!"
   End Sub

   Sub HelloEnglish.hi( )           '' overriding subroutine
      Print "hello!"
   End Sub

   Sub HelloFrench.hi( )            '' overriding subroutine
      Print "Salut!"
   End Sub

   Sub HelloGerman.hi( )            '' overriding subroutine
      Print "Hallo!"
   End Sub

   Randomize( Timer( ) )

   Dim As Hello Ptr h

   For i As Integer = 0 To 9
      Select Case( Int( Rnd( ) * 4 ) + 1 )
      Case 1
         h = New HelloEnglish
      Case 2
         h = New HelloFrench
      Case 3
         h = New HelloGerman
      Case Else
         h = New Hello
      End Select

      h->hi( )
      Delete h
   Next

   Sleep

   '' Example with overriding destructor and
   ''              overriding function with covariant return

   Type myBase Extends Object
     Declare Virtual Function clone () As myBase Ptr
     Declare Virtual Sub Destroy ()
   End Type

   Function myBase.clone () As myBase Ptr
     Dim As myBase Ptr pp = New myBase(This)
     Print "myBase.clone() As myBase Ptr", pp
     Function = pp
   End Function

   Sub myBase.Destroy ()
     Print "myBase.Destroy()", , @This
     Delete @This
   End Sub

   Type myDerived Extends myBase
     Declare Function clone () As myDerived Ptr     '' overriding member function with covariant return
     Declare Sub Destroy ()                         '' overriding member subroutine
   End Type

   Function myDerived.clone () As myDerived Ptr     '' overriding member function with covariant return
     Dim As myDerived Ptr pc = New myDerived(This)
     Print "myDerived.clone() As myDerived Ptr", pc
     Function = pc
   End Function

   Sub myDerived.Destroy ()                         '' overriding member subroutine
     Print "myDerived.Destroy()", , @This
     Delete @This
   End Sub

   Dim As myDerived c

   Dim As myBase Ptr ppc = @c
   Dim As myDerived Ptr pcc = @c

   Dim As myBase Ptr ppc1 = ppc->clone()            '' using base pointers and polymorphism
   Dim As myDerived Ptr pcc1 = pcc->clone()         '' using derived pointers and covariance of return value
   Print
   ppc1->Destroy()                                  '' using base pointer and polymorphism
   pcc1->Destroy()                                  '' using derived pointer

   Sleep

Dialect Differences
   * Only available in the -lang fb dialect.

Differences from QB
   * New to FreeBASIC

See also
   * Type
   * Object
   * Extends
   * Extends Zstring
   * Extends Wstring
   * Abstract
   * Override




============================================================================
    W

------------------------------------------------------------- KeyPgWait ----
Wait

Reads from a hardware port with a mask.

Syntax
   Declare Function Wait ( ByVal port As UShort, ByVal and_mask As Long, 
   ByVal xor_mask As Long = 0 ) As Long

Usage
   Wait port, and_value [, xor_value]

Parameters
   port
      Port to read.
   and_mask
      Mask value to And the port value with.
   xor_mask
      Mask value to Xor the port value with.

Return Value
   0 if successful, -1 on failure.

Description
   Wait keeps reading port until the reading ANDed with and_mask and 
   optionally XORed with xor_mask gives a non-zero result.

   Example
   Wait &h3da, &h8 'Old Qbasic way of waiting for the monitor's vsync
   ScreenSync 'FreeBASIC way of accomplishing the same thing

Platform Differences
   * In the Windows and Linux versions three port numbers (&H3C7, &H3C8, 
     &H3C9) are hooked by the graphics library when a graphics mode is in 
     use to emulate VGA palette handling as in QB. This use is deprecated; 
     use Palette to retrieve and set palette colors.

   * Using true port access in the Windows version requires the program to 
     install a device driver for the present session. For that reason, 
     Windows executables using hardware port access should be run with 
     administrator permits each time the computer is restarted. Further 
     runs don't require admin rights as they just use the already installed 
     driver. The driver is only 3K in size and is embedded in the 
     executable.

See also
   * Inp
   * Out

   


------------------------------------------------------------- KeyPgWbin ----
WBin

Returns the binary WString (Unicode) representation of a number

Syntax
   Declare Function WBin ( ByVal number As UByte ) As WString
   Declare Function WBin ( ByVal number As UShort ) As WString
   Declare Function WBin ( ByVal number As ULong ) As WString
   Declare Function WBin ( ByVal number As ULongInt ) As WString
   Declare Function WBin ( ByVal number As Const Any Ptr ) As WString

   Declare Function WBin ( ByVal number As UByte, ByVal digits As Long ) As 
   WString
   Declare Function WBin ( ByVal number As UShort, ByVal digits As Long ) As
   WString
   Declare Function WBin ( ByVal number As ULong, ByVal digits As Long ) As 
   WString
   Declare Function WBin ( ByVal number As ULongInt, ByVal digits As Long ) 
   As WString
   Declare Function WBin ( ByVal number As Const Any Ptr, ByVal digits As 
   Long ) As WString

Usage
   result = WBin( number [, digits] )

Parameters
   number
      A whole number or expression evaluating to a whole number.
   digits
      Optional number of digits to return.

Return Value
   Returns a binary WString representation of number, truncated or padded 
   with zeros ("0") to fit the number of digits, if specified.

Description
   Returns a WString (Unicode) representing the binary value of the integer 
   number. Binary digits range from 0 to 1.

   If you specify digits > 0, the result wstring will be exactly that 
   length.  It will be truncated or padded with zeros on the left, if 
   necessary.

   The length of the returned string will not be longer than the maximum 
   number of digits required for the type of expression (32 for a Long, 64 
   for floating point or LongInt)

Example
   Print WBin(54321)
   Print WBin(54321, 5)
   Print WBin(54321, 20)

   will produce the output:

   1101010000110001
   10001
   00001101010000110001

Platform Differences
   * Unicode strings are not supported in the DOS port of FreeBASIC.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Wbin.

Differences from QB
   * New to FreeBASIC

See also
   * Bin
   * WHex
   * WOct



------------------------------------------------------------- KeyPgWchr ----
WChr

Returns a wide-character string containing one or more Unicode characters

Syntax
   Declare Function Wchr ( ByVal ch As Integer [, ... ] ) As WString

Usage
   result = WChr( ch0 [, ch1 ... chN ] )

Parameters
   ch
      The Unicode integer value of a character.

Return Value
   Returns a wide-character string.

Description
   WChr returns a wide-character string containing the character(s) 
   represented by the Unicode values passed to it.

   When WChr is used with numerical constants or literals, the result is 
   evaluated at compile-time, so it can be used in variable initializers.

   Not all Unicode characters can be displayed on any machine, the 
   characters available depend on the font presently in use in the console. 
   Graphics modes can't display Unicode characters, as the GfxLib built-in 
   font is not Unicode.
 
Example
   Print "The character represented by the UNICODE code of 934 is: "; WChr(934)
   Print "Multiple UNICODE characters: "; WChr(933, 934, 935)

   will produce the output:
The character represented by the UNICODE code of 934 is: 
   Multiple UNICODE characters: 

Platform Differences
   * DOS does not support WChr.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Wchr.

Differences from QB
   * New to FreeBASIC

See also
   * Chr
   * WStr



---------------------------------------------------------- KeyPgWeekday ----
Weekday

Gets the number of day of the week from a Date Serial

Syntax
   Declare Function Weekday ( ByVal serial As Double , ByVal firstdayofweek 
   As Long = fbusesystem ) As Long

Usage
   #include "vbcompat.bi"
   result = Weekday( date_serial [, firstdayofweek ] )

Parameters
   date_serial
      the date
   firstdayofweek
      the first day of the week

Return Value
   Returns the week day number from a variable containing a date in 
   Date Serial format.

Description
   The week day values must be in the range 1-7, its meaning depends on the 
   firstdayofweek parameter

   firstdayofweek is optional.

         +-------+-----------------+-----------+
         |value  |first day of week|constant   |
         |omitted|sunday           |           |
         |0      |local settings   |fbUseSystem|
         |1      |sunday           |fbSunday   |
         |2      |monday           |fbMonday   |
         |3      |tuesday          |fbTuesday  |
         |4      |wednesday        |fbWednesday|
         |5      |thursday         |fbThursday |
         |6      |friday           |fbFriday   |
         |7      |saturday         |fbSaturday |
         +-------+-----------------+-----------+

   The compiler will not recognize this function unless vbcompat.bi is 
   included.

Example
   #include "vbcompat.bi"

   Dim a As Double = DateSerial (2005, 11, 28) + TimeSerial(7, 30, 50)

   Print Format(a, "yyyy/mm/dd hh:mm:ss "); Weekday(a)

Differences from QB
   * Did not exist in QB. This function appeared in PDS and VBDOS

See also
   * Date Serials



------------------------------------------------------ KeyPgWeekdayname ----
WeekdayName

Gets the name of a week day from its integral representation

Syntax
   Declare Function WeekdayName ( ByVal weekday As , ByVal abbreviate As 
   Long = 0, ByVal firstdayofweek As Long = fbUseSystem ) As String

Usage
   #include "vbcompat.bi"
   result = WeekdayName( weekday [, abbreviate [, firstdayofweek ] ] )

Parameters
   weekday
      the number of the day of the week
   abbreviate
      flag to indicate that name should be abbreviated
   firstdayofweek
      first day of the week

Return Value
   Returns the local operating system language day of week name from the 
   weekday value 1 to 7.

Description
   How weekday is interpreted depends on the firstdayofweek parameter.

   If abbreviate is true, a 3 letter abbreviation is returned, if false or 
   omitted, the whole name is returned.

   firstdayofweek is an optional parameter specified as follows:

         +-------+-----------------+-----------+
         |value  |first day of week|constant   |
         |omitted|sunday           |           |
         |0      |local settings   |fbUseSystem|
         |1      |sunday           |fbSunday   |
         |2      |monday           |fbMonday   |
         |3      |tuesday          |fbTuesday  |
         |4      |wednesday        |fbWednesday|
         |5      |thursday         |fbThursday |
         |6      |friday           |fbFriday   |
         |7      |saturday         |fbSaturday |
         +-------+-----------------+-----------+

   The compiler will not recognize this function unless vbcompat.bi or 
   datetime.bi is included.

Example
   #include "vbcompat.bi"

   Dim a As Double = DateSerial(2005, 11, 28) + TimeSerial(7, 30, 50)

   Print Format(a, "yyyy/mm/dd hh:mm:ss "); WeekdayName(Weekday(a))

Differences from QB
   * Did not exist in QB. This function appeared in Visual Basic.

See also
   * Date Serials



------------------------------------------------------------- KeyPgWend ----
Wend

Control flow statement.

Syntax
   While [condition]
      [statement block]
   Wend

Description
   Wend specifies the end of a While...Wend loop block.

Example
   See example at While...Wend.

Differences from QB
   * None

See also
   * While...Wend

   

------------------------------------------------------------ KeyPgWhile ----
While

Control flow statement.

Syntax
   Do While condition
      [statement block]
   Loop
or
   Do
      [statement block]
   Loop While condition
or
   While [condition]
      [statement block]
   Wend

Description
   While specifies that a loop block will continue if the condition 
   following it evaluates as true. This condition is checked during each 
   loop iteration.

Example
   Dim a As Integer

   a = 0
   Do While a < 10
      Print "hello"
   a = a + 1
   Loop

   'This will continue to print "hello" on the screen while the condition (a < 10) is met.
      

Differences from QB
   * None

See also
   * Do...Loop
   * While...Wend

   

-------------------------------------------------------- KeyPgWhilewend ----
While...Wend

Control flow statement for looping

Syntax
   While [condition]
      [statement block]
   Wend

Description
   The While statement will cause the following set of statements in the 
   statement block to execute repeatedly if and while the expression 
   condition evaluates to true.

   If condition evaluates to false when the While statement is first 
   executed, then the statement block is skipped and execution resumes 
   immediately following the enclosing Wend statement.

   If an Exit While statement is encountered inside the statement block, 
   the loop is terminated, and execution resumes immediately following the 
   enclosing Wend statement. If a Continue While statement is encountered, 
   the rest of the statement block is skipped and execution resumes at the 
   While statement.

   Like all control flow statements, the While statement can be nested, 
   that is, it can be used in a statement block of another While statement.

   note: the While keyword is also used in the Do...Loop statement to 
   indicate the type of comparison. Used in this way, the Do statement 
   becomes functionally equivalent to the While statement, so do not 
   confuse their enclosing keywords Loop and Wend, respectively.

Example
   In this example, a While loop is used to reverse a string by iterating 
   through it backward. The loop stops if index is less than 0 (0 being the 
   first index in the string).
   Dim As String sentence                          '' string to reverse
   sentence = "The quick brown fox jumps over the lazy dog."

   Dim As String ecnetnes
   Dim As Integer index
   index = Len( sentence ) - 1                     '' point to last character
   While( index >= 0 )                             '' stop after first character
     ecnetnes += Chr( sentence[index] )           '' append character to new string
     index -= 1
   Wend

   Print "original: """ ; sentence ; """"
   Print "reversed: """ ; ecnetnes ; """"

   End 0

Dialect Differences
   * In the -lang qb and -lang fblite dialects, variables declared inside 
     a While..Wend loop have a function-wide scope as in QB 
   * In the -lang fb and -lang deprecated dialects, variables declared 
     inside a While..Wend block are visible only inside the block, and 
     can't be accessed outside it. To access duplicated symbols defined as 
     global outside this block, add one or preferably two dot(s) as prefix: 
     .SomeSymbol or preferably ..SomeSymbol (or only ..SomeSymbol if inside 
     a With..End With block).

Differences from QB
   * None

See also
   * Exit
   * Continue
   * Do...Loop



------------------------------------------------------------- KeyPgWhex ----
WHex

Returns the hexadecimal WString (Unicode) representation of a number

Syntax
   Declare Function WHex ( ByVal number As UByte ) As WString
   Declare Function WHex ( ByVal number As UShort ) As WString
   Declare Function WHex ( ByVal number As ULong ) As WString
   Declare Function WHex ( ByVal number As ULongInt ) As WString
   Declare Function WHex ( ByVal number As Const Any Ptr ) As WString

   Declare Function WHex ( ByVal number As UByte, ByVal digits As Long ) As 
   WString
   Declare Function WHex ( ByVal number As UShort, ByVal digits As Long ) As
   WString
   Declare Function WHex ( ByVal number As ULong, ByVal digits As Long ) As 
   WString
   Declare Function WHex ( ByVal number As ULongInt, ByVal digits As Long ) 
   As WString
   Declare Function WHex ( ByVal number As Const Any Ptr, ByVal digits As 
   Long ) As WString

Usage
   result = WHex( number [, digits ] )

Parameters
   number
      A whole number or expression evaluating to a whole number.
   digits
      Optional number of digits to return.

Return Value
   Returns a hexadecimal WString representation of number, truncated or 
   padded with zeros ("0") to fit the number of digits, if specified.

Description
   Hexadecimal digits range from 0-9, or A-F.

   If you specify digits > 0, the resulting WString will be exactly that 
   length.  It will be truncated or padded with zeros on the left, if 
   necessary.

   The length of the wstring will not go longer than the maximum number of 
   digits required for the type of expression (8 for a Long, 16 for 
   floating point or LongInt)

Example
   Print Hex(54321)
   Print Hex(54321, 2)
   Print Hex(54321, 5)

   will produce the output:
   D431
   31
   0D431

Platform Differences
   * Unicode strings are not supported in the DOS port of FreeBASIC.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Whex.

Differences from QB
   * New to FreeBASIC.

See also
   * Hex
   * WBin
   * WOct



------------------------------------------------------------ KeyPgWidth ----
Width

Sets or gets the number of rows and columns of the display

Syntax
   Width [columns] [, rows]
   Width LPrint columns
   Width { #filenum | devicename }, columns
   result = Width( )

Parameters
   columns
      columns (in characters) for output
   rows
      rows (in characters) for output
   filenum
      file number to apply to
   devicename
      device name to apply to

Return Value
   Returns a 32 bit Long where the High Word is the number of rows and the 
   Low Word is the number of columns currently set.

Description
   Sets the maximum number of columns of characters of an output device 
   (console, printer or text file). If text sent to the device reaches the 
   width an automatic carriage return is generated.

   Using Width as a function returns the current console width in the low 
   word and the current height in the high word.

   If a device is not given then Width takes effect on the active 
   console/graphics screen, and a second argument specifying maximum number 
   of rows is allowed.

   In graphics modes Width is used to indirectly select the font size by 
   setting one of the character height * width pairs allowed (See 
   Screen (Graphics)). If  rows / cols is an invalid combination, no 
   changes are made to the screen display.

   Valid font heights are 8 pixels, 14 pixels and 16 pixels.  The fonts all 
   have a fixed width of 8 pixels.

   Using the Width command in graphic mode also forces a screen clear (Cls
   ).

Example

   Dim As Integer w
   w = Width
   Print "rows: " & HiWord(w)
   Print "cols: " & LoWord(w)

   ''Set up a graphics screen
   Const W = 320, H = 200
   ScreenRes W, H

   Dim As Integer twid, tw, th

   '' Fetch and print current text width/height:
   twid = Width()
   tw = LoWord(twid): th = HiWord(twid)
   Print "Default for current screen (8*8)"
   Print "Width:  " & tw
   Print "Height: " & th
   Sleep

   Width W\8, H\16 '' Use 8*16 font

   twid = Width()
   tw = LoWord(twid): th = HiWord(twid)
   Print "Set to 8*16 font"
   Print "Width:  " & tw
   Print "Height: " & th
   Sleep

   Width W\8, H\14 '' Use 8*14 font

   twid = Width()
   tw = LoWord(twid): th = HiWord(twid)
   Print "Set to 8*14 font"
   Print "Width:  " & tw
   Print "Height: " & th
   Sleep

   Width W\8, H\8 '' Use 8*8 font

   twid = Width()
   tw = LoWord(twid): th = HiWord(twid)
   Print "Set to 8*8 font"
   Print "Width:  " & tw
   Print "Height: " & th
   Sleep

Platform Differences
   * In a Windows console any values > 0 can be used in windowed mode.
   * On a DOS or Windows full-screen console, the valid dimensions depend 
     on the capabilities of the hardware.
   * Linux doesn't allow applications to change the console size.

Differences from QB
   * columns was limited to 40 or 80, while rows could be 25, 30, 43, 50 
     or 60, depending on the graphics hardware and screen mode being used.

See also
   * LoWord
   * HiWord
   * CsrLin
   * Pos



----------------------------------------------------------- KeyPgWindow ----
Window

Sets new view coordinates mapping for current viewport

Syntax
   Window [ [Screen] ( x1, y1 )-( x2, y2 ) ]

Parameters
   Screen
      Optional argument specifying y coordinates increase from top to 
      bottom.
   ( x1, y1 )-( x2, y2 )
      New floating point values corresponding to the opposite corners of 
      the current viewport.  If omitted, the Window coordinate mapping is 
      removed.

Description
   Window is used to define a new coordinates system. (x1, y1) and (x2, y2) 
   are the new coordinates to be mapped to the opposite corners of the 
   current viewport; all future coordinates passed to graphics primitive 
   statements will be affected by this new mapping. If Screen is omitted, 
   the new coordinates system will be Cartesian, that is, with y 
   coordinates increasing from bottom to top. Call Window with no argument 
   to disable the coordinates transformation.

   FreeBASIC's current behavior is to keep track of the corners of the 
   Window, rather than a specific coordinate mapping.  This means that the 
   coordinate mapping can change after calls to View.
   The Window corners are also currently taken into account when working on 
   image buffers, so when a Window is in effect, the coordinate mapping 
   will be different from image to image.

   When there is no Window in effect, there is no coordinate mapping in 
   effect, so the effective coordinate system is constant, independent of 
   image buffer sizes or View coordinates (if any).

Example
   '' The program shows how changing the view coordinates mapping for the current viewport changes the size of a figure drawn on the screen.
   '' The effect is one of zooming in and out:
   ''   - As the viewport coordinates get smaller, the figure appears larger on the screen, until parts of it are finally clipped,
   ''        because they lie outside the window.
   ''   - As the viewport coordinates get larger, the figure appears smaller on the screen.

   Declare Sub Zoom (ByVal X As Integer)
   Dim As Integer X = 500, Xdelta = 50

   Screen 12
   Do
     Do While X < 525 And X > 50
      X += Xdelta                      '' Change window size.
      Zoom(X)
      If Inkey <> "" Then Exit Do, Do  '' Stop if key pressed.
      Sleep 100
     Loop
     X -= Xdelta
     Xdelta *= -1                       '' Reverse size change.
   Loop

   Sub Zoom (ByVal X As Integer)
     Window (-X,-X)-(X,X)               '' Define new window.
     ScreenLock
     Cls
     Circle (0,0), 60, 11, , , 0.5, F   '' Draw ellipse with x-radius 60.
     ScreenUnlock
   End Sub

   Screen 13

   '' define clipping area
   View ( 10, 10 ) - ( 310, 150 ), 1, 15    

   '' set view coordinates
   Window ( -1, -1 ) - ( 1, 1 )             

   '' Draw X axis
   Line (-1,0)-(1,0),7
   Draw String ( 0.8, -0.1 ), "X"

   '' Draw Y axis
   Line (0,-1)-(0,1),7
   Draw String ( 0.1, 0.8 ), "Y"

   Dim As Single x, y, s

   '' compute step size
   s = 2 / PMap( 1, 0 )

   '' plot the function
   For x = -1 To 1 Step s
     y = x ^ 3
     PSet( x, y ), 14
   Next x

   '' revert to screen coordinates
   Window

   '' remove the clipping area
   View

   '' draw title
   Draw String ( 120, 160 ), "Y = X ^ 3"

   Sleep

Differences from QB
   * QBASIC preserves the coordinate mapping after subsequent calls to 
     VIEW.
   * FreeBASIC's current behavior is to preserve the WINDOW coordinates 
     after calls to VIEW, or when working on images, meaning that the 
     coordinate mapping may undergo scaling/translations. (If a WINDOW 
     hasn't been set, there is no coordinate mapping, and so it doesn't 
     change after calls to VIEW.)  The behavior may change in future, but 
     consistent behavior can be be assured over inconstent viewport 
     coordinates by re-calling WINDOW when you change the VIEW.

See also
   * Screen (Graphics)
   * View (Graphics)
   * PMap



------------------------------------------------------ KeyPgWindowtitle ----
WindowTitle

Sets the program window title

Syntax
   Declare Sub WindowTitle ( ByRef title As Const String )

Usage
   WindowTitle title

Parameters
   title
      the string to be assigned as new window title.

Description
   This statement is useful to change the program window title. The new 
   title set will become active immediately if the program already runs in 
   windowed mode, otherwise will become the new title for any window 
   produced by subsequent calls to the Screen (Graphics) or ScreenRes 
   statement. If this function is not called before setting a new windowed 
   mode via Screen (Graphics) or ScreenRes, the program window will use the 
   executable file name (without the extension) as title by default.
   This command has no effect in consoles.

Example
   'Set screen mode 
   Screen 13

   'Set the window title
   WindowTitle "FreeBASIC example program"

   Sleep

Platform Differences
   * Not present in DOS version / target of FreeBASIC

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Windowtitle.

Differences from QB
   * New to FreeBASIC

See also
   * ScreenControl (function SET_WINDOW_TITLE or GET_WINDOW_TITLE)
   * Screen (Graphics)
   * ScreenRes



----------------------------------------------------------- KeyPgWinput ----
Winput()

Reads a number of wide-characters from console or file

Syntax
   Declare Function WInput( ByVal num As Integer ) As WString
   Declare Function WInput( ByVal num As Integer, ByVal filenum As Long = 0 
   ) As WString

Usage
   result = WInput( num [, [#]filenum } )

Parameters
   num
      Number of characters to read.
   filenum
      File number of bound file or device.

Return Value
   Returns a WString of the characters read.

Description
   Reads a number of wide-characters from the console, or a bound 
   file/device specified by filenum.

   The first version waits for and reads n wide characters from the 
   keyboard buffer. Extended keys are not read. The characters are not 
   echoed to the screen.

   The second version waits for and reads n wide characters from a file or 
   device. The file position is updated.

   Note: FreeBASIC does not currently support reading wide-characters from 
   the console.

Example
   Dim char As WString * 2

   Dim filename As String, enc As String
   Dim f As Integer

   Line Input "Please enter a file name: ", filename
   Line Input "Please enter an encoding type (optional): ", enc
   If enc = "" Then enc = "ascii"

   f = FreeFile
   If Open(filename For Input Encoding enc As #f) = 0 Then
      
      Print "Press space to read a character from the file, or escape to exit."
      
      Do
         
         Select Case Input(1)
         
         Case " " 'Space
            
            If EOF(f) Then
               
               Print "You have reached the end of the file."
               Exit Do
               
            End If
            
            char = WInput(1, f)
            Print char & " (char no " & Asc(char) & ")"
            
         Case Chr(27) 'Escape
            
            Exit Do
            
         End Select
         
      Loop
      
      Close #f
      
   Else
      
      Print "There was an error opening the file."
      
   End If

Dialect Differences
   * Not available in the -lang qb dialect.

Differences from QB
   * QB does not support Unicode

See also
   * Input()
   * Open



------------------------------------------------------------- KeyPgWith ----
With

Statement block to allow implicit access to fields in a user defined type 
variable

Syntax
   With user_defined_var
      statements
   End With

Description
   The With...End With block allows the omission of the name of a variable 
   of a user-defined Type when referring to its fields. The fields may then 
   be accessed with just a single period (.) before them, e.g. if the Type 
   contains an field element called "element", then it could be accessed 
   within the With block as ".element".

   It can be used as a shorthand to save typing and avoid cluttering the 
   source. With can also be used with dereferenced pointers, as the second 
   example shows.

   With blocks may be nested.  In this case, only the innermost With block 
   is active, and any outer ones are ignored until the inner one is closed 
   again.  See the third example for an illustration of this.

   Internally, a reference to the variable is taken at the start of the 
   With block, and then is used to calculate any element accesses within 
   the block.  Note that this means that Goto should not be used to jump 
   into a With block, otherwise the reference will not have been set, and 
   the results of trying to access it will be undefined.

   Note for With block used inside member procedure:
   To access duplicated symbols defined as global outside the Type, add two 
   dots as prefix: "..SomeSymbol" (inside a With...End With block).

Example
   Type rect_type
      x As Single
      y As Single
   End Type

   Dim the_rectangle As rect_type
   Dim As Integer temp, t

   With the_rectangle
      temp = .x
      .x = 234 * t + 48 + .y
      .y = 321 * t + 2
   End With

   Type rect_type
      x As Single
      y As Single
   End Type

   Dim the_rectangle As rect_type Ptr

   the_rectangle = CAllocate( 5 * Len( rect_type ) )

   Dim As Integer loopvar, temp, t

   For loopvar = 0 To 4

     With the_rectangle[loopvar]

      temp = .x
      .x = 234 * t + 48 + .y
      .y = 321 * t + 2

     End With

   Next

   Type rect_type
      x As Single
      y As Single
   End Type

   Dim As rect_type rect1, rect2

   '' Nested With blocks
   With rect1

      .x = 1
      .y = 2

      With rect2

         .x = 3
         .y = 4

      End With

   End With

   Print rect1.x, rect1.y '' 1,  2
   Print rect2.x, rect2.y '' 3,  4

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __With.
   * In the -lang qb and -lang fblite dialects, variables declared inside 
     a With..End With block have a function-wide scope as in QB.
   * In the -lang fb and -lang deprecated dialects, variables declared 
     inside a With..End With block are visible only inside the block, and 
     can't be accessed outside it.

Differences from QB
   * New to FreeBASIC

See also
   * Type



------------------------------------------------------------- KeyPgWoct ----
WOct

Converts a number to a Unicode octal representation

Syntax
   Declare Function WOct ( ByVal number As UByte ) As WString
   Declare Function WOct ( ByVal number As UShort ) As WString
   Declare Function WOct ( ByVal number As ULong ) As WString
   Declare Function WOct ( ByVal number As ULongInt ) As WString
   Declare Function WOct ( ByVal number As Const Any Ptr ) As WString

   Declare Function WOct ( ByVal number As UByte, ByVal digits As Long ) As 
   WString
   Declare Function WOct ( ByVal number As UShort, ByVal digits As Long ) As
   WString
   Declare Function WOct ( ByVal number As ULong, ByVal digits As Long ) As 
   WString
   Declare Function WOct ( ByVal number As ULongInt, ByVal digits As Long ) 
   As WString
   Declare Function WOct ( ByVal number As Const Any Ptr, ByVal digits As 
   Long ) As WString

Usage
   result = WOct( number [, digits ] )

Parameters
   number
      Number to convert to octal representation.
   digits
      Desired number of digits in the returned string.

Return Value
   The Unicode octal representation of the number, truncated or padded with 
   zeros ("0") to fit the number of digits, if specified.

Description
   Returns the octal WString (Unicode) representation of number. Octal 
   digits range from 0 to 7.

   If you specify digits > 0, the result string will be exactly that 
   length.  It will be truncated or padded with zeros on the left, if 
   necessary.

   The length of the returned string will not be longer than the maximum 
   number of digits required for the type of number (3 characters for Byte, 
   6 for Short, 11 for Long, and 22 for LongInt)

Example
   Print WOct(54321)
   Print WOct(54321, 4)
   Print WOct(54321, 8)

   will produce the output:

   152061
   2061
   00152061

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Woct.

Platform Differences
   * Unicode strings are not supported in the DOS port of FreeBASIC.

Differences from QB
   * In QBASIC Unicode was not supported.

See also
   * WBin
   * WHex



------------------------------------------------------------ KeyPgWrite ----
Write

Outputs a comma-separated list of values to the screen

Syntax
   Write [ expressionlist ]

Parameters
   expressionlist
      Comma-separated list of items to print

Description
   Outputs the values in expressionlist to the screen. The values are 
   separated with commas, and strings are enclosed in double quotes. 
   Numeric values with an absolute value of less than one are prefixed with 
   a zero (0) if none is given (e.g. 0.5, -0.123).  Floating-point numbers 
   with absolute values greater than or equal to 10^16, or with absolute 
   values greater than 0 and less than 10^-5 are printed in scientific 
   notation (e.g. 1.8e+019, 3e-005)

   If no expression list is given, Write outputs a carriage return.

Example

   Dim i As Integer = 10
   Dim d As Double = 123.456
   Dim s As String = "text"

   Write 123, "text", -.45600
   Write
   Write i, d, s

   will produce the output:


   123,"text",-0.456

   10,123.456,"text"

Differences from QB
   * QBASIC might print format floating-point values in slightly different 
     ways.

See also
   * Write #
   * Print
   * ?



---------------------------------------------------------- KeyPgWritePp ----
Write #

Outputs a comma-separated list of values to a text file or device

Syntax
   Write # filenum , [ expressionlist ]

Parameters
   filenum
      File number of an open file or device opened for Output or Append.
   expressionlist
      Comma-separated list of items to print

Description
   Outputs the values in expressionlist to the text file or device bound to 
   filenum. The values are separated with commas, and strings are enclosed 
   in double quotes. Numeric values greater than zero (0) and less than one 
   (1) are prefixed with a zero (0) if none is given (e.g., a value of 
   -.123 will be output as -0.123). Extra zeroes are truncated.

   If no expression list is given, Write # outputs a carriage return (note 
   that the comma after filenum is still necessary, even if no expression 
   list is given).
   The purpose of Write # is to create a file that can be read back by 
   using Input #.

Example

   Const filename As String = "file.txt"

   Dim filenum As Integer = FreeFile()
   If 0 <> Open(filename, For Output, As filenum) Then
      Print "error opening " & filename & " for output."
      End -1
   End If

   Dim i As Integer = 10
   Dim d As Double = 123.456
   Dim s As String = "text"

   Write #filenum, 123, "text", -.45600
   Write #filenum,
   Write #filenum, i, d, s

   will produce the file:


   123,"text",-0.456

   10,123.456,"text"

Differences from QB
   * None

See also
   * Write
   * Print #
   * ? #
   * Input #



-------------------------------------------------------- KeyPgWriteFile ----
Write (File Access)

File access specifier

Syntax
   Open filename As String For Binary Access Write As #filenum As Integer

Description
   Specifier for the Access clause in the Open statement.  Write specifies 
   that the file is accessible for output.

Example
   See example at Access

Differences from QB
   * None known.

See also
   * Access
   * Open



----------------------------------------------------------- KeyPgWspace ----
WSpace

Creates a WString of a given length filled with spaces (" ")

Syntax
   Declare Function WSpace( ByVal count As Integer ) As WString

Usage
   result = WSpace( count )

Parameters
   count
      An integer type specifying the length of the string to be created.

Return Value
   The created WString. An empty string will be returned if count <= 0.

Description
   WSpace creates a wstring (wide character string- Unicode) with the 
   specified number of spaces.

Example
   Dim a As WString * 10
   a = "x" + WSpace(3) + "x"
   Print a ' prints: x   x

Platform Differences
   * Unicode strings are not supported in the DOS port of FreeBASIC.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Wspace.

Differences from QB
   * New to FreeBASIC

See also
   * Space
   * WString



------------------------------------------------------------- KeyPgWstr ----
WStr

Returns a wide-character string representation of a number or ASCII 
character string

Syntax
   Declare Function WStr ( ByVal n As Byte ) As WString
   Declare Function WStr ( ByVal n As UByte ) As WString
   Declare Function WStr ( ByVal n As Short ) As WString
   Declare Function WStr ( ByVal n As UShort ) As WString
   Declare Function WStr ( ByVal n As Long ) As WString
   Declare Function WStr ( ByVal n As ULong ) As WString
   Declare Function WStr ( ByVal n As LongInt ) As WString
   Declare Function WStr ( ByVal n As ULongInt ) As WString
   Declare Function WStr ( ByVal n As Single ) As WString
   Declare Function WStr ( ByVal n As Double ) As WString
   Declare Function WStr ( ByRef str As Const String ) As WString
   Declare Function WStr ( ByVal str As Const WString Ptr ) As WString

Usage
   result = WStr( number )
      or
   result = WStr( string )

Parameters
   number
      Numeric expression to convert to a wide-character string.
   string
      String expression to convert to a wide-character string.

Return Value
   Returns the wide-character representation of the numeric or string 
   expression.

Description
   WStr converts numeric variables to their wide-character string 
   representation. It is the wide-character equivalent to Str.

   WStr also converts ASCII character strings to Unicode character strings. 
   If a wide-character string is given, that string is returned unmodified.

Example
   #if defined( __FB_WIN32__ )
   #include "windows.bi"
   #endif

   Dim zs As ZString * 20
   Dim ws As WString * 20

   zs = "Hello World"
   ws = WStr(zs)

   #if defined( __FB_WIN32__ )

   MessageBox(null, ws, WStr("Unicode 'Hello World'"), MB_OK Or MB_ICONINFORMATION)

   #else

   Print ws
   Print WStr("Unicode 'Hello World'")

   #endif

Platform Differences
   * DOS does not support WStr.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Wstr.

Differences from QB
   * New to FreeBASIC

See also
   * Str
   * WString



---------------------------------------------------------- KeyPgWstring ----
WString

Standard data type: wide character string

Syntax
   Dim variable As WString * size
   Dim variable As WString Ptr

Description
   A WString is a fixed-size array of wide-chars that never overflows if 
   the size is known at compile-time. It has no descriptor, and does never 
   resize unless it's a pointer and Allocate/Reallocate/Deallocate are used 
   directly. When the variable has a fixed size (numeric constant, or 
   expression that can be evaluated at compile time), FreeBASIC avoids any 
   overflow that could occur on assignment, by truncating the contents to a 
   length of size - 1.

   The end of the string is marked by the character 0 automatically added 
   by the FreeBASIC string handling functions, so that character must never 
   be part of a WString or the content will be truncated. The character 0 
   will be appended when the string is created, and the length will be 
   calculated by scanning the string for the first null character.

   In a WString, Len returns the size of the contained string and SizeOf 
   returns the space allocated to the WString.  SizeOf only works if the 
   size is known by the compiler, i.e. a fixed-size WString variable is 
   passed directly, not as a dereferenced pointer or a ByRef function 
   argument.

   This type is provided for support non-Latin based alphabets. Any 
   intrinsic string function like Left will work with WStrings too, as will 
   any string operator.

   When processing source files, FreeBASIC can parse ASCII files with 
   Unicode escape sequences (\u),  or UTF-8, UTF-16LE, UTF-16BE, UTF-32LE 
   and UTF-32BE files, as long as they were saved with Byte Order Mark 
   (BOM).

   The FreeBASIC text file functions can read and write Unicode files in 
   different encodings, provided the Encoding is specified when the file is 
   opened. The text is automatically converted to the internal encoding at 
   read and converted back to the file encoding at write.

   SizeOf( WString ) returns the number of bytes used by a WString 
   character in the current platform.

   When allocating dynamic memory for a WString, the safest is to use 
   CAllocate (or at worst, to use Allocate followed by an immediate 
   assignment of the string data, as in the second example), in order to 
   avoid creating string data without any null character (the terminal 
   character for a WString).

   Note : When any operand of a binary operator (as assignment, equal, +, 
   *, ...) consists in dereferencing a 'Wstring Ptr' pointer ('pw'), this 
   can give a 'Wstring' string or a 'Numeric' variable, depending on the 
   other operand. If the other operand is numeric, so the dereferenced '
   Wstring Ptr' pointer ('*pw') will be treated as a 'Numeric' reference to 
   the one character pointed. If a 'Wstring' pointer indexing '[]' operator 
   is used as dereferencing syntax ('pw[n]'), it is basically a short-cut 
   version of the 'String' indexing '[]' operator ('(*pw)[n]').

Example
   Dim As WString * 13 str1 => "hello, world"
   Print str1
   Print Len(str1)    'returns 12, the length of the string it contains 
   Print SizeOf(str1) 'returns 13 * sizeof(wstring), the number of bytes used by the variable

   Dim As WString Ptr str2
   str2 = Allocate( 13 * Len(WString) )
   *str2 = "hello, world"
   Print *str2
   Print Len(*str2)      'returns 12, the length of the string it points to

Platform Differences
   Support for wstrings relies in the C runtime library available in the 
   platform and the internal format may vary.
      * Unicode is not supported in the DOS port of FreeBASIC. In this 
        port a character takes up always 1 byte and Wstrings will behave as 
        standard ASCII Zstrings
      * On Win32, FreeBASIC wstrings are encoded in UCS-2 which uses two 
        bytes (16 bits) for each character and, as such, can only encode 
        the first 65,536 code points of Unicode, that is, the Basic 
        Multilingual Plane (BMP). FreeBASIC does not support Win32 UTF-16 
        4-byte surrogate encoding beyond the BMP.
      * On Linux wstrings are encoded in UCS-4 and a character takes up 4 
        bytes.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Wstring.

Differences from QB
   * New to FreeBASIC

See also
   * String (data type)
   * ZString (data type)
   * String (function)
   * WString (function)
   * WSpace
   * WStr
   * WChr
   * WBin
   * WHex
   * WOct
   * Winput()
   * Standard Data Type Limits
   * Extends Wstring



-------------------------------------------------- KeyPgWstringFunction ----
Wstring (Function)

Fills a WString with a certain length of a certain wide character

Syntax
   Declare Function WString ( ByVal count As Integer, ByVal ch_code As Long 
   ) As WString
   Declare Function WString ( ByVal count As Integer, ByRef ch As Const 
   WString ) As WString

Usage
   result = WString( count, ch_code )
      or
   result = WString( count, ch )

Parameters
   count
      An Integer specifying the length of the string to be created.
   ch_code
      A Long specifying the Unicode char to be used to fill the string.
   ch
      A WString whose first character is to be used to fill the string.

Return Value
   The created WString. An empty string will be returned if either ch is an 
   empty string, or count <= 0.

Description
   WString generates a temporary WString filled with count copies of a 
   Unicode character. This string can be printed or assigned to a 
   previously Dimed WString.

Example
   Print WString( 4, 934 )         
   Print WString( 5, WStr("Indeed") )   
   End 0

   &#934;&#934;&#934;&#934;
   IIIII
   
Platform Differences
   * Unicode strings are not supported in the DOS port of FreeBASIC.

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Wstring.

Differences from QB
   * QBasic does not support Unicode

See also
   * String (data type)
   * WSpace
   * WString (data type)




============================================================================
    X

------------------------------------------------------------ KeyPgOpXor ----
Operator Xor (Exclusive Disjunction)

Returns the bitwise-xor (exclusive disjunction) of two numeric values

Syntax
   Declare Operator Xor ( ByRef lhs As T1, ByRef rhs As T2 ) As Ret

Usage
   result = lhs Xor rhs

Parameters
   lhs
      The left-hand side expression.
   T1
      Any numeric or boolean type.
   rhs
      The right-hand side expression.
   T2
      Any numeric or boolean type.
   Ret
      A numeric or boolean type (varies with T1 and T2).

Return Value
   Returns the bitwise-xor of the two operands.

Description
   This operator returns the bitwise-exclusion of its operands, a logical 
   operation that results in a value with bits set depending on the bits of 
   the operands (for conversion of a boolean to an integer, false or true 
   boolean value becomes 0 or -1 integer value).

   The truth table below demonstrates all combinations of a 
   boolean-exclusion operation:

      +-------+-------+------+
      |Lhs Bit|Rhs Bit|Result|
      |0      |0      |0     |
      |1      |0      |1     |
      |0      |1      |1     |
      |1      |1      |0     |
      +-------+-------+------+

   No short-circuiting is performed - both expressions are always 
   evaluated.

   The return type depends on the types of values passed. Byte, UByte and 
   floating-point type values are first converted to Integer. If the left 
   and right-hand side types differ only in signedness, then the return 
   type is the same as the left-hand side type (T1), otherwise, the larger 
   of the two types is returned. Only if the left and right-hand side types 
   are both Boolean, the return type is also Boolean.

   This operator can be overloaded for user-defined types.

Example
   ' Using the XOR operator on two numeric values
   Dim As UByte numeric_value1, numeric_value2
   numeric_value1 = 15 '00001111
   numeric_value2 = 30 '00011110

   'Result =  17  =     00010001
   Print numeric_value1 Xor numeric_value2
   Sleep

   ' Using the XOR operator on two conditional expressions
   Dim As UByte numeric_value1, numeric_value2
   numeric_value1 = 10
   numeric_value2 = 15

   If numeric_value1 = 10 Xor numeric_value2 = 20 Then Print "Numeric_Value1 equals 10 or Numeric_Value2 equals 20"
   Sleep

   ' This will output "Numeric_Value1 equals 10 or Numeric_Value2 equals 20"
   ' because only the first condition of the IF statement is true

Dialect Differences
   * In the -lang qb dialect, this operator cannot be overloaded.

Differences from QB
   * None

See also
   * Operator Truth Tables



----------------------------------------------------------- KeyPgXorGfx ----
Xor

Parameter to the Put graphics statement which uses a bit-wise Xor as the 
blitting method

Syntax
   Put [ target, ] [ STEP ] ( x,y ), source [ ,( x1,y1 )-( x2,y2 ) ], Xor

Parameters
   Xor
      Required.

Description
   The Xor method combines each source pixel with the corresponding 
   destination pixel, using the bit-wise Xor function.  The result of this 
   is output as the destination pixel.
   This method works in all graphics modes.  There is no mask color, 
   although color values of 0 (RGBA(0, 0, 0, 0) in full-color modes) will 
   have no effect, because of the behavior of Xor.

   In full-color modes, each component (red, green, blue and alpha) is kept 
   in a discrete set of bits, so the operation can be made to only affect 
   some of the channels, by making sure the all the values of the other 
   channels are set to 0.

Example
   ''open a graphics window
   ScreenRes 320, 200, 16

   ''create a sprite containing a circle
   Const As Integer r = 32
   Dim c As Any Ptr = ImageCreate(r * 2 + 1, r * 2 + 1, 0)
   Circle c, (r, r), r, RGBA(255, 255, 255, 0), , , 1, f

   ''put the three sprites, overlapping each other in the middle
   Put (146 - r, 108 - r), c, Xor
   Put (174 - r, 108 - r), c, Xor
   Put (160 - r,  84 - r), c, Xor

   ''free the memory used by the sprite
   ImageDestroy c

   ''pause the program before closing
   Sleep

Differences from QB
   * None

See also
   * Xor
   * Put (Graphics)




============================================================================
    Y

------------------------------------------------------------- KeyPgYear ----
Year

Gets the year from a Date Serial

Syntax
   Declare Function Year ( ByVal date_serial As Double ) As Long

Usage
   #include "vbcompat.bi"
   result = Year( date_serial )

Parameters
   date_serial
      the date

Return Value
   Returns the year from a  variable containing a date in  Date Serial  
   format. 

Description

   The compiler will not recognize this function unless vbcompat.bi is 
   included.

Example
   #include "vbcompat.bi"

   Dim a As Double = DateSerial (2005, 11, 28) + TimeSerial(7, 30, 50)

   Print Format(a, "yyyy/mm/dd hh:mm:ss "); Year(a)

Differences from QB
   * Did not exist in QB. This function appeared in PDS and VBDOS

See also
   * Date Serials




============================================================================
    Z

---------------------------------------------------------- KeyPgZstring ----
ZString

Standard data type: 8 bit character string

Syntax
   Dim variable As ZString * size
   Dim variable As ZString Ptr

Description
   A ZString is a C-style fixed-size array of chars.  It has no descriptor 
   so its length is calculated faster to pass it as an argument to 
   functions. When the variable has a fixed size (numeric constant, or 
   expression that can be evaluated at compile time), FreeBASIC avoids any 
   overflow that could occur on assignment, by truncating the contents to a 
   length of size - 1.

   A ZString Ptr can point to a standard ZString, also can be used to 
   implement an "user-managed" ZString, in this case Allocate/Reallocate/
   Deallocate must be used to size-resize-dispose it and is up  to the user 
   to avoid overflows . 

   The end of the string is marked by a null character (0 ASCII). This is 
   automatically added by the FreeBASIC string handling functions.  A null 
   character will be appended when the string is created, and the length 
   will be calculated by scanning the string for the first null character. 
   A null character (e.g. Chr(0)) may never be contained in the text of a 
   ZString or the rest of the string will be truncated.

   In a ZString, Len returns the size of the contained string and SizeOf 
   returns the space allocated to the ZString.  SizeOf only works if the 
   size is known by the compiler, i.e. a fixed-size ZString variable is 
   passed directly, not as a dereferenced pointer or a ByRef function 
   argument.

   Any intrinsic string functions like Left will work with ZString's too, 
   plus any string operator.

   This type is provided for easy interfacing with C libraries and to also 
   replace the fixed-length strings, that can't be managed through 
   pointers.
   Any string type argument may be directly passed to a procedure referring 
   to a parameter declared as ZString Ptr. The compiler performs itself an 
   automatic conversion (without warning message) between any string type 
   argument and the ZString Ptr type parameter.

   When allocating dynamic memory for a ZString, the safest is to use 
   CAllocate (or at worst, to use Allocate followed by an immediate 
   assignment of the string data, as in the second example), in order to 
   avoid creating string data without any null character (the terminal 
   character for a ZString).

   Note : When any operand of a binary operator (as assignment, equal, +, 
   *, ...) consists in dereferencing a 'Zstring Ptr' pointer ('pz'), this 
   can give a 'Zstring' string or a 'Ubyte' variable, depending on the 
   other operand. If the other operand is numeric, so the dereferenced '
   Zstring Ptr' pointer ('*pz') will be treated as a 'Ubyte' reference to 
   the one character pointed. If a 'Zstring' pointer indexing '[]' operator 
   is used as dereferencing syntax ('pz[n]'), it is basically a short-cut 
   version of the 'String' indexing '[]' operator ('(*pz)[n]').

Example
   Dim As ZString * 13 str1 => "hello, world"
   Print str1
   Print Len(str1)     'returns 12, the size of the string it contains 
   Print SizeOf(str1)  'returns 13, the size of the variable

   Dim As ZString Ptr str2
   str2 = Allocate( 13 )
   *str2 = "hello, world"
   Print *str2
   Print Len(*str2)     'returns 12, the size of the string it contains 

Dialect Differences
   * Not available in the -lang qb dialect unless referenced with the 
     alias __Zstring.

Differences from QB
   * New to FreeBASIC

See also
   * String
   * WString
   * Standard Data Type Limits
   * Extends Zstring
